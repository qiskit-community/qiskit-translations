msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-14 08:10+0000\n"
"PO-Revision-Date: 2024-01-08 01:30\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /main/optimization/docs/locale/en/LC_MESSAGES/tutorials/12_quantum_random_access_optimizer.po\n"
"X-Crowdin-File-ID: 10040\n"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:9
msgid "This page was generated from `docs/tutorials/12_quantum_random_access_optimizer.ipynb`__."
msgstr "このページは `docs/tutorials/12_quantum_random_access_optimizer.ipynb`__ から生成されました。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:9
msgid "Quantum Random Access Optimization"
msgstr "量子ランダムアクセス最適化 (Quantum Random Access Optimization)"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:20
msgid "The Quantum Random Access Optimization (QRAO) module is designed to enable users to leverage a new quantum method for combinatorial optimization problems [1]. This approach incorporates Quantum Random Access Codes (QRACs) as a tool to encode multiple classical binary variables into a single qubit, thereby saving quantum resources and enabling exploration of larger problem instances on a quantum computer. The encodings produce a local quantum Hamiltonian whose ground state can be approximated with standard algorithms such as VQE, and then rounded to yield approximation solutions of the original problem."
msgstr "量子ランダムアクセス最適化（Quantum Random Access Optimization: QRAO）モジュールは、組合せ最適化問題[1] に新しい量子手法を活用できるように設計されています。この手法は、量子ランダムアクセスコード（Quantum Random Access Codes: QRAC）を、複数の古典的なバイナリ変数を1つの量子ビットにエンコードするツールとして組み込んだもので、これにより量子リソースを節約し、量子コンピューター上でより大規模な問題インスタンスを探索することが可能になります。この符号化により、局所的な量子ハミルトニアンが生成され、その基底状態はVQEなどの標準的なアルゴリズムで近似することができ、その後、元の問題の近似解を得るために丸められます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:23
msgid "QRAO through a series of 3 classes: 1. The encoding class (``QuantumRandomAccessEncoding``): This class encodes the original problem into a relaxed problem that requires fewer resources to solve. 2. The rounding schemes (``SemideterministicRounding`` and ``MagicRounding``): This scheme is used to round the solution obtained from the relaxed problem back to a solution of the original problem. 3. The optimizer class (``QuantumRandomAccessOptimizer``): This class performs the high-level optimization algorithm, utilizing the capabilities of the encoding class and the rounding scheme."
msgstr "QRAOは3つのクラスで構成されています: 1. 符号化クラス(``QuantumRandomAccessEncoding``): このクラスは元の問題を、解くのに必要なリソースがより少ない緩和された問題にエンコードします。 2. 丸めスキーム (``SemideterministicRounding`` と ``MagicRounding``): このスキームは、緩和された問題から得られた解を元の問題の解に丸めるために使用されます。 3. オプティマイザークラス(``QuantumRandomAccessOptimizer``): このクラスは、符号化クラスと丸めスキームの機能を利用して、高レベルの最適化アルゴリズムを実行します。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:26
msgid "*References*"
msgstr "*参考文献*"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:28
msgid "[1] Bryce Fuller et al., *Approximate Solutions of Combinatorial Problems via Quantum Relaxations,* `arXiv:2111.03167 <https://arxiv.org/abs/2111.03167>`__"
msgstr "[1] Bryce Fuller et al., *Approximate Solutions of Combinatorial Problems via Quantum Relaxations,* `arXiv:2111.03167 <https://arxiv.org/abs/2111.03167>`__"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:54
msgid "Set up a combinatorial optimization problem"
msgstr "組合せ最適化問題を設定する"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:56
msgid "In this tutorial, we will consider a random max-cut problem instance and use QRAO to try to find a maximum cut; in other words, a partition of the graph's vertices (nodes) into two sets that maximizes the number of edges between the sets."
msgstr "このチュートリアルでは、ランダムなマックスカット問題のインスタンスを検討し、QRAO を使用して最大カットを見つけようとします。 言い換えれば、グラフの頂点 (ノード) を 2 つのセットに分割し、セット間のエッジの数を最大化します。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:58
msgid "To begin, we utilize the ``Maxcut`` class from Qiskit Optimization's application module. It allows us to generate a ``QuadraticProgram`` representation of the given graph."
msgstr "はじめに、Qiskit Optimizationのアプリケーションモジュールにある ``Maxcut`` クラスを利用します。これにより、与えられたグラフの ``QuadraticProgram`` 表現を生成することができます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:60
msgid "Note that once our problem has been represented as a ``QuadraticProgram``, it will need to be converted to the correct type, a `quadratic unconstrained binary optimization (QUBO) <https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization>`__ problem, so that it is compatible with QRAO. A ``QuadraticProgram`` generated by ``Maxcut`` is already a QUBO, but if you define your own problem be sure you convert it to a QUBO before proceeding. Here is `a tutorial <https://qiskit.org/documentation/optimization/tutorials/02_converters_for_quadratic_programs.html>`__ on converting ``QuadraticPrograms``."
msgstr "問題が ``QuadraticProgram`` として表現されたら、QRAOと互換性があるように、正しい型である `二次制約なし二項最適化（QUBO） <https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization>`__ 問題に変換する必要があることに注意してください。 ``Maxcut`` によって生成された``QuadraticProgram`` はすでにQUBOですが、もし自分で問題を定義する場合には、先に進む前に必ずQUBOに変換してください。 ``QuadraticPrograms`` の変換についての `チュートリアルはこちら <https://qiskit.org/documentation/optimization/tutorials/02_converters_for_quadratic_programs.html>`__ です。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:163
msgid "Encode the problem into a quantum Hamiltonian"
msgstr "量子ハミルトニアンに問題を符号化する"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:165
msgid "Once we have appropriately configured our problem, we proceed to encode it using the ``QuantumRandomAccessEncoding`` class from the ``qrao`` module. This encoding step allows us to generate a quantum Hamiltonian operator that represents our problem. In particular, we employ a Quantum Random Access Code (QRAC) to encode multiple classical binary variables (corresponding to the nodes of our max-cut graph) into each qubit."
msgstr "問題を適切に設定したら、 ``qrao`` モジュールの ``QuantumRandomAccessEncoding`` クラスを使って符号化します。この符号化ステップによって、問題を表す量子ハミルトニアン演算子を生成することができます。特に、量子ランダムアクセスコード(QRAC) を用いて、複数の古典バイナリ変数(マックスカットグラフのノードに対応) を各量子ビットにエンコードします。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:167
msgid "It's important to note that the resulting \"relaxed\" Hamiltonian, produced by this encoding, will not be diagonal. This differs from the standard workflow in ``qiskit-optimization``, which typically generates a diagonal (Ising) Hamiltonian suitable for optimization using a ``MinimumEigenOptimizer``. You can find a tutorial on the ``MinimumEigenOptimizer`` `here <https://qiskit.org/documentation/optimization/tutorials/03_minimum_eigen_optimizer.html>`__."
msgstr "この符号化によって生成される \"relaxed\" ハミルトニアンは対角ではないことに注意することが重要です。これは 通常は ``MinimumEigenOptimizer`` を使った最適化に適した対角（Ising）ハミルトニアンを生成する ``qiskit-optimization`` の標準的なワークフローとは異なります。 ``MinimumEigenOptimizer`` の `チュートリアルはこちら<https://qiskit.org/documentation/optimization/tutorials/03_minimum_eigen_optimizer.html>`__ です。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:169
msgid "In our encoding process, we employ a :math:`(3,1,p)-`\\ QRAC, where each qubit can accommodate a maximum of 3 classical binary variables. The parameter :math:`p` represents the bit recovery probability achieved through measurement. Depending on the nature of the problem, some qubits may have fewer than 3 classical variables assigned to them. To evaluate the compression achieved, we can examine the ``compression_ratio`` attribute of the encoding, which provides the ratio between the number of original binary variables and the number of qubits used (at best, a factor of 3)."
msgstr "私たちの符号化プロセスでは、 :math:`(3,1,p)-`\\ QRAC を採用しており、各量子ビットは最大 3 つの古典的なバイナリ変数に対応できます。 パラメータ :math:`p` は、測定によって得られたビット回復確率を表します。 問題の性質によっては、一部の量子ビットに割り当てられている古典的な変数が 3 つ未満である場合があります。 達成された圧縮を評価するには、符号化の ``compression_ratio`` 属性を調べることができます。これは、元のバイナリ変数の数と使用される量子ビットの数の間の比率 (最大で 3 の係数) を提供します。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:249
msgid "Solve the problem using the ``QuantumRandomAccessOptimizer``"
msgstr "``QuantumRandomAccessOptimizer`` を使って問題を解く"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:251
msgid "Having successfully encoded our input problem as a relaxed Hamiltonian, we proceed to solve it using the ``QuantumRandomAccessOptimizer``. This optimizer allows us to find an approximate solution to the relaxed problem by leveraging quantum computing techniques."
msgstr "入力問題を緩和されたハミルトニアンとして符号化することに成功したので、 ``QuantumRandomAccessOptimizer`` を使って解を求めます。このオプティマイザーは、量子計算技術を活用することで、緩和された問題の近似解を求めることができます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:253
msgid "To set up the optimizer, we need to specify two crucial components:"
msgstr "オプティマイザーを設定するには、2つの重要なコンポーネントを指定する必要があります："

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:255
msgid "**Minimum Eigensolver**: We specify a minimum eigensolver to heuristically search for the ground state of the relaxed problem Hamiltonian. As an example, we can use the Variational Quantum Eigensolver (VQE). For simulation purposes, we'll employ an simulator, but you can choose a quantum device as the backend if desired."
msgstr "**最小固有値解法**: 緩和問題のハミルトニアンの基底状態を発見的に探索する最小固有値解法を指定します。例として、変分量子固有値ソルバー(VQE) を使うことができます。シミュレーションのために、シミュレーターを使用しますが、必要であればバックエンドに量子デバイスを選択することもできます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:256
msgid "**Rounding Scheme**: To map the ground state results back to a solution for the original problem, we specify a rounding scheme. By default, the ``SemideterministicRounding`` is used, but alternative scheme, ``MagicRounding``, is also available."
msgstr "**丸めスキーム**: 基底状態の結果を元の問題の解に戻すために、丸めスキームを指定します。デフォルトでは ``SemideterministicRounding`` が使用されますが、 ``MagicRounding`` も使用できます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:302
msgid "Finally, we move forward with solving the problem by invoking the ``solve()`` method. It's important to note that when calling ``solve()``, we pass the ``problem`` itself as an argument. Although we previously used ``encode()`` in ``QuantumRandomAccessEncoding`` to provide a clear understanding of the flow, ``solve(problem)`` automatically encodes the problem internally using ``QuantumRandomAccessEncoding``. This provides a streamlined and simplified workflow that eliminates the need for explicit encoding steps."
msgstr "最後に、 ``solve()`` メソッドを呼び出して問題を解きます。 ``solve()`` を呼び出すときに、 ``problem`` そのものを引数として渡すことに注意することが重要です。以前は ``QuantumRandomAccessEncoding`` の ``encode()`` を使って流れを明確に理解していましたが、 ``solve(problem)`` は自動的に ``QuantumRandomAccessEncoding`` を使って問題を内部的に符号化します。これにより、明示的な符号化手順が不要になり、合理的で簡素化されたワークフローが実現します。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:305
msgid "The result is provides us as a ``QuantumRandomAccessOptimizationResult``. The ``x`` contains the binary values representing the best solution found, while the ``fval`` contains the corresponding objective value."
msgstr "結果は ``QuantumRandomAccessOptimizationResult`` として提供されます。 ``x`` には、見つかった最適解を表すバイナリ値が格納され、 ``fval`` には対応する目的値が格納されます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:307
msgid "The ``relaxed_fval`` provides the expectation value of the relaxed Hamiltonian, adjusted to be in the units of the original optimization problem. For maximization problems, the best possible relaxed function value will always be greater than or equal to the best possible objective function value of the original problem. In practice, this often holds true for the best found value and best found objective function value as well."
msgstr "``relaxed_fval`` は、元の最適化問題の単位になるように調整された緩和ハミルトニアンの期待値を提供します。最大化問題では、可能な限り最良の緩和された関数値は、常に元の問題の可能な限り最良の目的関数値以上となります。実際には、これは最良の発見値と最良の発見された目的関数値にも当てはまることが多いです。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:369
msgid "Interpret the solution"
msgstr "解の解釈"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:380
msgid "In the context of `max-cut <https://en.wikipedia.org/wiki/Maximum_cut>`__, the result's \"optimal value\" tells us which subset each node belongs to given the partition found by the optimizer."
msgstr "`max-cut <https://en.wikipedia.org/wiki/Maximum_cut>`__ の文脈では、結果の \"最適値\" は、オプティマイザーによって発見されたパーティションが与えられたときに、各ノードがどのサブセットに属するかを教えてくれます。"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:440
msgid "Inspect the results of subroutines"
msgstr "サブルーチンの結果の検査"

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:451
msgid "The `MinimumEigensolverResult <https://qiskit.org/ecosystem/algorithms/stubs/qiskit_algorithms.MinimumEigensolverResult.html>`__ that results from performing VQE on the relaxed Hamiltonian is available:"
msgstr "緩和されたハミルトニアンに対してVQEを実行した結果の `MinimumEigensolverResult <https://qiskit.org/ecosystem/algorithms/stubs/qiskit_algorithms.MinimumEigensolverResult.html>`__ が利用できます："

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:497
msgid "The result of the rounding scheme is also worth considering. In this example, we used the ``SemideterministricRounding``. It's important to note that with semi-deterministic rounding, a single sample is generated as the result, making it the optimal solution candidate."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:499
msgid "However, if we use the ``MagicRounding`` instead, multiple samples would be generated, each with a probability associated with it. These probabilities sum up to one, providing a distribution of potential optimal solutions."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:546
msgid "Exact Problem Solution with the ``NumpyMinimumEigensolver``"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:548
msgid "To assess the performance of QRAO in approximating the optimal solution, we can utilize the ``NumpyMinimumEigensolver``, an exact classical optimizer. We can obtain the exact optimal solution to the problem as follows:"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:606
msgid "The approximation ratio (QRAO's objective function value divided by the optimal objective function value) tells us how closely QRAO approximated the optimal solution to the problem."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:660
msgid "Solve the problem using the ``QuantumRandomAccessOptimizer`` with ``MagicRounding``"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:662
msgid "Magic rounding is a quantum technique employed to map the ground state results of our encoded Hamiltonian back to a solution of the original problem. Unlike semi-deterministic rounding, magic rounding requires a quantum backend, which can be either hardware or a simulator. The backend is passed to the ``MagicRounding`` class through a ``Sampler``, which also determines the total number of shots (samples) that magic rounding will utilize. Note that to specify the backend, you need to choose a ``Sampler`` from providers such as Aer or IBM Runtime. Consequently, we need to specify ``Estimator`` and ``Sampler`` for the optimizer and the rounding scheme, respectively."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:665
msgid "In practice, users may choose to set a significantly higher number of magic rounding shots compared to the shots used by the minimum eigensolver for the relaxed problem. This difference arises because the minimum eigensolver estimates expectation values, while the magic rounding scheme returns the sample corresponding to the maximum function value found. The number of magic rounding shots directly impacts the diversity of the computational basis we can generate. When estimating an expectation value, increasing the number of shots enhances the convergence to the true value. However, when aiming to identify the largest possible function value, we often sample from the tail of a distribution of outcomes. As a result, until we observe the highest value outcome in our distribution, each additional shot increases the expected return value."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:668
msgid "In this tutorial, we use the ``Estimator`` for solving the relaxed Hamiltonian and the ``Sampler`` for performing magic rounding. Here, 10 times as many shots are used in the ``Sampler``. As the number of qubits increases, you may need more shots or ``weighted`` basis sampling, as explained above.\""
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:759
msgid "Since magic rounding relies on nondeterministic measurements, the method collects a number of samples based on the shots count provided to the ``Sampler`` mentioned earlier. These samples are then consolidated, taking into account duplicates and calculating the empirical probability for each ``SolutionSample``. Each sample in the consolidation process includes a corresponding function value (``fval``)."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:761
msgid "From the consolidated samples, we select the sample with the \"optimal\" function value. In the case of a max-cut problem, this means choosing the sample with the largest function value as our solution."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:843
msgid "Alternative: Solve the Problem in Two Explicit Steps"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:845
msgid "In the previous part of this tutorial, we utilized the ``qrao.solve()`` method, which solved the encoded problem (the ground state of the relaxed Hamiltonian) and performed rounding to map the ground state results back to a solution of the original problem. However, it is also possible to explicitly break down the calculation into these two distinct steps. This can be beneficial, especially when comparing solutions obtained across multiple rounding schemes applied to a candidate ground state."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:847
msgid "In this section, we will explore how to perform each of these steps explicitly."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:850
msgid "Manually solve the relaxed problem."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:852
msgid "Let's start by invoking the ``qrao.solve_relaxed()`` method to directly solve the relaxed problem encoded by ``QuantumRandomAccessEncoding``. This method allows us to focus solely on solving the relaxed problem without performing rounding."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:854
msgid "By invoking ``qrao.solve_relaxed()``, we obtain two essential outputs:"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:856
msgid "``MinimumEigensolverResult``: This object contains the results of running the minimum eigen optimizer such as the VQE on the relaxed problem. It provides information about the eigenvalue, and other relevant details. You can refer to the Qiskit Algorithms `documentation <https://qiskit.org/documentation/stubs/qiskit.algorithms.MinimumEigensolverResult.html>`__ for a comprehensive explanation of the entries within this object."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:857
msgid "``RoundingContext``: This object encapsulates essential information about the encoding and the solution of the relaxed problem in a form that is ready for consumption by the rounding schemes."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:983
msgid "Manually perform rounding on the relaxed problem results"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:985
msgid "Next, we proceed with rounding the results obtained from solving the relaxed problem. To achieve this, we call the ``round()`` method on an instance of the desired rounding scheme and pass it the ``RoundingContext`` object. Below, we provide an example for both rounding schemes, utilizing the relaxed solution obtained in the previous step."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:987
msgid "By manually performing the rounding step, we have more flexibility and control over the rounding scheme applied to the relaxed problem results. This allows for greater exploration and comparison of different rounding strategies."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1108
msgid "Appendix"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1111
msgid "How to verify correctness of your encoding"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1113
msgid "We assume for sake of the QRAO method that **the relaxation commutes with the objective function.** This notebook demonstrates how one can verify this for any problem (a ``QuadraticProgram`` in the language of Qiskit Optimization). One might want to verify this for pedagogical purposes, or as a sanity check when investigating unexpected behavior with the QRAO. Any problem that does not commute should be considered a bug, and if such a problem is discovered, we encourage that you submit it as `an issue on GitHub <https://github.com/qiskit-community/qiskit-optimization/issues>`__."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1116
msgid "The ``EncodingCommutationVerifier`` class allows one to conveniently iterate over all decision variable states and compare each objective value with the corresponding encoded objective value, in order to identify any discrepancy."
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1215
msgid "As before, we ``encode()`` the problem using the QuantumRandomAccessEncoding class:"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1284
msgid "Finally, we iterate over every decision variable state using ``EncodingCommutationVerifier`` and verify that, in each case, the problem objective value matches the encoded objective value:"
msgstr ""

#: ../../tutorials/12_quantum_random_access_optimizer.ipynb:1316
msgid "If you are able to construct a problem that causes a violation, it is quite possible that you have discovered a bug in the ``QuantumRandomAccessEncoding`` logic. We would greatly appreciate it if you could share the problem with us by `submitting it as an issue <https://github.com/Qiskit/qiskit-optimization/issues>`__ on GitHub."
msgstr ""


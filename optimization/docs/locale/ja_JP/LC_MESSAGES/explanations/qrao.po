msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-14 08:10+0000\n"
"PO-Revision-Date: 2024-01-05 06:27\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /main/optimization/docs/locale/en/LC_MESSAGES/explanations/qrao.po\n"
"X-Crowdin-File-ID: 10036\n"

#: ../../explanations/qrao.rst:2
msgid "Background on Quantum Random Access Optimization: *Quantum relaxations, quantum random access codes, rounding schemes*"
msgstr "量子ランダムアクセス最適化 (QRAO) の背景： *量子緩和、量子ランダムアクセス符号、丸めスキーム*"

#: ../../explanations/qrao.rst:4
msgid "This material provides a deeper look into the concepts behind Quantum Random Access Optimization."
msgstr "この資料では、量子ランダムアクセス最適化の背後にある概念について、より深く考察します。"

#: ../../explanations/qrao.rst:8
msgid "Relaxations"
msgstr "緩和（リラクゼーション）"

#: ../../explanations/qrao.rst:10
msgid "Consider a binary optimization problem defined on binary variables :math:`m_i \\in \\{-1,1\\}`. The choice of using :math:`\\pm 1` variables instead of :math:`0/1` variables is not important, but will be convenient in terms of notation when we begin to re-cast this problem in terms of quantum observables. We will be primarily interested in `quadratic unconstrained binary optimization (QUBO) <https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization>`__ problems, although the ideas in this document can readily extend to problems with more than quadratic terms, and problems with non-binary or constrained variables can often be recast as a QUBO (though this conversion will incur some overhead)."
msgstr "バイナリ変数 :math:`m_i \\in \\{-1,1\\}` に対して定義されたバイナリ最適化問題を考えてみましょう。:math:`0/1` 変数の代わりに :math:`\\pm 1` 変数を使用するという選択は重要ではありませんが、この問題を量子観測量の観点から再キャストし始めるときに、表記の点で便利です。 私たちは主に `2 次の制約なし 2 値最適化 (QUBO) 問題 <https://en.wikipedia.org/wiki/Quadratic_unconstrained_binary_optimization>`__ に興味を持ちますが、このドキュメントのアイデアは 2 次以上の項を含む問題にも簡単に拡張でき、非 2 値変数または制約付き変数の問題は多くの場合 QUBO として再キャストできます。 (この変換にはある程度のオーバーヘッドが発生します)。"

#: ../../explanations/qrao.rst:22
msgid "Within mathematical optimization, `relaxation <https://en.wikipedia.org/wiki/Relaxation_%28approximation%29>`__ is the strategy of taking some hard problem and mapping it onto a similar version of that problem which is (usually) easier to solve. The core idea here is that for useful relaxations, the solution to the relaxed problem can give information about the original problem and allow one to heuristically find better solutions. An example of relaxation could be something as simple as taking a discrete optimization problem and allowing a solver to optimize the problem using continuous variables. Once a solution is obtained for the relaxed problem, the solver must find a strategy for extracting a discrete solution from the relaxed solution of continuous values. This process of mapping the relaxed solution back onto original problem’s set of admissible solutions is often referred to as **rounding**."
msgstr "数理最適化において、 `緩和(リラクゼーション) <https://en.wikipedia.org/wiki/Relaxation_%28approximation%29>`__ とは、ある難問を取り上げ、その問題の類似バージョンにマッピングする戦略であり、(通常は) より簡単に解くことができます。ここでの核となる考え方は、有用な緩和の場合、緩和された問題の解が元の問題についての情報を与え、より良い解を発見することを可能にするということです。緩和の例としては、離散最適化問題を連続変数で最適化するという単純なものがあります。緩和された問題の解が得られると、ソルバーは連続値の緩和された解から離散解を抽出する戦略を見つけなければなりません。緩和解を元の問題の許容解集合にマッピングするこのプロセスは、しばしば **丸め(rounding)** と呼ばれます。"

#: ../../explanations/qrao.rst:37
#, python-format
msgid "For a concrete example of relaxation and rounding, see the `Goemans-Williamson Algorithm for MaxCut <https://en.wikipedia.org/wiki/Semidefinite_programming#Example_3_(Goemans%E2%80%93Williamson_max_cut_approximation_algorithm)>`__."
msgstr "緩和と丸めの具体的な例としては、 `MaxCutのGoemans-Williamsonアルゴリズム <https://en.wikipedia.org/wiki/Semidefinite_programming#Example_3_(Goemans%E2%80%93Williamson_max_cut_approximation_algorithm)>`__ を参照してください。"

#: ../../explanations/qrao.rst:41
msgid "Without loss of generality, the rest of this document will consider a `MaxCut <https://en.wikipedia.org/wiki/Maximum_cut>`__ objective function defined on a graph :math:`G = (V,E)`. Our goal is to find a partitioning of our vertices :math:`V` into two sets (:math:`+1` and :math:`-1`), such that we maximize the number of edges which connect both sets. More concretely, each :math:`v_i \\in V` will be assigned a binary variable :math:`m_i \\in \\{-1, 1\\}`, and we will define the *cut* of a variable assignment as:"
msgstr "一般性を失うことなく、このドキュメントの残りの部分では、グラフ :math:`G = (V,E)` 上で定義された `MaxCut <https://en.wikipedia.org/wiki/Maximum_cut>`__ 目的関数を考えます。我々の目的は、頂点 :math:`V` を2つの集合 (:math:`+1` and :math:`-1`) に分割し、両方の集合を結ぶ辺の数を最大にするような分割を見つけることです。より具体的には、 :math:`v_i \\in V` に2値変数 :math:`m_i \\in \\{-1, 1\\}` を代入し、変数代入の *cut* を次のように定義します："

#: ../../explanations/qrao.rst:50
msgid "\\text{cut}(m) = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-m_i m_j)\n\n"
msgstr "\\text{cut}(m) = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-m_i m_j)\n\n"

#: ../../explanations/qrao.rst:53
msgid "Quantum Relaxation"
msgstr "量子緩和"

#: ../../explanations/qrao.rst:55
msgid "Our goal is to define a relaxation of our MaxCut objective function. We will do this by mapping our objective function’s binary variables into the space of single qubit Pauli observables and by embedding the set of feasible inputs to cut(:math:`m`) onto the space of single-qubit quantum product states. Let us denote this embedding :math:`F` as:"
msgstr "我々の目的は、MaxCut目的関数の緩和を定義することです。これは、目的関数の2値変数を単一量子ビット パウリ観測量の空間にマッピングし、 cut(:math:`m`) への実行可能な入力の集合を単一量子ビット量子積状態の空間に埋め込むことによって行います。この埋め込みを :math:`F` とします："

#: ../../explanations/qrao.rst:61
msgid "F: \\{-1,1\\}^{M} \\mapsto \\mathcal{D}(\\mathbb{C}^{2^n}),\n\n"
msgstr "F: \\{-1,1\\}^{M} \\mapsto \\mathcal{D}(\\mathbb{C}^{2^n}),\n\n"

#: ../../explanations/qrao.rst:63
msgid "\\text{cut}(m) \\mapsto \\text{Tr}\\big(H\\cdot F(m)\\big),\n\n"
msgstr "\\text{cut}(m) \\mapsto \\text{Tr}\\big(H\\cdot F(m)\\big),\n\n"

#: ../../explanations/qrao.rst:65
msgid "where :math:`M = |V|`, and :math:`H` is a quantum Hamiltonian which encodes our objective function."
msgstr "ここで、 :math:`M = |V|` であり、 :math:`H` は目的関数を符号化した量子ハミルトニアンです。"

#: ../../explanations/qrao.rst:68
msgid "For this to be `a valid relaxation <https://en.wikipedia.org/wiki/Relaxation_%28approximation%29#Properties>`__ of our problem, it must be the case that:"
msgstr "これが我々の問題の `有効な緩和 <https://en.wikipedia.org/wiki/Relaxation_%28approximation%29#Properties>`__ であるためには、次のようでなければなりません："

#: ../../explanations/qrao.rst:72
msgid "\\text{cut}(m) \\geq \\text{Tr}\\big(H\\cdot F(m)\\big)\\qquad \\forall m \\in \\{-1,1\\}^M.\n\n"
msgstr "\\text{cut}(m) \\geq \\text{Tr}\\big(H\\cdot F(m)\\big)\\qquad \\forall m \\in \\{-1,1\\}^M.\n\n"

#: ../../explanations/qrao.rst:74
msgid "In order to guarantee this is true, we will enforce the stronger condition that our relaxation **commutes** with our objective function. In other words, cut(:math:`m`) is equal to the relaxed objective function for all :math:`m \\in \\{-1,1\\}^M`, rather than simply upper bounding it. This detail will become crucially important further down when we explicitly define our quantum relaxation."
msgstr "これが真であることを保証するために、我々は緩和が目的関数と **交換する** というより強い条件を強制します。言い換えると、 cut(:math:`m`) は単に上限を定めるのではなく、 :math:`m \\in \\{-1,1\\}^M` に対する緩和された目的関数と等しくなります。 この詳細は、量子緩和を明示的に定義するときにさらに重要になります。"

#: ../../explanations/qrao.rst:82
msgid "A Simple Quantum Relaxation"
msgstr "簡単な量子緩和"

#: ../../explanations/qrao.rst:84
msgid "Before explicating the full quantum relaxation scheme based on single-qubit Quantum Random Access Codes (QRACs), it may be helpful to first discuss `a version of quantum optimization <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__ which users may be more familiar with, but discussed in the language of quantum relaxation and rounding."
msgstr "単一量子ビット量子ランダムアクセス符号（QRAC）に基づく完全な量子緩和スキームを説明する前に、まず、量子緩和と丸め込みの言語で議論された、ユーザーにとって馴染み深い `量子最適化 <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__ について説明することが役に立つかもしれません。"

#: ../../explanations/qrao.rst:91
msgid "Consider the embedding"
msgstr "埋め込みを考慮して、"

#: ../../explanations/qrao.rst:93
msgid "F^{(1)}: m \\in \\{-1,1\\}^M \\mapsto \\{|0\\rangle,|1\\rangle\\}^{\\otimes M},\n\n"
msgstr "F^{(1)}: m \\in \\{-1,1\\}^M \\mapsto \\{|0\\rangle,|1\\rangle\\}^{\\otimes M},\n\n"

#: ../../explanations/qrao.rst:95
msgid "\\text{cut}(m) \\mapsto \\text{Tr}\\big(H^{(1)}F^{(1)}(m)\\big),\\quad  H^{(1)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-Z_i Z_j),\n\n"
msgstr "\\text{cut}(m) \\mapsto \\text{Tr}\\big(H^{(1)}F^{(1)}(m)\\big),\\quad  H^{(1)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-Z_i Z_j),\n\n"

#: ../../explanations/qrao.rst:97
msgid "where :math:`Z_i` indicates the single qubit Pauli-Z observable defined on the :math:`i`\\ ’th qubit and identity terms on all other qubits. It is worth convincing yourself that this transformation is a valid relaxation of our problem. In particular:"
msgstr "ここで、 :math:`Z_i` は :math:`i`\\ ’ 番目の量子ビットで定義される単一量子ビットのPauli-Z観測量と、他のすべての量子ビットの恒等項を表します。この変換が我々の問題の有効な緩和であることを納得するのは十分です。特に："

#: ../../explanations/qrao.rst:102
msgid "\\text{cut}(m) = \\text{Tr}\\big(H^{(1)}F^{(1)}(m)\\big) \\quad \\forall m \\in \\{-1,1\\}^M\n\n"
msgstr "\\text{cut}(m) = \\text{Tr}\\big(H^{(1)}F^{(1)}(m)\\big) \\quad \\forall m \\in \\{-1,1\\}^M\n\n"

#: ../../explanations/qrao.rst:104
msgid "This sort of embedding is currently used by many near-term quantum optimization algorithms, including many `QAOA and VQE based approaches <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/03_minimum_eigen_optimizer.ipynb>`__. Observe how although the relaxed version of our problem can exactly reproduce the objective function cut(:math:`m`) for inputs of the form :math:`\\{|0\\rangle,|1\\rangle\\}^{\\otimes M}`, we are also free to evaluate :math:`H^{(1)}` using a continuous superposition of such states. This stands in analogy to how one might classically relax an optimization problem such that they optimize the objective function using continuous values."
msgstr "この種の埋め込みは、現在、多くの `QAOAやVQEベースのアプローチ <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/03_minimum_eigen_optimizer.ipynb>`__ を含む、多くの近未来量子最適化アルゴリズムで使用されています。私たちの問題の緩和版では :math:`\\{|0\\rangle,|1\\rangle\\}^{\\otimes M}` の形式の入力に対する目的関数 cut(:math:`m`) を正確に再現できますが、そのような状態の連続的な重ね合わせを使って :math:`H^{(1)}` を自由に評価することもできます。これは、連続値を用いて目的関数を最適化するような最適化問題を古典的に緩和する方法と類似しています。"

#: ../../explanations/qrao.rst:115
msgid "Crucially, a relaxation is only useful if there is some practical way to **round** relaxed solutions back onto the original problem’s set of admissible solutions. For this particular quantum relaxation, the rounding scheme is simply given by measuring each qubit of our relaxed solution in the :math:`Z`-basis. Measurement will project any quantum state onto the set of computational basis states, and consequently, onto the image of :math:`F^{(1)}`."
msgstr "重要なことは、 **丸められた** 緩和解を元の問題の許容解の集合に戻す実用的な方法がある場合にのみ、緩和は有用であるということです。この特殊な量子緩和では、緩和された解の各量子ビットを :math:`Z`- 基底で測定することで、丸めを行います。測定は、任意の量子状態を計算基底状態の集合に投影し、その結果、 :math:`F^{(1)}` のイメージに投影します。"

#: ../../explanations/qrao.rst:124
msgid "Quantum Relaxations via Quantum Random Access Codes (QRACs)"
msgstr "量子ランダムアクセスコード（QRAC）による量子緩和"

#: ../../explanations/qrao.rst:126
msgid "Quantum Random Access Codes were `first outlined in 1983 by Stephen Wiesner [2] <http://users.cms.caltech.edu/~vidick/teaching/120_qcrypto/wiesner.pdf>`__ and were used in the context of communication complexity theory. We will not be using QRACs in the way they were originally conceived, instead we are co-opting them to define our quantum relaxations. For this reason will not provide a full introduction to RACs or QRACs, but encourage interested readers to seek out more information about them."
msgstr "量子ランダムアクセスコードは、 `1983年に Stephen Wiesner によって初めて概説され[2] <http://users.cms.caltech.edu/~vidick/teaching/120_qcrypto/wiesner.pdf>`__ 、通信複雑性理論の文脈で使用されました。我々は、QRACを当初考えられていたように使うのではなく、量子緩和を定義するためにQRACを利用します。このため、RACやQRACの完全な紹介はしませんが、興味のある読者には、より詳しい情報を探すことを推奨します。"

#: ../../explanations/qrao.rst:136
msgid ":math:`(1,1,1)`, :math:`(2,1,p)`, and :math:`(3,1,p)` Quantum Random Access Codes"
msgstr ":math:`(1,1,1)` , :math:`(2,1,p)` , :math:`(3,1,p)' の量子ランダムアクセスコード"

#: ../../explanations/qrao.rst:138
msgid "A :math:`(k,1,p)`-QRAC, is a scheme for embedding :math:`k` classical bits into a 1-qubit state, such that given a single copy of this state, you can recover any one of the :math:`k`-bits with probability :math:`p` by performing some measurement. The simple quantum relaxation discussed in the previous section is an example of a trivial :math:`(1,1,1)`-QRAC. For convenience, we will write the :math:`(2,1,0.854)` and :math:`(3,1,0.789)` QRACs as :math:`(2,1,p)` and :math:`(3,1,p)`, respectively. It is worth noting :math:`(4, 1, p)`-QRAC :math:`(p > 1/2)` has been `proven to be impossible. [3] <https://iopscience.iop.org/article/10.1088/1367-2630/8/8/129>`__"
msgstr ":math:`(k,1,p)`-QRAC とは、1量子ビットの状態に :math:`k` 個の古典ビットを埋め込むスキームで、この状態のコピーが1つあれば、何らかの測定を行うことで :math:`k` 個のビットのどれかを確率 :math:`p` で復元することができます。前節で説明した単純な量子緩和は、自明な :math:`(1,1,1)`-QRAC の一例です。便宜上、 :math:`(2,1,0.854)` と :math:`(3,1,0.789)` のQRACをそれぞれ :math:`(2,1,p)` と :math:`(3,1,p)` と書きます。 :math:`(4, 1, p)`-QRAC :math:`(p > 1/2)` は`不可能であることが証明されています。[3]<https://iopscience.iop.org/article/10.1088/1367-2630/8/8/129>`__"

#: ../../explanations/qrao.rst:149
msgid "As we generalize the simple example above, it will be helpful to write out single qubit states decomposed in the Hermitian basis of Pauli observables."
msgstr "上の単純な例を一般化すると、単一量子ビットの状態をパウリ観測量のエルミート基底で分解して書き出すのが役に立つでしょう。"

#: ../../explanations/qrao.rst:153
msgid "\\rho = \\frac{1}{2}\\left(I + aX + bY + cZ \\right),\\quad |a|^2 + |b|^2 + |c|^2 = 1\n\n"
msgstr "\\rho = \\frac{1}{2}\\left(I + aX + bY + cZ \\right),\\quad |a|^2 + |b|^2 + |c|^2 = 1\n\n"

#: ../../explanations/qrao.rst:155
msgid "The embeddings :math:`F^{(1)}`, :math:`F^{(2)}`, and :math:`F^{(3)}` associated respectively with the :math:`(1,1,1), (2,1,p),` and :math:`(3,1,p)` QRACs can now be written as follows:"
msgstr ":math:`(1,1,1), (2,1,p),` :math:`(3,1,p)` のQRACにそれぞれ関連する埋め込み :math:`F^{(1)}` 、 :math:`F^{(2)}` 、 :math:`F^{(3)}` は次のように書くことができます："

#: ../../explanations/qrao.rst:159
msgid "\\begin{array}{l|ll}\n"
"\\text{QRAC} & &\\text{Embedding into } \\rho = \\vert \\psi(m)\\rangle\\langle\\psi(m)\\vert \\\\\n"
"\\hline\n"
"(1,1,1)&F^{(1)}(m): \\{-1,1\\} &\\mapsto\\ \\vert\\psi^{(1)}_m\\rangle \\langle\\psi^{(1)}_m\\vert = \\frac{1}{2}\\Big(I + {m_0}Z \\Big) \\\\\n"
"(2,1,p)&F^{(2)}(m): \\{-1,1\\}^2 &\\mapsto\\ \\vert\\psi^{(2)}_m\\rangle \\langle\\psi^{(2)}_m\\vert = \\frac{1}{2}\\left(I + \\frac{1}{\\sqrt{2}}\\big({m_0}X+ {m_1}Z \\big)\\right)  \\\\\n"
"(3,1,p)&F^{(3)}(m): \\{-1,1\\}^3 &\\mapsto\\ \\vert\\psi^{(3)}_m\\rangle \\langle\\psi^{(3)}_m\\vert = \\frac{1}{2}\\left(I + \\frac{1}{\\sqrt{3}}\\big({m_0}X+ {m_1}Y + {m_2}Z\\big)\\right) \\\\\n"
"\\end{array}"
msgstr "\\begin{array}{l|ll}\n"
"\\text{QRAC} & &\\text{Embedding into } \\rho = \\vert \\psi(m)\\rangle\\langle\\psi(m)\\vert \\\\\n"
"\\hline\n"
"(1,1,1)&F^{(1)}(m): \\{-1,1\\} &\\mapsto\\ \\vert\\psi^{(1)}_m\\rangle \\langle\\psi^{(1)}_m\\vert = \\frac{1}{2}\\Big(I + {m_0}Z \\Big) \\\\\n"
"(2,1,p)&F^{(2)}(m): \\{-1,1\\}^2 &\\mapsto\\ \\vert\\psi^{(2)}_m\\rangle \\langle\\psi^{(2)}_m\\vert = \\frac{1}{2}\\left(I + \\frac{1}{\\sqrt{2}}\\big({m_0}X+ {m_1}Z \\big)\\right)  \\\\\n"
"(3,1,p)&F^{(3)}(m): \\{-1,1\\}^3 &\\mapsto\\ \\vert\\psi^{(3)}_m\\rangle \\langle\\psi^{(3)}_m\\vert = \\frac{1}{2}\\left(I + \\frac{1}{\\sqrt{3}}\\big({m_0}X+ {m_1}Y + {m_2}Z\\big)\\right) \\\\\n"
"\\end{array}"

#: ../../explanations/qrao.rst:169
msgid "\\text{Table 1: QRAC states}\n\n"
msgstr "\\text{Table 1: QRAC states}"

#: ../../explanations/qrao.rst:171
msgid "Note that for when using a :math:`(k,1,p)`-QRAC with bit strings :math:`m \\in \\{-1,1\\}^M, M > k`, these embeddings scale naturally via composition by tensor product."
msgstr "ビット列 :math:`m \\in \\{-1,1\\}^M, M > k` を持つ :math:`(k,1,p)`-QRAC を使う場合、これらの埋め込みはテンソル積による合成で自然にスケールすることに注意してください。"

#: ../../explanations/qrao.rst:175
msgid "m \\in \\{-1,1\\}^6,\\quad F^{(3)}(m) = F^{(3)}(m_0,m_1,m_2)\\otimes F^{(3)}(m_3,m_4,m_5)\n\n"
msgstr "m \\in \\{-1,1\\}^6,\\quad F^{(3)}(m) = F^{(3)}(m_0,m_1,m_2)\\otimes F^{(3)}(m_3,m_4,m_5)\n\n"

#: ../../explanations/qrao.rst:177
msgid "Similarly, when :math:`k \\nmid M`, we can simply pad our input bitstring with the appropriate number of :math:`+1` values."
msgstr "同様に、 :math:`k \\nmid M` のとき、入力ビット列を適切な数の :math:`+1` 値でパディングすればよいです。"

#: ../../explanations/qrao.rst:180
msgid "m \\in \\{-1,1\\}^4,\\quad F^{(3)}(m) = F^{(3)}(m_0,m_1,m_2)\\otimes F^{(3)}(m_3,+1,+1)\n\n"
msgstr "m \\in \\{-1,1\\}^4,\\quad F^{(3)}(m) = F^{(3)}(m_0,m_1,m_2)\\otimes F^{(3)}(m_3,+1,+1)\n\n"

#: ../../explanations/qrao.rst:183
msgid "Recovering Encoded Bits"
msgstr "符号化されたビットの復元"

#: ../../explanations/qrao.rst:185
msgid "Given a QRAC state, we can recover the values of the encoded bits by estimating the expectation value of each bit’s corresponding observable. Note that there is a re-scaling factor which depends on the density of the QRAC."
msgstr "QRACの状態が与えられた場合、各ビットの対応する観測値の期待値を推定することで、符号化されたビットの値を復元することができます。QRACの密度に依存する再スケーリング係数があることに注意してください。"

#: ../../explanations/qrao.rst:190
msgid "\\begin{array}{l|l|l|l}\n"
"\\text{Embedding} & m_0 & m_1 & m_2\\\\\n"
"\\hline\n"
"\\rho = F^{(1)}(m_0) &\\text{Tr}\\big(\\rho Z\\big) &  & \\\\\n"
"\\rho = F^{(2)}(m_0,m_1) &\\sqrt{2}\\cdot\\text{Tr}\\big(\\rho X\\big) &\\sqrt{2}\\cdot\\text{Tr}\\big(\\rho Z\\big) & \\\\\n"
"\\rho = F^{(3)}(m_0,m_1,m_2) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho X\\big) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho Y\\big) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho Z\\big)\n"
"\\end{array}"
msgstr "\\begin{array}{l|l|l|l}\n"
"\\text{Embedding} & m_0 & m_1 & m_2\\\\\n"
"\\hline\n"
"\\rho = F^{(1)}(m_0) &\\text{Tr}\\big(\\rho Z\\big) &  & \\\\\n"
"\\rho = F^{(2)}(m_0,m_1) &\\sqrt{2}\\cdot\\text{Tr}\\big(\\rho X\\big) &\\sqrt{2}\\cdot\\text{Tr}\\big(\\rho Z\\big) & \\\\\n"
"\\rho = F^{(3)}(m_0,m_1,m_2) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho X\\big) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho Y\\big) & \\sqrt{3}\\cdot\\text{Tr}\\big(\\rho Z\\big)\n"
"\\end{array}"

#: ../../explanations/qrao.rst:200
msgid "\\text{Table 2: Bit recovery from QRAC states}\n\n"
msgstr "\\text{Table 2: Bit recovery from QRAC states}\n\n"

#: ../../explanations/qrao.rst:203
msgid "Encoded Problem Hamiltonians"
msgstr "符号化された問題のハミルトニアン"

#: ../../explanations/qrao.rst:205
msgid "Using the tools we have outlined above, we can explicitly write out the Hamiltonians which encode the relaxed versions of our MaxCut problem. We do this by substituting each decision variable with the unique observable that has been assigned to that variable under the embedding :math:`F`."
msgstr "上記で概説したツールを用いて、MaxCut問題の緩和されたバージョンを符号化するハミルトニアンを明示的に書き出すことができます。これは、各決定変数を、埋め込み :math:`F` のもとでその変数に割り当てられているユニークな観測量に置き換えることで行います。"

#: ../../explanations/qrao.rst:211
msgid "\\begin{array}{l|ll}\n"
"\\text{QRAC}  & \\text{Problem Hamiltonian}\\\\\n"
"\\hline\n"
"(1,1,1)&H^{(1)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-Z_i Z_j)\\\\\n"
"(2,1,p)&H^{(2)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-2\\cdot P_{[i]} P_{[j]}),\\quad P_{[i]} \\in \\{X,Z\\}\\\\\n"
"(3,1,p)&H^{(3)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-3\\cdot P_{[i]} P_{[j]}),\\quad P_{[i]} \\in \\{X,Y,Z\\}\\\\\n"
"\\end{array}"
msgstr "\\begin{array}{l|ll}\n"
"\\text{QRAC}  & \\text{Problem Hamiltonian}\\\\\n"
"\\hline\n"
"(1,1,1)&H^{(1)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-Z_i Z_j)\\\\\n"
"(2,1,p)&H^{(2)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-2\\cdot P_{[i]} P_{[j]}),\\quad P_{[i]} \\in \\{X,Z\\}\\\\\n"
"(3,1,p)&H^{(3)} = \\sum_{ij; e_{ij} \\in E} \\frac{1}{2}(1-3\\cdot P_{[i]} P_{[j]}),\\quad P_{[i]} \\in \\{X,Y,Z\\}\\\\\n"
"\\end{array}"

#: ../../explanations/qrao.rst:221
msgid "\\text{Table 3: Relaxed MaxCut Hamiltonians after QRAC embedding}\n\n"
msgstr "\\text{Table 3: Relaxed MaxCut Hamiltonians after QRAC embedding}\n\n"

#: ../../explanations/qrao.rst:223
msgid "Note that here, :math:`P_{[i]}` indicates a single-qubit Pauli observable corresponding to decision variable :math:`i`. The bracketed index here is to make clear that :math:`P_{[i]}` will not necessarily be acting on qubit :math:`i`, because the :math:`(2,1,p)` and :math:`(3,1,p)` no longer have a 1:1 relationship between qubits and decision variables."
msgstr "ここで、 :math:`P_{[i]}` は、決定変数 :math:`i` に対応する1量子ビットのパウリ観測量を示していることに注意してください。ここでの括弧付きインデックスは、 :math:`(2,1,p)` と :math:`(3,1,p)` は、もはや量子ビットと決定変数の間に1:1の関係を持たないため、 :math:`P_{[i]}` は必ずしも量子ビット :math:`i` に作用しないことを明確にするためです。"

#: ../../explanations/qrao.rst:231
msgid "Commutation of Quantum Relaxation"
msgstr "量子緩和の交換"

#: ../../explanations/qrao.rst:233
msgid "Note that for the :math:`(2,1,p)` and :math:`(3,1,p)` QRACs, we are associating multiple decision variables to each qubit. This means that each decision variable is assigned a *unique* single-qubit Pauli observable and some subsets of these Pauli observables will be defined on the same qubits. This can potentially pose a problem when trying to ensure the commutativity condition discussed earlier"
msgstr ":math:`(2,1,p)` と :math:`(3,1,p)` のQRACでは、各量子ビットに複数の決定変数を割り当てていることに注意してください。これは、各決定変数に *ユニーク* な1量子ビットのパウリ観測変数が割り当てられ、これらのパウリ観測変数のいくつかのサブセットが同じ量子ビット上で定義されることを意味します。このことは、先に説明した可換性を保証する際に問題となる可能性があります。"

#: ../../explanations/qrao.rst:240
msgid "Observe that under the :math:`(3,1,p)`-QRAC, any term in our objective function of the form :math:`(1 - x_i x_j)` will map to a Hamiltonian term of the form :math:`(1-3\\cdot P_{[i]} P_{[j]})`. If both :math:`P_{[i]}` and :math:`P_{[j]}` are acting on different qubits, then :math:`P_{[i]}\\cdot P_{[j]} = P_{[i]}\\otimes P_{[j]}` and this term of our Hamiltonian will behave as we expect."
msgstr ":math:`(3,1,p)` -QRACの下では、 :math:`(1 - x_i x_j)` の形の目的関数の任意の項は、:math:`(1-3\\cdot P_{[i]} P_{[j]})` の形のハミルトニアン項にマップされることに注意してください。 :math:`P_{[i]}` と :math:`P_{[j]}` の両方が異なる量子ビットに作用する場合、 :math:`P_{[i]}\\cdot P_{[j]} = P_{[i]}\\otimes P_{[j]}` となり、ハミルトニアンのこの項は期待通りの振る舞いをします。"

#: ../../explanations/qrao.rst:247
msgid "If however, :math:`P_{[i]}` and :math:`P_{[j]}` are acting on the same qubit, the two Paulis will compose directly. Recall that the Pauli matrices form a group and are self-inverse, thus we can deduce that the product of two distinct Paulis will yield another element of the group and it will not be the identity."
msgstr "しかし、:math:`P_{[i]}` と :math:`P_{[j]}` が同じ量子ビットに作用する場合、2つのパウリは直接合成されます。パウリ行列は群を形成し、自己逆行列であることを思い出してください。したがって、2つの異なるパウリの積は群の別の要素をもたらし、それは恒等式にはならないことが推測できます。"

#: ../../explanations/qrao.rst:253
msgid "Practically, this means that our commutation relationship will break and :math:`\\text{cut}(m) \\not= \\text{Tr}\\big(H^{(1)}F^{(3)}(m)\\big)`"
msgstr "実用的には、これは交換関係が崩れて、 :math:`\\text{cut}(m) \\not= \\text{Tr}\\big(H^{(1)}F^{(3)}(m)\\big)` になることを意味します。"

#: ../../explanations/qrao.rst:256
msgid "In order to restore the commutation of our encoding with our objective function, we must introduce an additional constraint on the form of our problem Hamiltonian. Specifically, we must guarantee that decision variables which share an edge in our input graph :math:`G` are not assigned to the same qubit under our embedding :math:`F`"
msgstr "符号化と目的関数の交換性を復元するためには、問題のハミルトニアンの形に追加の制約を導入する必要があります。具体的には、入力グラフ :math:`G` のエッジを共有する決定変数は、埋め込み :math:`F` のもとでは同じ量子ビットに割り当てられないことを保証しなければなりません。"

#: ../../explanations/qrao.rst:262
msgid "\\forall e_{ij} \\in E,\\quad F^{(3)}(\\dots,m_i,\\dots,m_j,\\dots) = F^{(3)}(\\dots,m_i,\\dots)\\otimes F^{(3)}(\\dots,m_j,\\dots)\n\n"
msgstr "\\forall e_{ij} \\in E,\\quad F^{(3)}(\\dots,m_i,\\dots,m_j,\\dots) = F^{(3)}(\\dots,m_i,\\dots)\\otimes F^{(3)}(\\dots,m_j,\\dots)\n\n"

#: ../../explanations/qrao.rst:264
msgid "In [1] this is accomplished by finding a coloring of the graph G such that no vertices with the same color share an edge, and then assigning variables to the same qubit only if they have the same color."
msgstr "[1] では、同じ色を持つ頂点がエッジを共有しないようなグラフGのカラーリングを見つけ、同じ色を持つ場合にのみ同じ量子ビットに変数を割り当てることで実現しています。"

#: ../../explanations/qrao.rst:269
msgid "Quantum Rounding Schemes"
msgstr "量子丸めスキーム"

#: ../../explanations/qrao.rst:271
msgid "Because the final solution we obtain for the relaxed problem :math:`\\rho_\\text{relax}` is unlikely to be in the image of :math:`F`, we need a strategy for mapping :math:`\\rho_\\text{relax}` to the image of :math:`F` so that we may extract a solution to our original problem."
msgstr "緩和問題 :math:`\\rho_\\text{relax}` に対して得られる最終的な解は :math:`F` マッピング の画像内にある可能性は低いため、抽出できるように :math:`\\rho_\\text{relax}` を :math:`F` の画像にマッピングする戦略が必要です。 私たちの元々の問題に対する解決策です。"

#: ../../explanations/qrao.rst:276
msgid "In [1] there are two strategies proposed for rounding :math:`\\rho_\\text{relax}` back to :math:`m \\in \\{-1,1\\}^M`."
msgstr "[1] では、 :math:`\\rho_\\text{relax}` を :math:`m \\in \\{-1,1\\}^M` に丸めるために 2 つの戦略が提案されています。"

#: ../../explanations/qrao.rst:280
msgid "Semi-deterministic Rounding"
msgstr "半決定論的丸め"

#: ../../explanations/qrao.rst:282
msgid "A natural choice for extracting a solution is to use the results of Table :math:`2` and simply estimate :math:`\\text{Tr}(P_{[i]}\\rho_\\text{relax})` for all :math:`i` in order to assign a value to each variable :math:`m_i`. The procedure described in Table :math:`2` was intended for use on states in the image of :math:`F`, however, we are now applying it to arbitrary input states. The practical consequence is we will no longer measure a value close to {:math:`\\pm 1`}, {:math:`\\pm \\sqrt{2}`}, or {:math:`\\pm \\sqrt{3}`}, as we would expect for the :math:`(1,1,1)`, :math:`(2,1,p)`, and :math:`(3,1,p)` QRACs, respectively."
msgstr "解を抽出するための自然な選択は、表 :math:`2` の結果を使用し、各変数 :math:`m_i` に値を割り当てるためにすべての :math:`i` について単純に :math:`\\text{Tr}(P_{[i]}\\rho_\\text{relax})` を推定することです。 表 :math:`2` で説明されている手順は、:math:`F` の画像内の状態で使用することを目的としていましたが、現在はそれを任意の入力状態に適用しています。 実際の結果として、:math:`(1,1,1)`, :math:`(2,1,p)` や :math:`(3,1,p)` QRACに対して期待されるような、{:math:`\\pm 1`}, {:math:`\\pm \\sqrt{2}`}, または {:math:`\\pm \\sqrt{3}`} に近い値は測定されなくなります。"

#: ../../explanations/qrao.rst:293
msgid "We handle this by returning the sign of the expectation value, leading to the following rounding scheme."
msgstr "期待値の符号を返すことでこれを処理し、以下のような丸めスキームを導き出します。"

#: ../../explanations/qrao.rst:296
msgid "m_i = \\left\\{\\begin{array}{rl}\n"
"      +1 & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) > 0 \\\\\n"
"      X \\sim\\{-1,1\\} & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) = 0 \\\\\n"
"      -1 & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) < 0\n"
"      \\end{array}\\right."
msgstr "m_i = \\left\\{\\begin{array}{rl}\n"
"      +1 & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) > 0 \\\\\n"
"      X \\sim\\{-1,1\\} & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) = 0 \\\\\n"
"      -1 & \\text{Tr}(P_{[i]}\\rho_\\text{relax}) < 0\n"
"      \\end{array}\\right."

#: ../../explanations/qrao.rst:304
msgid "Where :math:`X` is a random variable which returns either -1 or 1 with equal probability."
msgstr "ここで :math:`X` は-1か1を等確率で返す確率変数です。"

#: ../../explanations/qrao.rst:307
msgid "Notice that semi-deterministic rounding will faithfully recover :math:`m` from :math:`F(m)` with a failure probability that decreases exponentially with the number of shots used to estimate each :math:`\\text{Tr}(P_{[i]}\\rho_\\text{relax})`"
msgstr "半決定論的丸めは、各 :math:`\\text{Tr}(P_{[i]}\\rho_\\text{relax})` の推定に使用されるショットの数に応じて指数関数的に減少する失敗確率で :math:`F(m)` から :math:`m` を忠実に復元することに注意してください。"

#: ../../explanations/qrao.rst:313
msgid "Magic State Rounding"
msgstr "マジック状態丸め"

#: ../../explanations/qrao.rst:319
msgid "Three different encodings, the states and the measurement bases, of variables into a single qubit. (a) One variable per qubit. (b) Two variables per qubit. (c) Three variables per qubit. Taken from `[1] <https://arxiv.org/pdf/2111.03167.pdf>`__."
msgstr "3つの異なる符号化、状態および測定規定、1つの量子ビットへの変数のエンコーディング。(a) 1量子ビットあたり1変数。(b) 1量子ビットあたり2変数。(c) 1量子ビットあたり3変数。 `[1] <https://arxiv.org/pdf/2111.03167.pdf>`__ から引用。"

#: ../../explanations/qrao.rst:323
msgid "Rather than seeking to independently distinguish each :math:`m_i`, magic state rounding randomly selects a measurement basis which will perfectly distinguish a particular pair of orthogonal QRAC states :math:`\\{ F(m), F(\\bar m)\\}`, where :math:`\\bar m` indicates that every bit of :math:`m` has been flipped."
msgstr "マジック状態丸めでは、各 :math:`m_i` を独立して区別しようとするのではなく、直交 QRAC 状態の特定のペア :math:`\\{ F(m), F(\\bar m)\\}` を完全に区別する測定基底がランダムに選択されます。ここで、 :math:`\\bar m` は、:math:`m` のすべてのビットが反転されていることを示します。"

#: ../../explanations/qrao.rst:329
msgid "Let :math:`\\mathcal{M}` be the randomized rounding procedure which takes as input a state :math:`\\rho_\\text{relax}` and samples a bitstring :math:`m` by measuring in a randomly selected magic-basis."
msgstr ":math:`\\mathcal{M}` および を、状態 :math:`\\rho_\\text{relax}` を入力として受け取り、ランダムに選択されたマジック基底で測定することによってビット列 :math:`m` をサンプリングするランダム化された丸め手順とします。"

#: ../../explanations/qrao.rst:333
msgid "\\mathcal{M}^{\\otimes n}(\\rho_\\text{relax}) \\rightarrow F(m)\n\n"
msgstr "\\mathcal{M}^{\\otimes n}(\\rho_\\text{relax}) \\rightarrow F(m)\n\n"

#: ../../explanations/qrao.rst:335
msgid "First, notice that for the :math:`(1,1,1)`-QRAC, there is only one basis to choose and the magic state rounding scheme is essentially equivalent to the semi-deterministic rounding scheme."
msgstr "まず、 :math:`(1,1,1)`-QRAC の場合、選択する基底は1つだけであり、マジック状態丸め方式は本質的に半決定論的丸め方式と等価であることに注意してください。"

#: ../../explanations/qrao.rst:339
msgid "For the :math:`(2,1,p)` and :math:`(3,1,p)` QRACs, if we apply the magic state rounding scheme to an :math:`n`-qubit QRAC state :math:`F(m)`, we will have a :math:`2^{-n}` and :math:`4^{-n}` probability of picking the correct basis on each qubit to perfectly extract the solution :math:`m`. Put differently, if we are given an unknown state :math:`F(m)` the probability that :math:`\\mathcal{M}^{\\otimes n}(F(m))\\mapsto F(m)` decreases exponentially with the number of qubits measured - it is far more likely to be mapped to some other :math:`F(m^*)`. Similarly, when we perform magic rounding on an arbitrary state :math:`\\rho_\\text{relax}`, we have similarly low odds of randomly choosing the optimal magic basis for all :math:`n`-qubits. Fortunately magic state rounding does offer a lower bound on the approximation ratio under certain conditions."
msgstr ":math:`(2,1,p)` と :math:`(3,1,p)` のQRACでは、 :math:`n` 量子ビットのQRAC状態 :math:`F(m)` にマジック状態丸めスキームを適用すると、解 :math:`m` を完全に抽出するために各量子ビットの正しい基底を選ぶ確率は :math:`2^{-n}` と :math:`4^{-n}` pになります。言い換えると、未知の状態 :math:`F(m)` が与えられた場合、 :math:`\\mathcal{M}^{\\otimes n}(F(m))\\mapsto F(m)` の確率は、測定される量子ビットの数とともに指数関数的に減少します。 他の :math:`F(m^*)` にマッピングされる可能性がはるかに高くなります。同様に、任意の状態 :math:`\\rho_\\text{relax}` でマジック丸めを実行する場合、すべての :math:`n` 量子ビットに対して最適なマジック基底がランダムに選択される確率は同様に低くなります。 幸いなことに、マジック状態丸めは、特定の条件下で近似比の下限を提供します。"

#: ../../explanations/qrao.rst:353
msgid "Let :math:`F(m^*)` be the highest energy state in the image of F, and let :math:`\\rho^*` be the maximal eigenstate of H."
msgstr ":math:`F(m^*)` を F の画像内の最高エネルギー状態とし、 :math:`\\rho^*` を H の最大固有状態とします。"

#: ../../explanations/qrao.rst:356
msgid "\\forall \\rho_\\text{relax}\\quad \\text{s.t.}\\quad \\text{Tr}\\left(F(m^*)\\cdot H\\right) \\leq \\text{Tr}\\left(\\rho_\\text{relax}\\cdot H\\right)\\leq \\text{Tr}\\left(\\rho^*\\cdot H\\right)\n\n"
msgstr "\\forall \\rho_\\text{relax}\\quad \\text{s.t.}\\quad \\text{Tr}\\left(F(m^*)\\cdot H\\right) \\leq \\text{Tr}\\left(\\rho_\\text{relax}\\cdot H\\right)\\leq \\text{Tr}\\left(\\rho^*\\cdot H\\right)\n\n"

#: ../../explanations/qrao.rst:358
msgid "\\frac{\\text{expected fval}}{\\text{optimal fval}} = \\frac{\\mathbb{E}\\left[\\text{Tr}\\left(H\\cdot \\mathcal{M}^{\\otimes n}(\\rho_\\text{relax})\\right)\\right]}{\\text{Tr}\\left(H\\cdot F(m^*)\\right)} \\geq \\frac{5}{9}\n\n"
msgstr "\\frac{\\text{expected fval}}{\\text{optimal fval}} = \\frac{\\mathbb{E}\\left[\\text{Tr}\\left(H\\cdot \\mathcal{M}^{\\otimes n}(\\rho_\\text{relax})\\right)\\right]}{\\text{Tr}\\left(H\\cdot F(m^*)\\right)} \\geq \\frac{5}{9}\n\n"

#: ../../explanations/qrao.rst:361
msgid "References"
msgstr "参考文献"

#: ../../explanations/qrao.rst:363
msgid "[1] Bryce Fuller et al., “Approximate solutions of combinatorial problems via quantum relaxations,” (2021), `arXiv:2111.03167 <https://arxiv.org/pdf/2111.03167.pdf>`__,"
msgstr "[1] Bryce Fuller et al., “Approximate solutions of combinatorial problems via quantum relaxations,” (2021), `arXiv:2111.03167 <https://arxiv.org/pdf/2111.03167.pdf>`__,"

#: ../../explanations/qrao.rst:366
msgid "[2] Stephen Wiesner, “Conjugate coding,” SIGACT News, vol. 15, issue 1, pp. 78-88, 1983. `link <http://users.cms.caltech.edu/~vidick/teaching/120_qcrypto/wiesner.pdf>`__"
msgstr "[2] Stephen Wiesner, “Conjugate coding,” SIGACT News, vol. 15, issue 1, pp. 78-88, 1983. `link <http://users.cms.caltech.edu/~vidick/teaching/120_qcrypto/wiesner.pdf>`__"

#: ../../explanations/qrao.rst:370
msgid "[3] Masahito Hayashi et al., “(4,1)-Quantum random access coding does not exist—one qubit is not enough to recover one of four bits,” New Journal of Physics, vol. 8, number 8, pp. 129, 2006. `link <https://iopscience.iop.org/article/10.1088/1367-2630/8/8/129>`__"
msgstr "[3] Masahito Hayashi et al., “(4,1)-Quantum random access coding does not exist—one qubit is not enough to recover one of four bits,” New Journal of Physics, vol. 8, number 8, pp. 129, 2006. `link <https://iopscience.iop.org/article/10.1088/1367-2630/8/8/129>`__"


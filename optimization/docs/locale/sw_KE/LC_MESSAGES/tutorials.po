msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-12 22:17+0000\n"
"PO-Revision-Date: 2021-07-12 23:09\n"
"Last-Translator: \n"
"Language-Team: Swahili\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: sw\n"
"X-Crowdin-File: /master/optimization/docs/locale/en/LC_MESSAGES/tutorials.po\n"
"X-Crowdin-File-ID: 9594\n"
"Language: sw_KE\n"

#: ../../tutorials/01_quadratic_program.ipynb:13
#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:13
#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:13
#: ../../tutorials/04_grover_optimizer.ipynb:13
#: ../../tutorials/05_admm_optimizer.ipynb:13
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:13
#: ../../tutorials/07_examples_vehicle_routing.ipynb:13
#: ../../tutorials/08_cvar_optimization.ipynb:13
#: ../../tutorials/09_application_classes.ipynb:13
#: ../../tutorials/10_warm_start_qaoa.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:9
msgid "Quadratic Programs"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:21
#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:21
#: ../../tutorials/04_grover_optimizer.ipynb:21
#: ../../tutorials/05_admm_optimizer.ipynb:21
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:21
#: ../../tutorials/08_cvar_optimization.ipynb:21
#: ../../tutorials/09_application_classes.ipynb:21
#: ../../tutorials/10_warm_start_qaoa.ipynb:12
msgid "Introduction"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:32
msgid "In this tutorial, we briefly introduce how to build optimization problems using Qiskit’s optimization module. Qiskit introduces the ``QuadraticProgram`` class to make a model of an optimization problem. More precisely, it deals with quadratically constrained quadratic programs given as follows:"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:34
msgid "\\begin{align}\n"
"\\text{minimize}\\quad& x^\\top Q_0 x + c^\\top x\\\\\n"
"\\text{subject to}\\quad& A x \\leq b\\\\\n"
"& x^\\top Q_i x + a_i^\\top x \\leq r_i, \\quad 1,\\dots,i,\\dots,q\\\\\n"
"& l_i \\leq x_i \\leq u_i, \\quad 1,\\dots,i,\\dots,n,\n"
"\\end{align}"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:44
msgid "where the :math:`Q_i` are :math:`n \\times n` matrices, :math:`A` is a :math:`m \\times n` matrix , :math:`x`, and :math:`c` are :math:`n`-dimensional vectors, :math:`b` is an :math:`m`-dimensional vector, and where :math:`x` can defined as binary, integer, or continuous variables. In addition to “:math:`\\leq`” constraints ‘QuadraticProgram’ also supports “:math:`\\geq`” and “:math:`=`”."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:56
msgid "Loading a ``Quadratic Program`` from an LP file"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:67
msgid "As setup, you need to import the following module."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:89
msgid "You start with an empty model. How to add variables and constraints to a model is explained in the section “Directly constructing a ``QuadraticProgram``”."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:100
msgid "Qiskit’s optimization module supports the conversion from Docplex model. You can easily make a model of an optimization problem with Docplex. You can find the documentation of Docplex at https://ibmdecisionoptimization.github.io/docplex-doc/mp/index.html"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:102
msgid "You can load a Docplex model to ``QuadraticProgram`` by using ``from_docplex_mp`` function."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:114
msgid "Loading a ``QuadraticProgram`` from a docplex model"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:275
msgid "Directly constructing a ``QuadraticProgram``"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:286
msgid "We then explain how to make model of an optimization problem directly using ``QuadraticProgram``. Let’s start from an empty model."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:348
msgid "The ``QuadraticProgram`` supports three types of variables: - Binary variable - Integer variable - Continuous variable"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:350
msgid "When you add variables, you can specify names, types, lower bounds and upper bounds."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:352
msgid "When you display your problem as LP format, ``Binaries`` denotes binary variables and ``Generals`` denotes integer variables. If variables are not included in either ``Binaries`` or ``Generals``, such variables are continuous ones with default lower bound = 0 and upper bound = infinity. Note that you cannot use ‘e’ or ‘E’ as the first character of names due to the `specification of LP format <https://www.ibm.com/support/knowledgecenter/SSSA5P_12.7.1/ilog.odms.cplex.help/CPLEX/FileFormats/topics/LP_VariableNames.html>`__."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:435
msgid "You can set the objective function by invoking ``QuadraticProgram.minimize`` or ``QuadraticProgram.maximize``. You can add a constant term as well as linear and quadratic objective function by specifying linear and quadratic terms with either list, matrix or dictionary."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:437
msgid "Note that in the LP format the quadratic part has to be scaled by a factor :math:`1/2`. Thus, when printing as LP format, the quadratic part is first multiplied by 2 and then divided by 2 again."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:439
msgid "For quadratic programs, there are 3 pieces that have to be specified: a constant (offset), a linear term (:math:`c^{T}x`), and a quadratic term (:math:`x^{T}Qx`)."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:441
msgid "The cell below shows how to declare an objective function using a dictionary. For the linear term, keys in the dictionary correspond to variable names, and the corresponding values are the coefficients. For the quadratic term, keys in the dictionary correspond to the two variables being multiplied, and the values are again the coefficients."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:521
msgid "Another way to specify the quadratic program is using arrays. For the linear term, the array corresponds to the vector :math:`c` in the mathematical formulation. For the quadratic term, the array corresponds to the matrix :math:`Q`. Note that the ordering of the variables (:math:`x` in the mathematical formulation) is the order in which the variables were originally declared in the QuadraticProgram object."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:601
msgid "You can access the constant, the linear term, and the quadratic term by looking at ``Quadratic.objective.{constant, linear, quadratic}``, respectively. As for linear and quadratic terms, you can get a dense matrix (``to_array``), a sparse matrix (``coefficients``), and a dictionary (``to_dict``). For dictionaries, you can specify whether to use variable indices or names as keys. Note that the quadratic terms are stored in a compressed way, e.g., ``{('x', 'y'): 1, ('y', 'x'): 2}`` is stored as ``{('x', 'y'): 3}``. You can get the quadratic term as a symmetric matrix by calling ``to_array(symmetric=True)`` or ``to_dict(symmetric=True)``. If you call ``to_dict(name=True)``, you can get a dictionary whose keys are pairs of variable names."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:694
msgid "Adding/removing linear and quadratic constraints"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:705
msgid "You can add linear constraints by setting name, linear expression, sense and right-hand-side value (rhs). You can use senses ‘EQ’, ‘LE’, and ‘GE’ as Docplex supports."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:793
msgid "You can add quadratic constraints as well as objective function and linear constraints."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:887
msgid "You can access linear and quadratic terms of linear and quadratic constraints as in the same way as the objective function."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:932
msgid "You can also remove linear/quadratic constraints by ``remove_linear_constraint`` and ``remove_quadratic_constraint``."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:1021
msgid "You can substitute some of variables with constants or other variables. More precisely, ``QuadraticProgram`` has a method ``substitute_variables(constants=..., variables=...)`` to deal with the following two cases. - :math:`x \\leftarrow c`: when ``constants`` have a dictionary ``{x: c}``. - :math:`x \\leftarrow c y`: when ``variables`` have a dictionary ``{x: (y, c)}``."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:1033
msgid "Substituting Variables"
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:1104
msgid "If the resulting problem is infeasible due to lower bounds or upper bounds, the methods returns the status ``Status.INFEASIBLE``. We try to replace variable ``x`` with -1, but -1 is out of range of ``x`` (0 <= ``x`` <= 1). So, it returns ``Status.INFEASIBLE``."
msgstr ""

#: ../../tutorials/01_quadratic_program.ipynb:1166
msgid "You cannot substitute variables multiple times. The method raises an error in such a case."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:9
msgid "Converters for Quadratic Programs"
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:20
msgid "Optimization problems in Qiskit’s optimization module are represented with the ``QuadraticProgram`` class, which is generic and powerful representation for optimization problems. In general, optimization algorithms are defined for a certain formulation of a quadratic program and we need to convert our problem to the right type."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:22
msgid "For instance, Qiskit provides several optimization algorithms that can handle Quadratic Unconstrained Binary Optimization (QUBO) problems. These are mapped to Ising Hamiltonians, for which Qiskit uses the ``qiskit.aqua.operators`` module, and then their ground state is approximated. For this optimization commonly known algorithms such as VQE or QAOA can be used as underlying routine. See the following tutorial about the `Minimum Eigen Optimizer <./03_minimum_eigen_optimizer.ipynb>`__ for more detail. Note that also other algorithms exist that work differently, such as the ``GroverOptimizer``."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:25
msgid "To map a problem to the correct input format, the optimization module of Qiskit offers a variety of converters. In this tutorial we’re providing an overview on this functionality. Currently, Qiskit contains the following converters. - ``InequalityToEquality``: converts inequality constraints into equality constraints with additional slack variables. - ``IntegerToBinary``: converts integer variables into binary variables and corresponding coefficients. - ``LinearEqualityToPenalty``: convert equality constraints into additional terms of the object function. - ``QuadraticProgramToQubo``: a wrapper for ``InequalityToEquality``, ``IntegerToBinary``, and ``LinearEqualityToPenalty`` for convenience."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:38
msgid "InequalityToEquality"
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:40
msgid "``InequalityToEqualityConverter`` converts inequality constraints into equality constraints with additional slack variables to remove inequality constraints from ``QuadraticProgram``. The upper bounds and the lower bounds of slack variables will be calculated from the difference between the left sides and the right sides of constraints. Signs of slack variables depend on symbols in constraints such as :math:`\\leq` and :math:`\\geq`."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:42
msgid "The following is an example of a maximization problem with two inequality constraints. Variable :math:`x` and :math:`y` are binary variables and variable :math:`z` is an integer variable."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:56
msgid "With ``QuadraticProgram``, an optimization model of the problem is written as follows."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:156
msgid "Call ``convert`` method of ``InequalityToEquality`` to convert."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:254
msgid "After converting, the formulation of the problem looks like as the follows. As we can see, the inequality constraints are replaced with equality constraints with additional integer slack variables, :math:`xyz\\_leg\\text{@}int\\_slack` and :math:`xyz\\_geq\\text{@}int\\_slack`."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:256
msgid "Let us explain how the conversion works. For example, the lower bound of the left side of the first constraint is :math:`0` which is the case of :math:`x=0`, :math:`y=0`, and :math:`z=0`. Thus, the upperbound of the additional integer variable must be :math:`5` to be able to satisfy even the case of :math:`x=0`, :math:`y=0`, and :math:`z=0`. Note that we cut off the part after the decimal point in the converted formulation since the left side of the first constraint in the original formulation can be only integer values. For the second constraint, basically we apply the same approach. However, the symbol in the second constraint is :math:`\\geq`, so we add minus before :math:`xyz\\_geq\\text{@}int\\_slack` to be able to satisfy even the case of :math:`x=1, y=1`, and :math:`z=7`."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:283
msgid "IntegerToBinary"
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:294
msgid "``IntegerToBinary`` converts integer variables into binary variables and coefficients to remove integer variables from ``QuadraticProgram``. For converting, bounded-coefficient encoding proposed in `arxiv:1706.01945 <https://arxiv.org/abs/1706.01945>`__ (Eq. (5)) is used. For more detail of the encoding method, please see the paper."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:296
msgid "We use the output of ``InequalityToEquality`` as starting point. Variable :math:`x` and :math:`y` are binary variables, while the variable :math:`z` and the slack variables :math:`xyz\\_leq\\text{@}int\\_slack` and :math:`xyz\\_geq\\text{@}int\\_slack` are integer variables. We print the problem again for reference."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:382
msgid "Call ``convert`` method of ``IntegerToBinary`` to convert."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:492
msgid "After converting, integer variables :math:`z` is replaced with three binary variables :math:`z\\text{@}0`, :math:`z\\text{@}1` and :math:`z\\text{@}2` with coefficients 1, 2 and 4, respectively as the above. The slack variables :math:`xyz\\_leq\\text{@}int\\_slack` and :math:`xyz\\_geq\\text{@}int\\_slack` that were introduced by ``InequalityToEquality`` are also both replaced with three binary variables with coefficients 1, 2, 2, and 1, 2, 3, respectively."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:494
msgid "Note: Essentially the coefficients mean that the sum of these binary variables with coefficients can be the sum of a subset of :math:`\\{1, 2, 4\\}`, :math:`\\{1, 2, 2\\}`, and :math:`\\{1, 2, 3\\}` to represent that acceptable values :math:`\\{0, \\ldots, 7\\}`, :math:`\\{0, \\ldots, 5\\}`, and :math:`\\{0, \\ldots, 6\\}`, which respects the lower bound and the upper bound of original integer variables correctly."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:496
msgid "``IntegerToBinary`` also provides ``interpret`` method that is the functionality to translate a given binary result back to the original integer representation."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:508
msgid "LinearEqualityToPenalty"
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:519
msgid "``LinearEqualityToPenalty`` converts linear equality constraints into additional quadratic penalty terms of the objective function to map ``QuadraticProgram`` to an unconstrained form. An input to the converter has to be a ``QuadraticProgram`` with only linear equality constraints. Those equality constraints, e.g. \\ :math:`\\sum_i a_i x_i = b` where :math:`a_i` and :math:`b` are numbers and :math:`x_i` is a variable, will be added to the objective function in the form of :math:`M(b - \\sum_i a_i x_i)^2` where :math:`M` is a large number as penalty factor. By default :math:`M= 1e5`. The sign of the term depends on whether the problem type is a maximization or minimization."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:522
msgid "We use the output of ``IntegerToBinary`` as starting point, where all variables are binary variables and all inequality constraints have been mapped to equality constraints. We print the problem again for reference."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:620
msgid "Call ``convert`` method of ``LinearEqualityToPenalty`` to convert."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:774
msgid "After converting, the equality constraints are added to the objective function as additional terms with the default penalty factor :math:`M=1e5`. The resulting problem is now a QUBO and compatible with many quantum optimization algorithms such as VQE, QAOA and so on."
msgstr ""

#: ../../tutorials/02_converters_for_quadratic_programs.ipynb:785
msgid "This gives the same result as before."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:9
msgid "Minimum Eigen Optimizer"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:32
msgid "An interesting class of optimization problems to be addressed by quantum computing are Quadratic Unconstrained Binary Optimization (QUBO) problems. Finding the solution to a QUBO is equivalent to finding the ground state of a corresponding Ising Hamiltonian, which is an important problem not only in optimization, but also in quantum chemistry and physics. For this translation, the binary variables taking values in :math:`\\{0, 1\\}` are replaced by spin variables taking values in :math:`\\{-1, +1\\}`, which allows to replace the resulting spin variables by Pauli Z matrices, and thus, an Ising Hamiltonian. For more details on this mapping we refer to [1]."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:35
msgid "Qiskit provides automatic conversion from a suitable ``QuadraticProgram`` to an Ising Hamiltonian, which then allows to leverage all the ``MinimumEigenSolver`` such as - ``VQE``, - ``QAOA``, or - ``NumpyMinimumEigensolver`` (classical exact method)."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:37
msgid "Qiskit wraps the translation to an Ising Hamiltonian (in Qiskit Aqua also called ``Operator``), the call to an ``MinimumEigensolver`` as well as the translation of the results back to ``OptimizationResult`` in the ``MinimumEigenOptimizer``."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:39
msgid "In the following we first illustrate the conversion from a ``QuadraticProgram`` to an ``Operator`` and then show how to use the ``MinimumEigenOptimizer`` with different ``MinimumEigensolver`` to solve a given ``QuadraticProgram``. The algorithms in Qiskit automatically try to convert a given problem to the supported problem class if possible, for instance, the ``MinimumEigenOptimizer`` will automatically translate integer variables to binary variables or add a linear equality constraints as a quadratic penalty term to the objective. It should be mentioned that Aqua will through a ``QiskitOptimizationError`` if conversion of a quadratic program with integer variable is attempted."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:42
msgid "The circuit depth of ``QAOA`` potentially has to be increased with the problem size, which might be prohibitive for near-term quantum devices. A possible workaround is Recursive QAOA, as introduced in [2]. Qiskit generalizes this concept to the ``RecursiveMinimumEigenOptimizer``, which is introduced at the end of this tutorial."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:45
#: ../../tutorials/04_grover_optimizer.ipynb:29
#: ../../tutorials/05_admm_optimizer.ipynb:81
#: ../../tutorials/07_examples_vehicle_routing.ipynb:168
#: ../../tutorials/08_cvar_optimization.ipynb:27
#: ../../tutorials/10_warm_start_qaoa.ipynb:29
msgid "References"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:47
msgid "[1] `A. Lucas, Ising formulations of many NP problems, Front. Phys., 12 (2014). <https://arxiv.org/abs/1302.5843>`__"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:49
msgid "[2] `S. Bravyi, A. Kliesch, R. Koenig, E. Tang, Obstacles to State Preparation and Variational Optimization from Symmetry Protection, arXiv preprint arXiv:1910.08980 (2019). <https://arxiv.org/abs/1910.08980>`__"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:61
msgid "Converting a QUBO to an Operator"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:156
msgid "Next we translate this QUBO into an Ising operator. This results not only in an ``Operator`` but also in a constant offset to be taking into account to shift the resulting value."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:213
msgid "Sometimes an ``QuadraticProgram`` might also directly be given in the form of an ``Operator``. For such cases, Qiskit also provides a converter from an ``Operator`` back to a ``QuadraticProgram``, which we illustrate in the following."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:287
msgid "This converter allows, for instance, to translate an ``Operator`` to a ``QuadraticProgram`` and then solve the problem with other algorithms that are not based on the Ising Hamiltonian representation, such as the ``GroverOptimizer``."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:299
msgid "Solving a QUBO with the MinimumEigenOptimizer"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:310
msgid "We start by initializing the ``MinimumEigensolver`` we want to use."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:336
msgid "Then, we use the ``MinimumEigensolver`` to create ``MinimumEigenOptimizer``."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:358
msgid "We first use the ``MinimumEigenOptimizer`` based on the classical exact ``NumPyMinimumEigensolver`` to get the optimal benchmark solution for this small example."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:403
msgid "Next we apply the ``MinimumEigenOptimizer`` based on ``QAOA`` to the same problem."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:449
msgid "Analysis of Samples"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:451
msgid "``OptimizationResult`` provides a useful information source ``SolutionSample`` (here denoted as *samples*). They contain information about input values ``x``, objective function values ``fval``, probability of obtaining that result ``probability`` and the solution status ``status`` (``SUCCESS``, ``FAILURE``, ``INFEASIBLE``)."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:509
msgid "We may also want to filter samples according to their status or probabilities."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:585
msgid "If we want to obtain a better perspective of the results, statistics is very helpful, both with respect to the objective function values and their respective probabilities. Thus, mean and standard deviation are the very basics for understanding the results."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:667
msgid "Finally, despite all number-crunching, visualization is usually the best early-analysis approach."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:745
msgid "RecursiveMinimumEigenOptimizer"
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:756
msgid "The ``RecursiveMinimumEigenOptimizer`` takes a ``MinimumEigenOptimizer`` as input and applies the recursive optimization scheme to reduce the size of the problem one variable at a time. Once the size of the generated intermediate problem is below a given threshold (``min_num_vars``), the ``RecursiveMinimumEigenOptimizer`` uses another solver (``min_num_vars_optimizer``), e.g., an exact classical solver such as CPLEX or the ``MinimumEigenOptimizer`` based on the ``NumPyMinimumEigensolver``."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:758
msgid "In the following, we show how to use the ``RecursiveMinimumEigenOptimizer`` using the two ``MinimumEigenOptimizer`` introduced before."
msgstr ""

#: ../../tutorials/03_minimum_eigen_optimizer.ipynb:769
msgid "First, we construct the ``RecursiveMinimumEigenOptimizer`` such that it reduces the problem size from 3 variables to 1 variable and then uses the exact solver for the last variable. Then we call ``solve`` to optimize the considered problem."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:9
msgid "Grover Optimizer"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:23
msgid "Grover Adaptive Search (GAS) has been explored as a possible solution for combinatorial optimization problems, alongside variational algorithms such as Variational Quantum Eigensolver (VQE) and Quantum Approximate Optimization Algorithm (QAOA). The algorithm iteratively applies Grover Search to find the optimum value of an objective function, by using the best-known value from the previous run as a threshold. The adaptive oracle used in GAS recognizes all values above or below the current threshold (for max and min respectively), decreasing the size of the search space every iteration the threshold is updated, until an optimum is found."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:26
msgid "In this notebook we will explore each component of the ``GroverOptimizer``, which utilizes the techniques described in GAS, by minimizing a Quadratic Unconstrained Binary Optimization (QUBO) problem, as described in [1]"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:31
msgid "[1] `A. Gilliam, S. Woerner, C. Gonciulea, Grover Adaptive Search for Constrained Polynomial Binary Optimization, arXiv preprint arXiv:1912.04088 (2019). <https://arxiv.org/abs/1912.04088>`__"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:43
msgid "Grover Adaptive Search"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:45
msgid "Grover Search, the core element of GAS, needs three ingredients:"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:47
msgid "A state preparation operator :math:`A` to construct a superposition of all states in the search space."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:49
msgid "An oracle operator :math:`O`, that recognizes the states of interest and multiplies their amplitudes by -1."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:51
msgid "The Grover diffusion operator :math:`D`, that multiplies the amplitude of the :math:`|0\\rangle_n` state by -1."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:53
msgid "While implementations of GAS vary around the specific use case, the general framework still loosely follows the steps described below."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:59
msgid "|35591a3dc5a64ea5ae86624efe922b14|"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:65
msgid "``GroverOptimizer`` uses ``QuadraticProgramToNegativeValueOracle`` to construct :math:`A_y` such that it prepares a :math:`n`-qubit register to represent the equal superposition of all :math:`|x\\rangle_n` and a :math:`m`-qubit register to (approximately) represent the corresponding :math:`|Q(x)-y\\rangle_m`. Then, all states with :math:`(Q(x) - y)` negative should be flagged by :math:`O_y`. Note that in the implementation discussed, the oracle operator is actually independent of :math:`y`, but this is not a requirement. For clarity, we will refer to the oracle as :math:`O` when the oracle is independent of :math:`y`."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:68
msgid "Put formally, ``QuadraticProgramToNegativeValueOracle`` constructs an :math:`A_y` and :math:`O` such that:"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:74
msgid "|a26c1efb85ce42a491f1eaaa95666bfa|"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:80
msgid "where :math:`|x\\rangle` is the binary encoding of the integer :math:`x`."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:82
msgid "At each iteration in which the threshold :math:`y` is updated, we adapt :math:`A_y` such that the function values are shifted up or down (for minimum and maximum respectively) by :math:`y`. For example, in the context of finding the minimum, as the value of :math:`y` decreases, the search space (negative values) also decreases, until only the minimum value remains. A concrete example will be explored in the next section."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:99
msgid "Find the Minimum of a QUBO Problem using GroverOptimizer"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:101
msgid "The following is a toy example of a minimization problem."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:103
msgid ":nbsphinx-math:`\\begin{eqnarray} \\min_{x \\in \\{0, 1\\}^3} -2x_1x_3 - x_2x_3 - 1x_1 + 2x_2 - 3x_3. \\end{eqnarray}`"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:107
msgid "For our initial steps, we create a docplex model that defines the problem above, and then use the ``from_docplex_mp()`` function to convert the model to a ``QuadraticProgram``, which can be used to represent a QUBO in Qiskit Optimization."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:202
msgid "Next, we create a ``GroverOptimizer`` that uses 6 qubits to encode the value, and will terminate after there have been 10 iterations of GAS without progress (i.e. the value of :math:`y` does not change). The ``solve()`` function takes the ``QuadraticProgram`` we created earlier, and returns a results object that contains information about the run."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:247
msgid "This results in the optimal solution :math:`x_0=1`, :math:`x_1=0`, :math:`x_2=1` and the optimal objective value of :math:`-6` (most of the time, since it is a randomized algorithm). In the following, a custom visualization of the quantum state shows a possible run of ``GroverOptimizer`` applied to this QUBO."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:253
msgid "|bed54c396cb9401fb5f7f39436bf8c82|"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:259
msgid "Each graph shows a single iteration of GAS, with the current values of :math:`r` (= iteration counter) and :math:`y` (= threshold/offset) shown in the title. The X-axis displays the integer equivalent of the input (e.g. ‘101’ :math:`\\rightarrow` 5), and the Y-axis shows the possible function values. As there are 3 binary variables, there are :math:`2^3=8` possible solutions, which are shown in each graph. The color intensity indicates the probability of measuring a certain result (with bright intensity being the highest), while the actual color indicates the corresponding phase (see phase color-wheel below). Note that as :math:`y` decreases, we shift all of the values up by that amount, meaning there are fewer and fewer negative values in the distribution, until only one remains (the minimum)."
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:266
msgid "|34e8d78ac36144a3b5be73478672a917|"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:287
msgid "Check that GroverOptimizer finds the correct value"
msgstr ""

#: ../../tutorials/04_grover_optimizer.ipynb:289
msgid "We can verify that the algorithm is working correctly using the ``MinimumEigenOptimizer`` in Qiskit."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:9
msgid "ADMM Optimizer"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:32
msgid "The ADMM Optimizer can solve classes of mixed-binary constrained optimization problems, hereafter (MBCO), which often appear in logistic, finance, and operation research. In particular, the ADMM Optimizer here designed can tackle the following optimization problem :math:`(P)`:"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:34
msgid "\\min_{x \\in \\mathcal{X},u\\in\\mathcal{U} \\subseteq \\mathbb{R}^l } \\quad q(x) + \\varphi(u),"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:39
msgid "subject to the constraints:"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:41
msgid "\\mathrm{s.t.:~} \\quad G x = b, \\quad  g(x) \\leq 0, \\quad \\ell(x, u) \\leq 0,"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:46
msgid "with the corresponding functional assumptions."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:48
msgid "Function :math:`q: \\mathbb{R}^n \\to \\mathbb{R}` is quadratic, i.e., :math:`q(x) = x^{\\intercal} Q x + a^{\\intercal} x` for a given symmetric squared matrix :math:`Q \\in \\mathbb{R}^n \\times \\mathbb{R}^n, Q = Q^{\\intercal}`, and vector :math:`a \\in \\mathbb{R}^n`;"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:49
msgid "The set :math:`\\mathcal{X} = \\{0,1\\}^n = \\{x_{(i)} (1-x_{(i)}) = 0, \\forall i\\}` enforces the binary constraints;"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:50
msgid "Matrix :math:`G\\in\\mathbb{R}^n \\times \\mathbb{R}^{n'}`, vector :math:`b \\in \\mathbb{R}^{n'}`, and function :math:`g: \\mathbb{R}^n \\to \\mathbb{R}` is convex;"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:51
msgid "Function :math:`\\varphi: \\mathbb{R}^l \\to \\mathbb{R}` is convex and :math:`\\mathcal{U}` is a convex set;"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:52
msgid "Function :math:`\\ell: \\mathbb{R}^n\\times \\mathbb{R}^l \\to \\mathbb{R}` is *jointly* convex in :math:`x, u`."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:63
msgid "In order to solve MBO problems, [1] proposed heuristics for :math:`(P)` based on the Alternating Direction Method of Multipliers (ADMM) [2]. ADMM is an operator splitting algorithm with a long history in convex optimization, and it is known to have residual, objective and dual variable convergence properties, provided that convexity assumptions are holding."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:65
msgid "The method of [1] (referred to as 3-ADMM-H) leverages the ADMM operator-splitting procedure to devise a decomposition for certain classes of MBOs into: - a QUBO subproblem to be solved by on the quantum device via variational algorithms, such as VQE or QAOA; - continuous convex constrained subproblem, which can be efficiently solved with classical optimization solvers."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:67
msgid "The algorithm 3-ADMM-H works as follows:"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:69
msgid "Initialization phase (set the parameters and the QUBO and convex solvers);"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:70
msgid "For each ADMM iterations ($k = 1, 2, :nbsphinx-math:`\\ldots`, $) until termination:"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:72
msgid "Solve a properly defined QUBO subproblem (with a classical or quantum solver);"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:73
msgid "Solve properly defined convex problems (with a classical solver);"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:74
msgid "Update the dual variables."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:76
msgid "Return optimizers and cost."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:78
msgid "A comprehensive discussion on the conditions for convergence, feasibility and optimality of the algorithm can be found in [1]. A variant with 2 ADMM blocks, namely a QUBO subproblem, and a continuous convex constrained subproblem, is also introduced in [1]."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:83
msgid "[1] `C. Gambella and A. Simonetto, Multi-block ADMM heuristics for mixed-binary optimization, on classical and quantum computers, arXiv preprint arXiv:2001.02069 (2020). <https://arxiv.org/abs/2001.02069>`__"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:85
msgid "[2] `S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein, Distributed optimization and statistical learning via the alternating direction method of multipliers, Foundations and Trends in Machine learning, 3, 1–122 (2011). <https://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf>`__"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:97
#: ../../tutorials/07_examples_vehicle_routing.ipynb:188
msgid "Initialization"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:99
msgid "First of all we load all the packages that we need."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:138
msgid "We first initialize all the algorithms we plan to use later in this tutorial."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:140
msgid "To solve the QUBO problems we can choose between - ``MinimumEigenOptimizer`` using different ``MinimumEigensolver``, such as ``VQE``, ``QAOA`` or ``NumpyMinimumEigensolver`` (classical) - ``GroverOptimizer`` - ``CplexOptimizer`` (classical, if CPLEX is installed)"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:142
msgid "and to solve the convex continuous problems we can choose between the following classical solvers: - ``CplexOptimizer`` (if CPLEX is installed) - ``CobylaOptimizer``"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:144
msgid "In case CPLEX is not available, the ``CobylaOptimizer`` (for convex continuous problems) and the ``MinimumEigenOptimizer`` using the ``NumpyMinimumEigensolver`` (for QUBOs) can be used as classical alternatives to CPLEX for testing, validation, and benchmarking."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:178
msgid "Example"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:180
msgid "We test 3-ADMM-H algorithm on a simple Mixed-Binary Quadratic Problem with equality and inequality constraints (Example 6 reported in [1]). We first construct a docplex problem and then load it into a ``QuadraticProgram``."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:274
msgid "Classical Solution"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:276
msgid "3-ADMM-H needs a QUBO optimizer to solve the QUBO subproblem, and a continuous optimizer to solve the continuous convex constrained subproblem. We first solve the problem classically: we use the ``MinimumEigenOptimizer`` with the ``NumPyMinimumEigenSolver`` as a classical and exact QUBO solver and we use the ``CobylaOptimizer`` as a continuous convex solver. 3-ADMM-H supports any other suitable solver available in Qiskit. For instance, VQE, QAOA, and GroverOptimizer can be invoked as quantum solvers, as demonstrated later. If CPLEX is installed, the ``CplexOptimizer`` can also be used as both, a QUBO and convex solver."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:289
msgid "Parameters"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:291
msgid "The 3-ADMM-H are wrapped in class ``ADMMParameters``. Customized parameter values can be set as arguments of the class. In this example, parameters :math:`\\rho, \\beta` are initialized to :math:`1001` and :math:`1000`, respectively. The penalization ``factor_c`` of equality constraints :math:`Gx = b` is set to :math:`900`. The tolerance ``tol`` for primal residual convergence is set to ``1.e-6``. In this case, the 3-block implementation is guaranteed to converge for Theorem 4 of [1], because the inequality constraint with the continuous variable is always active. The 2-block implementation can be run by setting ``three_block=False``, and practically converges to a feasible not optimal solution."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:320
msgid "Calling 3-ADMM-H algorithm"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:322
msgid "To invoke the 3-ADMM-H algorithm, an instance of the ``ADMMOptimizer`` class needs to be created. This takes ADMM-specific parameters and the subproblem optimizers separately into the constructor. The solution returned is an instance of ``OptimizationResult`` class."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:366
msgid "Classical Solver Result"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:368
msgid "The 3-ADMM-H solution can be then printed and visualized. The ``x`` attribute of the solution contains respectively, the values of the binary decision variables and the values of the continuous decision variables. The ``fval`` is the objective value of the solution."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:411
msgid "Solution statistics can be accessed in the ``state`` field and visualized. We here display the convergence of 3-ADMM-H, in terms of primal residuals."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:444
msgid "Quantum Solution"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:446
msgid "We now solve the same optimization problem with QAOA as QUBO optimizer, running on simulated quantum device. First, one need to select the classical optimizer of the eigensolver QAOA. Then, the simulation backend is set. Finally, the eigensolver is wrapped into the ``MinimumEigenOptimizer`` class. A new instance of ``ADMMOptimizer`` is populated with QAOA as QUBO optimizer."
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:489
msgid "Quantum Solver Results"
msgstr ""

#: ../../tutorials/05_admm_optimizer.ipynb:491
msgid "Here we present the results obtained from the quantum solver. As in the example above ``x`` stands for the solution, the ``fval`` is for objective value."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:9
msgid "Max-Cut and Traveling Salesman Problem"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:23
msgid "Many problems in quantitative fields such as finance and engineering are optimization problems. Optimization problems lie at the core of complex decision-making and definition of strategies."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:25
msgid "Optimization (or combinatorial optimization) means searching for an optimal solution in a finite or countably infinite set of potential solutions. Optimality is defined with respect to some criterion function, which is to be minimized or maximized. This is typically called cost function or objective function."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:27
msgid "**Typical optimization problems**"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:29
msgid "Minimization: cost, distance, length of a traversal, weight, processing time, material, energy consumption, number of objects"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:31
msgid "Maximization: profit, value, output, return, yield, utility, efficiency, capacity, number of objects"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:33
msgid "We consider here max-cut problems of practical interest in many fields, and show how they can be mapped on quantum computers manually and how Qiskit’s optimization module supports this."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:36
msgid "Weighted Max-Cut"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:38
msgid "Max-Cut is an NP-complete problem, with applications in clustering, network science, and statistical physics. To grasp how practical applications are mapped into given Max-Cut instances, consider a system of many people that can interact and influence each other. Individuals can be represented by vertices of a graph, and their interactions seen as pairwise connections between vertices of the graph, or edges. With this representation in mind, it is easy to model typical marketing problems. For example, suppose that it is assumed that individuals will influence each other’s buying decisions, and knowledge is given about how strong they will influence each other. The influence can be modeled by weights assigned on each edge of the graph. It is possible then to predict the outcome of a marketing strategy in which products are offered for free to some individuals, and then ask which is the optimal subset of individuals that should get the free products, in order to maximize revenues."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:41
msgid "The formal definition of this problem is the following:"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:43
msgid "Consider an :math:`n`-node undirected graph *G = (V, E)* where *\\|V\\| = n* with edge weights :math:`w_{ij}>0`, :math:`w_{ij}=w_{ji}`, for :math:`(i, j)\\in E`. A cut is defined as a partition of the original set V into two subsets. The cost function to be optimized is in this case the sum of weights of edges connecting points in the two different subsets, *crossing* the cut. By assigning :math:`x_i=0` or :math:`x_i=1` to each node :math:`i`, one tries to maximize the global profit function (here and in the following summations run over indices 0,1,…n-1)"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:46
msgid "\\tilde{C}(\\textbf{x}) = \\sum_{i,j} w_{ij} x_i (1-x_j).\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:48
msgid "In our simple marketing model, :math:`w_{ij}` represents the probability that the person :math:`j` will buy a product after :math:`i` gets a free one. Note that the weights :math:`w_{ij}` can in principle be greater than :math:`1` (or even negative), corresponding to the case where the individual :math:`j` will buy more than one product. Maximizing the total buying probability corresponds to maximizing the total future revenues. In the case where the profit probability will be greater than the cost of the initial free samples, the strategy is a convenient one. An extension to this model has the nodes themselves carry weights, which can be regarded, in our marketing model, as the likelihood that a person granted with a free sample of the product will buy it again in the future. With this additional information in our model, the objective function to maximize becomes"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:51
msgid "C(\\textbf{x}) = \\sum_{i,j} w_{ij} x_i (1-x_j)+\\sum_i w_i x_i.\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:53
msgid "In order to find a solution to this problem on a quantum computer, one needs first to map it to an Ising Hamiltonian. This can be done with the assignment :math:`x_i\\rightarrow (1-Z_i)/2`, where :math:`Z_i` is the Pauli Z operator that has eigenvalues :math:`\\pm 1`. Doing this we find that"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:55
msgid "C(\\textbf{Z}) = \\sum_{i,j} \\frac{w_{ij}}{4} (1-Z_i)(1+Z_j) + \\sum_i \\frac{w_i}{2} (1-Z_i) = -\\frac{1}{2}\\left( \\sum_{i<j} w_{ij} Z_i Z_j +\\sum_i w_i Z_i\\right)+\\mathrm{const},\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:57
msgid "where :math:`\\mathrm{const} = \\sum_{i<j}w_{ij}/2+\\sum_i w_i/2`. In other terms, the weighted Max-Cut problem is equivalent to minimizing the Ising Hamiltonian"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:59
msgid "H = \\sum_i w_i Z_i + \\sum_{i<j} w_{ij} Z_iZ_j.\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:61
msgid "Qiskit’s optimization module can generate the Ising Hamiltonian for the first profit function :math:`\\tilde{C}`. To this extent, function :math:`\\tilde{C}` can be modeled as a ``QuadraticProgram``, which provides the ``to_ising()`` method."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:64
msgid "Approximate Universal Quantum Computing for Optimization Problems"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:66
msgid "There has been a considerable amount of interest in recent times about the use of quantum computers to find a solution to combinatorial optimization problems. It is important to say that, given the classical nature of combinatorial problems, exponential speedup in using quantum computers compared to the best classical algorithms is not guaranteed. However, due to the nature and importance of the target problems, it is worth investigating heuristic approaches on a quantum computer that could indeed speed up some problem instances. Here we demonstrate an approach that is based on the *Quantum Approximate Optimization Algorithm* (QAOA) by Farhi, Goldstone, and Gutmann (2014). We frame the algorithm in the context of *approximate quantum computing*, given its heuristic nature."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:69
msgid "The algorithm works as follows:"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:71
msgid "Choose the :math:`w_i` and :math:`w_{ij}` in the target Ising problem. In principle, even higher powers of Z are allowed."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:73
#: ../../tutorials/07_examples_vehicle_routing.ipynb:96
msgid "Choose the depth of the quantum circuit :math:`m`. Note that the depth can be modified adaptively."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:75
msgid "Choose a set of controls :math:`\\theta` and make a trial function :math:`|\\psi(\\boldsymbol\\theta)\\rangle`, built using a quantum circuit made of C-Phase gates and single-qubit Y rotations, parameterized by the components of :math:`\\boldsymbol\\theta`."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:77
msgid "Evaluate"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:79
msgid "C(\\boldsymbol\\theta) = \\langle\\psi(\\boldsymbol\\theta)~|H|~\\psi(\\boldsymbol\\theta)\\rangle = \\sum_i w_i \\langle\\psi(\\boldsymbol\\theta)~|Z_i|~\\psi(\\boldsymbol\\theta)\\rangle+ \\sum_{i<j} w_{ij} \\langle\\psi(\\boldsymbol\\theta)~|Z_iZ_j|~\\psi(\\boldsymbol\\theta)\\rangle\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:81
msgid "by sampling the outcome of the circuit in the Z-basis and adding the expectation values of the individual Ising terms together. In general, different control points around :math:`\\boldsymbol\\theta` have to be estimated, depending on the classical optimizer chosen."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:83
#: ../../tutorials/07_examples_vehicle_routing.ipynb:102
msgid "Use a classical optimizer to choose a new set of controls."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:85
#: ../../tutorials/07_examples_vehicle_routing.ipynb:103
msgid "Continue until :math:`C(\\boldsymbol\\theta)` reaches a minimum, close enough to the solution :math:`\\boldsymbol\\theta^*`."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:87
msgid "Use the last :math:`\\boldsymbol\\theta` to generate a final set of samples from the distribution :math:`|\\langle z_i~|\\psi(\\boldsymbol\\theta)\\rangle|^2\\;\\forall i` to obtain the answer."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:89
msgid "It is our belief the difficulty of finding good heuristic algorithms will come down to the choice of an appropriate trial wavefunction. For example, one could consider a trial function whose entanglement best aligns with the target problem, or simply make the amount of entanglement a variable. In this tutorial, we will consider a simple trial function of the form"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:91
msgid "|\\psi(\\theta)\\rangle  = [U_\\mathrm{single}(\\boldsymbol\\theta) U_\\mathrm{entangler}]^m |+\\rangle\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:93
msgid "where :math:`U_\\mathrm{entangler}` is a collection of C-Phase gates (fully entangling gates), and :math:`U_\\mathrm{single}(\\theta) = \\prod_{i=1}^n Y(\\theta_{i})`, where :math:`n` is the number of qubits and :math:`m` is the depth of the quantum circuit. The motivation for this choice is that for these classical problems this choice allows us to search over the space of quantum states that have only real coefficients, still exploiting the entanglement to potentially converge faster to the solution."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:96
msgid "One advantage of using this sampling method compared to adiabatic approaches is that the target Ising Hamiltonian does not have to be implemented directly on hardware, allowing this algorithm not to be limited to the connectivity of the device. Furthermore, higher-order terms in the cost function, such as :math:`Z_iZ_jZ_k`, can also be sampled efficiently, whereas in adiabatic or annealing approaches they are generally impractical to deal with."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:98
msgid "References: - A. Lucas, Frontiers in Physics 2, 5 (2014) - E. Farhi, J. Goldstone, S. Gutmann e-print arXiv 1411.4028 (2014) - D. Wecker, M. B. Hastings, M. Troyer Phys. Rev. A 94, 022309 (2016) - E. Farhi, J. Goldstone, S. Gutmann, H. Neven e-print arXiv 1703.06199 (2017)"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:110
msgid "Application classes"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:112
msgid "We use the application classes for the max-cut problem and the traveling salesman problem in this page. There are application classes for other optimization problems available as well. See `Application Classes for Optimization Problems <09_application_classes.ipynb>`__ for details."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:148
msgid "Max-Cut problem"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:247
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:877
msgid "Brute force approach"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:249
msgid "Try all possible :math:`2^n` combinations. For :math:`n = 4`, as in this example, one deals with only 16 combinations, but for n = 1000, one has 1.071509e+30 combinations, which is impractical to deal with by using a brute force approach."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:356
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:972
msgid "Mapping to the Ising problem"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:367
msgid "Qiskit provides functionality to generate ``QuadraticProgram`` from the problem specification as well as create the corresponding Ising Hamiltonian."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:525
msgid "Since the problem was cast to a minimization problem, the solution of :math:`-4` corresponds to the optimum."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:537
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:1240
msgid "Checking that the full Hamiltonian gives the right cost"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:613
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:1318
msgid "Running it on quantum computer"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:615
#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:1320
msgid "We run the optimization routine using a feedback loop with a quantum computer that uses trial functions built with Y single-qubit rotations, :math:`U_\\mathrm{single}(\\theta) = \\prod_{i=1}^n Y(\\theta_{i})`, and entangler steps :math:`U_\\mathrm{entangler}`."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:772
msgid "Traveling Salesman Problem"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:774
msgid "In addition to being a notorious NP-complete problem that has drawn the attention of computer scientists and mathematicians for over two centuries, the Traveling Salesman Problem (TSP) has important bearings on finance and marketing, as its name suggests. Colloquially speaking, the traveling salesman is a person that goes from city to city to sell merchandise. The objective in this case is to find the shortest path that would enable the salesman to visit all the cities and return to its hometown, i.e. the city where he started traveling. By doing this, the salesman gets to maximize potential sales in the least amount of time."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:777
msgid "The problem derives its importance from its “hardness” and ubiquitous equivalence to other relevant combinatorial optimization problems that arise in practice."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:779
msgid "The mathematical formulation with some early analysis was proposed by W.R. Hamilton in the early 19th century. Mathematically the problem is, as in the case of Max-Cut, best abstracted in terms of graphs. The TSP on the nodes of a graph asks for the shortest *Hamiltonian cycle* that can be taken through each of the nodes. A Hamilton cycle is a closed path that uses every vertex of a graph once. The general solution is unknown and an algorithm that finds it efficiently (e.g., in polynomial time) is not expected to exist."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:782
msgid "Find the shortest Hamiltonian cycle in a graph :math:`G=(V,E)` with :math:`n=|V|` nodes and distances, :math:`w_{ij}` (distance from vertex :math:`i` to vertex :math:`j`). A Hamiltonian cycle is described by :math:`N^2` variables :math:`x_{i,p}`, where :math:`i` represents the node and :math:`p` represents its order in a prospective cycle. The decision variable takes the value 1 if the solution occurs at node :math:`i` at time order :math:`p`. We require that every node can only appear once in the cycle, and for each time a node has to occur. This amounts to the two constraints (here and in the following, whenever not specified, the summands run over 0,1,…N-1)"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:785
msgid "\\sum_{i} x_{i,p} = 1 ~~\\forall p\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:787
msgid "\\sum_{p} x_{i,p} = 1 ~~\\forall i.\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:789
msgid "For nodes in our prospective ordering, if :math:`x_{i,p}` and :math:`x_{j,p+1}` are both 1, then there should be an energy penalty if :math:`(i,j) \\notin E` (not connected in the graph). The form of this penalty is"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:791
msgid "\\sum_{i,j\\notin E}\\sum_{p} x_{i,p}x_{j,p+1}>0,\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:793
msgid "where it is assumed the boundary condition of the Hamiltonian cycles :math:`(p=N)\\equiv (p=0)`. However, here it will be assumed a fully connected graph and not include this term. The distance that needs to be minimized is"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:795
msgid "C(\\textbf{x})=\\sum_{i,j}w_{ij}\\sum_{p} x_{i,p}x_{j,p+1}.\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:797
msgid "Putting this all together in a single objective function to be minimized, we get the following:"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:799
msgid "C(\\textbf{x})=\\sum_{i,j}w_{ij}\\sum_{p} x_{i,p}x_{j,p+1}+ A\\sum_p\\left(1- \\sum_i x_{i,p}\\right)^2+A\\sum_i\\left(1- \\sum_p x_{i,p}\\right)^2,\n\n"
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:801
msgid "where :math:`A` is a free parameter. One needs to ensure that :math:`A` is large enough so that these constraints are respected. One way to do this is to choose :math:`A` such that :math:`A > \\mathrm{max}(w_{ij})`."
msgstr ""

#: ../../tutorials/06_examples_max_cut_and_tsp.ipynb:803
msgid "Once again, it is easy to map the problem in this form to a quantum computer, and the solution will be found by minimizing a Ising Hamiltonian."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:9
msgid "Vehicle Routing"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:12
msgid "The Introduction"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:14
msgid "Logistics is a major industry, with some estimates valuing it at USD 8183 billion globally in 2015. Most service providers operate a number of vehicles (e.g., trucks and container ships), a number of depots, where the vehicles are based overnight, and serve a number of client locations with each vehicle during each day. There are many optimization and control problems that consider these parameters. Computationally, the key challenge is how to design routes from depots to a number of client locations and back to the depot, so as to minimize vehicle-miles traveled, time spent, or similar objective functions. In this notebook we formalize an idealized version of the problem and showcase its solution using the quantum approximate optimization approach of Farhi, Goldstone, and Gutmann (2014)."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:17
msgid "The overall workflow we demonstrate comprises:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:19
msgid "establish the client locations. Normally, these would be available ahead of the day of deliveries from a database. In our use case, we generate these randomly."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:21
msgid "compute the pair-wise distances, travel times, or similar. In our case, we consider the Euclidean distance, “as the crow flies”, which is perhaps the simplest possible."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:23
msgid "compute the actual routes. This step is run twice, actually. First, we obtain a reference value by a run of a classical solver (IBM CPLEX) on the classical computer. Second, we run an alternative, hybrid algorithm partly on the quantum computer."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:25
msgid "visualization of the results. In our case, this is again a simplistic plot."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:27
msgid "In the following, we first explain the model, before we proceed with the installation of the pre-requisites and the data loading."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:30
msgid "The Model"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:32
msgid "Mathematically speaking, the vehicle routing problem (VRP) is a combinatorial problem, wherein the best routes from a depot to a number of clients and back to the depot are sought, given a number of available vehicles. There are a number of formulations possible, extending a number of formulations of the traveling salesman problem [Applegate et al, 2006]. Here, we present a formulation known as MTZ [Miller, Tucker, Zemlin, 1960]."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:34
msgid "Let :math:`n` be the number of clients (indexed as :math:`1,\\dots,n`), and :math:`K` be the number of available vehicles. Let :math:`x_{ij} = \\{0,1\\}` be the binary decision variable which, if it is :math:`1`, activates the segment from node :math:`i` to node :math:`j`. The node index runs from :math:`0` to :math:`n`, where :math:`0` is (by convention) the depot. There are twice as many distinct decision variables as edges. For example, in a fully connected graph, there are :math:`n(n+1)` binary decision variables."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:37
msgid "If two nodes :math:`i` and :math:`j` have a link from :math:`i` to :math:`j`, we write :math:`i \\sim j`. We also denote with :math:`\\delta(i)^+` the set of nodes to which :math:`i` has a link, i.e., :math:`j \\in \\delta(i)^+` if and only if :math:`i \\sim j`. Similarly, we denote with :math:`\\delta(i)^-` the set of nodes which are connected to :math:`i`, in the sense that :math:`j \\in \\delta(i)^-` if and only if :math:`j \\sim i`."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:39
msgid "In addition, we consider continuous variables, for all nodes :math:`i = 1,\\dots, n`, denoted :math:`u_i`. These variables are needed in the MTZ formulation of the problem to eliminate sub-tours between clients."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:41
msgid "The VRP can be formulated as:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:43
msgid "(VRP) \\quad  f = \\min_{\\{x_{ij}\\}_{i\\sim j}\\in \\{0,1\\}, \\{u_i\\}_{i=1,\\dots,n}\\in \\mathbb{R}} \\quad \\sum_{i \\sim j} w_{ij} x_{ij}"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:48
msgid "subject to the node-visiting constraint:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:50
msgid "\\sum_{j \\in \\delta(i)^+} x_{ij} = 1, \\,\\sum_{j \\in \\delta(i)^-} x_{ji} = 1,\\, \\forall i \\in \\{1,\\dots,n\\},"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:55
msgid "the depot-visiting constraints:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:57
msgid "\\sum_{i \\in \\delta(0)^+} x_{0i} = K, \\, \\sum_{j \\in \\delta(0)^+} x_{j0} = K,"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:62
msgid "and the sub-tour elimination constraints:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:64
msgid "u_i - u_j + Q x_{ij} \\leq Q-q_j, \\, \\forall i \\sim j, \\,i ,j \\neq 0, \\quad q_i \\leq u_i \\leq Q,\\, \\forall i, i \\neq 0."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:69
msgid "In particular, - The cost function is linear in the cost functions and weighs the different arches based on a positive weight :math:`w_{ij}>0` (typically the distance between node :math:`i` and node :math:`j`); - The first set of constraints enforce that from and to every client, only one link is allowed; - The second set of constraints enforce that from and to the depot, exactly :math:`K` links are allowed; - The third set of constraints enforce the sub-tour elimination constraints and are bounds on :math:`u_i`, with :math:`Q>q_j>0`, and :math:`Q,q_i \\in \\mathbb{R}`."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:73
msgid "Classical solution"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:75
msgid "We can solve the VRP classically, e.g., by using CPLEX. CPLEX uses a branch-and-bound-and-cut method to find an approximate solution of the VRP, which, in this formulation, is a mixed-integer linear program (MILP). For the sake of notation, we pack the decision variables in one vector as"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:77
msgid "{\\bf z} = [x_{01},x_{02},\\ldots,x_{10}, x_{12},\\ldots,x_{n(n-1)}]^T,"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:82
msgid "wherein :math:`{\\bf z} \\in \\{0,1\\}^N`, with :math:`N = n (n+1)`. So the dimension of the problem scales quadratically with the number of nodes. Let us denote the optimal solution by :math:`{\\bf z}^*`, and the associated optimal cost :math:`f^*`."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:85
msgid "Quantum solution"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:87
msgid "Here, we demonstrate an approach that combines classical and quantum computing steps, following the quantum approximate optimization approach of Farhi, Goldstone, and Gutmann (2014). In particular, we use the variational quantum eigensolver (VQE). We stress that given the use of limited depth of the quantum circuits employed (variational forms), it is hard to discuss the speed-up of the algorithm, as the solution obtained is heuristic in nature. At the same time, due to the nature and importance of the target problems, it is worth investigating heuristic approaches, which may be worthwhile for some problem classes."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:90
msgid "Following [5], the algorithm can be summarized as follows:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:92
msgid "Preparation steps:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:94
msgid "Transform the combinatorial problem into a binary polynomial optimization problem with equality constraints only;"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:95
msgid "Map the resulting problem into an Ising Hamiltonian (:math:`H`) for variables :math:`{\\bf z}` and basis :math:`Z`, via penalty methods if necessary;"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:97
msgid "Choose a set of controls :math:`\\theta` and make a trial function :math:`\\big|\\psi(\\boldsymbol\\theta)\\rangle`, built using a quantum circuit made of C-Phase gates and single-qubit Y rotations, parameterized by the components of :math:`\\boldsymbol\\theta`."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:99
msgid "Algorithm steps:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:101
msgid "Evaluate :math:`C(\\boldsymbol\\theta) = \\langle\\psi(\\boldsymbol\\theta)\\big|H\\big|\\psi(\\boldsymbol\\theta)\\rangle` by sampling the outcome of the circuit in the Z-basis and adding the expectation values of the individual Ising terms together. In general, different control points around :math:`\\boldsymbol\\theta` have to be estimated, depending on the classical optimizer chosen."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:104
msgid "Use the last :math:`\\boldsymbol\\theta` to generate a final set of samples from the distribution :math:`\\Big|\\langle z_i\\big|\\psi(\\boldsymbol\\theta)\\rangle\\Big|^2\\;\\forall i` to obtain the answer."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:106
msgid "There are many parameters throughout, notably the choice of the trial wavefunction. Below, we consider:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:108
msgid "\\big|\\psi(\\theta)\\rangle = [U_\\mathrm{single}(\\boldsymbol\\theta) U_\\mathrm{entangler}]^m \\big|+\\rangle"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:113
msgid "where :math:`U_\\mathrm{entangler}` is a collection of C-Phase gates (fully-entangling gates), and :math:`U_\\mathrm{single}(\\theta) = \\prod_{i=1}^N Y(\\theta_{i})`, where :math:`N` is the number of qubits and :math:`m` is the depth of the quantum circuit."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:116
msgid "Construct the Ising Hamiltonian"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:118
msgid "From :math:`VRP` one can construct a binary polynomial optimization with equality constraints only by considering cases in which :math:`K=n-1`. In these cases the sub-tour elimination constraints are not necessary and the problem is only on the variable :math:`{\\bf z}`. In particular, we can write an augmented Lagrangian as"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:120
msgid "(IH) \\quad H = \\sum_{i \\sim j} w_{ij} x_{ij}  + A \\sum_{i \\in \\{1,\\dots,n\\}} \\Big(\\sum_{j \\in \\delta(i)^+} x_{ij} - 1\\Big)^2 + A \\sum_{i \\in \\{1,\\dots,n\\}}\\Big(\\sum_{j \\in \\delta(i)^-} x_{ji} - 1\\Big)^2 +A \\Big(\\sum_{i \\in \\delta(0)^+} x_{0i} - K\\Big)^2 + A\\Big(\\sum_{j \\in \\delta(0)^+} x_{j0} - K\\Big)^2"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:125
msgid "where :math:`A` is a big enough parameter."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:128
msgid "From Hamiltonian to QP formulation"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:130
msgid "In the vector :math:`{\\bf z}`, and for a complete graph (:math:`\\delta(i)^+ = \\delta(i)^- = \\{0,1,\\dots,i-1,i+1,\\dots,n\\}`), :math:`H` can be written as follows."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:132
msgid "\\min_{{\\bf z}\\in \\{0,1\\}^{n(n+1)}} {\\bf w}^T {\\bf z}  + A \\sum_{i \\in \\{1,\\dots,n\\}} \\Big({\\bf e}_i \\otimes {\\bf 1}_n^T {\\bf z} - 1\\Big)^2 + A \\sum_{i \\in \\{1,\\dots,n\\}}\\Big({\\bf v}_i^T {\\bf z} - 1\\Big)^2 + A \\Big(({\\bf e}_0 \\otimes {\\bf 1}_n)^T{\\bf z} - K\\Big)^2 + A\\Big({\\bf v}_0^T{\\bf z} - K\\Big)^2."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:137
msgid "That is:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:139
msgid "\\min_{\\bf z\\in \\{0,1\\}^{n(n+1)}} \\bf z^T {\\bf Q} \\bf z + {\\bf g}^T \\bf z + c,"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:144
msgid "Where: first term:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:146
msgid "{\\bf Q} = A \\sum_{i \\in \\{0,1,\\dots,n\\}}  \\Big[({\\bf e}_i \\otimes {\\bf 1}_n)({\\bf e}_i \\otimes {\\bf 1}_n)^T + {\\bf v}_i{\\bf v}_i^T \\Big]"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:151
msgid "Second term:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:153
msgid "{\\bf g} = {\\bf w} -2 A \\sum_{i \\in \\{1,\\dots,n\\}} \\Big[({\\bf e}_i \\otimes {\\bf 1}_n) + {\\bf v}_i \\Big] -2 A K \\Big[({\\bf e}_0 \\otimes {\\bf 1}_n) + {\\bf v}_0 \\Big]"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:158
msgid "Third term:"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:160
msgid "c = 2An +2AK^2."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:165
msgid "The QP formulation of the Ising Hamiltonian is ready for the use of VQE. We will solve the QP using optimization stack available in Qiskit."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:170
msgid "[1] E. Farhi, J. Goldstone, S. Gutmann e-print arXiv 1411.4028, 2014"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:172
msgid "[2] `Max-Cut and Traveling Salesman Problem <./06_examples_max_cut_and_tsp.ipynb>`__"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:174
msgid "[3] C. E. Miller, E. W. Tucker, and R. A. Zemlin (1960). “Integer Programming Formulations and Travelling Salesman Problems”. J. ACM. 7: 326–329. doi:10.1145/321043.321046."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:176
msgid "[4] D. L. Applegate, R. M. Bixby, V. Chvátal, and W. J. Cook (2006). The Traveling Salesman Problem. Princeton University Press, ISBN 978-0-691-12993-8."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:190
msgid "First of all we load all the packages that we need: - Python 3.6 or greater is required; - CPLEX 12.8 or greater is required for the classical computations; - Latest Qiskit is required for the quantum computations."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:252
msgid "We then initialize the variables"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:275
msgid "We define an initializer class that randomly places the nodes in a 2-D plane and computes the distance between them."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:331
msgid "Classical solution using IBM ILOG CPLEX"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:333
msgid "For a classical solution, we use IBM ILOG CPLEX. CPLEX is able to find the exact solution of this problem. We first define a ClassicalOptimizer class that encodes the problem in a way that CPLEX can solve, and then instantiate the class and solve it."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:542
msgid "If you have CPLEX, the solution shows the depot with a star and the selected routes for the vehicles with arrows."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:554
msgid "Quantum solution from the ground up"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:556
msgid "For the quantum solution, we use Qiskit."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:558
msgid "First, we derive the solution from the ground up, using a class QuantumOptimizer that encodes the quantum approach to solve the problem and then we instantiate it and solve it. We define the following methods inside the class: - ``binary_representation`` : encodes the problem :math:`(M)` into a QP terms (that’s basically linear algebra); - ``construct_problem`` : constructs a QUBO optimization problem as an instance of ``QuadraticProgram``; - ``solve_problem``: solves the problem :math:`(M)` constructed at the previous step via ``MinimunEigenOptimizer`` by using VQE with default parameters;"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:669
msgid "Step 1"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:671
msgid "Instantiate the quantum optimizer class with parameters: - the instance; - the number of nodes and vehicles ``n`` and ``K``;"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:694
msgid "Step 2"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:696
msgid "Encode the problem as a binary formulation (IH-QP)."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:698
msgid "Sanity check: make sure that the binary formulation in the quantum optimizer is correct (i.e., yields the same cost given the same solution)."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:755
msgid "Step 3"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:757
msgid "Encode the problem as an instance of ``QuadraticProgram``."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:779
msgid "Step 4"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:781
msgid "Solve the problem via ``MinimumEigenOptimizer`` from the optimization stack. N.B. Depending on the number of qubits, the state-vector simulation can take a while; for example with 12 qubits, it takes more than 12 hours. Logging is useful to see what the program is doing."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:824
msgid "Step 5"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:826
msgid "Visualize the solution"
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:869
msgid "The plots present the depot with a star and the selected routes for the vehicles with arrows. Note that in this particular case, we can find the optimal solution of the QP formulation, which happens to coincide with the optimal solution of the ILP."
msgstr ""

#: ../../tutorials/07_examples_vehicle_routing.ipynb:871
msgid "Keep in mind that VQE is an heuristic working on the QP formulation of the Ising Hamiltonian, though. For suitable choices of A, local optima of the QP formulation will be feasible solutions to the ILP. While for some small instances, as above, we can find optimal solutions of the QP formulation which coincide with optima of the ILP, finding optimal solutions of the ILP is harder than finding local optima of the QP formulation, in general, which in turn is harder than finding feasible solutions of the ILP. Even within the VQE, one may provide stronger guarantees, for specific variational forms (trial wave functions)."
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:9
msgid "Improving Variational Quantum Optimization using CVaR"
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:23
msgid "This notebook shows how to use the Conditional Value at Risk (CVaR) objective function introduced in [1] within the variational quantum optimization algorithms provided by Qiskit. Particularly, it is shown how to setup the ``MinimumEigenOptimizer`` using ``VQE`` accordingly. For a given set of shots with corresponding objective values of the considered optimization problem, the CVaR with confidence level :math:`\\alpha \\in [0, 1]` is defined as the average of the :math:`\\alpha` best shots. Thus, :math:`\\alpha = 1` corresponds to the standard expected value, while :math:`\\alpha=0` corresponds to the minimum of the given shots, and :math:`\\alpha \\in (0, 1)` is a tradeoff between focusing on better shots, but still applying some averaging to smoothen the optimization landscape."
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:29
msgid "[1] `P. Barkoutsos et al., Improving Variational Quantum Optimization using CVaR, Quantum 4, 256 (2020). <https://quantum-journal.org/papers/q-2020-04-20-256/>`__"
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:74
msgid "Portfolio Optimization"
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:76
msgid "In the following we define a problem instance for portfolio optimization as introduced in [1]."
msgstr ""

#: ../../tutorials/08_cvar_optimization.ipynb:194
msgid "Minimum Eigen Optimizer using VQE"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:9
msgid "Application Classes for Optimization Problems"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:23
msgid "We introduce application classes for the following optimization problems so that users can easily try various optimization problems on quantum computers."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:25
msgid "Exact cover problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:27
msgid "Given a collection of subsets of items, find a subcollection such that each item is covered exactly once."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:29
#: ../../tutorials/09_application_classes.ipynb:430
msgid "Knapsack problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:31
msgid "Given a set of items, find a subset of items such that the total weight is within the capacity and the total value is maximized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:33
msgid "Number partition problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:35
msgid "Given a multiset of positive integers, find a partition of the multiset into two subsets such that the sums of the subsets are equal."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:37
msgid "Set packing problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:39
msgid "Given a collection of subsets of items, find a subcollection such that all subsets of the subcollection are pairwise disjoint and the number of items in the subcollection is maximized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:41
msgid "Graph problems"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:43
msgid "Clique problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:45
msgid "Given an undirected graph, find a subset of nodes with a specified number or the maximum number such that the induced subgraph is complete."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:47
msgid "Graph partition problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:49
msgid "Given an undirected graph, find a partition into two components whose sizes are equal such that the total capacity of the edges between the two components is minimized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:51
msgid "Max-cut problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:53
msgid "Given an undirected graph, find a partition of nodes into two subsets such that the total weight of the edges between the two subsets is maximized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:55
msgid "Stable set problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:57
msgid "Given an undirected graph, find a subset of nodes such that no edge connects the nodes in the subset and the number of nodes is maximized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:59
msgid "Traveling salesman problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:61
msgid "Given a graph, find a route with the minimum distance such that the route visits each city exactly once."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:63
msgid "Vehicle routing problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:65
msgid "Given a graph, a depot node, and the number of vehicles (routes), find a set of routes such that each node is covered exactly once except the depot and the total distance of the routes is minimized."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:67
#: ../../tutorials/09_application_classes.ipynb:120
msgid "Vertex cover problem"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:69
msgid "Given an undirected graph, find a subset of nodes with the minimum size such that each edge has at least one endpoint in the subsets."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:71
msgid "The application classes for graph problems (``GraphOptimizationApplication``) provide a functionality to draw graphs of an instance and a result. Note that you need to install ``matplotlib`` beforehand to utilize the functionality."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:82
msgid "We introduce examples of the vertex cover problem and the knapsack problem in this page."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:84
msgid "Examples of the max-cut problem and the traveling salesman problem are available in `Max-Cut and Traveling Salesman Problem <06_examples_max_cut_and_tsp.ipynb>`__."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:95
msgid "We first import packages necessary for application classes."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:122
msgid "We introduce the application class for the vertex cover problem as an example of graph problems. Given an undirected graph, the vertex cover problem asks us to find a subset of nodes with the minimum size such that all edges are covered by any node selected."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:124
msgid "We import the application class ``VertexCover`` for the vertex cover problem and ``networkx`` to generate a random graph."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:189
msgid "``VertexCover`` takes a graph as an instance and ``to_quadratic_program`` generates a corresponding ``QuadraticProgram`` of the instance of the vertex cover problem."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:285
msgid "You can solve the problem as follows. ``NumPyMinimumEigensolver`` finds the minimum eigen vector. You can also apply QAOA. Note that the solution by QAOA is not always optimal."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:432
msgid "The knapsack problem asks us to find a combination of items such that the total weight is within the capacity of the knapsack and maximize the total value of the items. The following examples solve an instance of the knapsack problem with 5 items by Numpy eigensolver and QAOA."
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:617
msgid "How to check the Hamiltonian"
msgstr ""

#: ../../tutorials/09_application_classes.ipynb:619
msgid "If you want to check the actual Hamiltonian generated from your problem instance, you need to apply a converter as follows."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:9
msgid "Warm-starting quantum optimization"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:14
msgid "Optimization problems with integer variables or constraints are often hard to solve. For example, the Quadratic Unconstrained Binary Optimization (QUBO) problem, i.e."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:16
msgid ":nbsphinx-math:`\\begin{align} \\min_{x\\in\\{0,1\\}^n}x^T\\Sigma x + \\mu^Tx, \\end{align}`"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:20
msgid "is NP-Hard. Here, :math:`\\Sigma` is an :math:`n\\times n` matrix and :math:`x` is a vector of :math:`n` binary variables. Note that we could have added the linear term :math:`\\mu` to the diagonal as :math:`x_i^2=x_i` for :math:`x_i\\in\\{0, 1\\}`. While QUBOs are hard to solve there exists many ways to relax them to problems that are easier to solve. For example, if :math:`\\Sigma` is semi-definite positive the QUBO can be relaxed and results in a convex Quadratic Program"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:22
msgid ":nbsphinx-math:`\\begin{align} \\min_{x\\in[0,1]^n}x^T\\Sigma x, \\end{align}`"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:26
msgid "which becomes easy to solve as :math:`x` now represents :math:`n` continuous variables bound to the range :math:`[0, 1]`. Such relaxations can be leveraged to warm-start quantum optimization algorithms as shown in [1]."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:31
msgid "[1] `D. J. Egger, J Marecek, S. Woerner, Warm-starting quantum optimization, arXiv:2009.10095 <http://arxiv.org/abs/2009.10095>`__"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:68
msgid "Preliminaries: relaxing QUBOs"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:70
msgid "First, we show how to relax a QUBO built with a semi-definite positive matrix to obtain an easy-to-solve QP."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:112
msgid "For this example, we use a positive semi-definite matrix :math:`\\Sigma` and a linear term :math:`\\mu` as defined below."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:139
msgid "Using DOCPLEX we build a model with binary variables."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:235
msgid "Such binary problems are hard to deal with but can be solved if the problem instance is small enough. Our example above has as solution"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:280
msgid "We can create a relaxation of this problem in which the variables are no longer binary. Note that we use the ``QuadraticProgramToQubo`` converter to convert the constraint into a quadratic penalty term. We do this to remain consistent with the steps that the Qiskit optimization module applies internally."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:370
msgid "The solution of this continuous relaxation is different from the solution to the binary problem but can be used to warm-start a solver when dealing with the binary problem."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:460
msgid "QAOA"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:462
msgid "Here, we illustrate how to warm-start the quantum approximate optimization algorithm (QAOA) by leveraging the relaxed problem shown above."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:465
msgid "Standard QAOA"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:467
msgid "First, we use standard QAOA to solve the QUBO. To do this, we convert the QUBO to Qiskit’s QuadraticProgram class (note that the resulting problem is still a binary problem)."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:538
#: ../../tutorials/10_warm_start_qaoa.ipynb:815
msgid "Warm-start QAOA"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:540
msgid "Next, we compare this result to a warm-start QAOA in which we use the solution to the continuous relaxation of the problem. First, we create the initial state"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:542
msgid ":nbsphinx-math:`\\begin{align} |\\phi^*\\rangle=\\bigotimes_{i=0}^{n-1}R_y(\\theta_i)|0\\rangle_n . \\end{align}`"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:546
msgid "which is given by applying :math:`R_y` rotations with an angle :math:`\\theta=2\\arcsin(\\sqrt{c^*_i})` that depends on the solution to the relaxed problem. Here, :math:`c^*_i` the value of variable :math:`i` of the relaxed problem."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:584
msgid "Next, we create the mixer operator for QAOA. When warm-starting QAOA we must ensure that the mixer operator has the initial state as ground state. We therefore chose the Hamiltonian"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:586
msgid ":nbsphinx-math:`\\begin{align} H_{M,i}^{(ws)}= \\begin{pmatrix} 2c_i^*-1 & -2\\sqrt{c_i^*(1-c_i^*)} \\\\ -2\\sqrt{c_i^*(1-c_i^*)} & 1-2c_i^* \\end{pmatrix} \\end{align}`"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:594
msgid "as mixer operator for qubit :math:`i`. Once multiplied by :math:`-i\\beta` and exponentiated this mixer produces the following mixer circuit."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:634
msgid "The initial state and mixer operator can then be passed to QAOA."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:703
msgid "Analysis"
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:705
msgid "Both results appear to give the same result. However, when we look at the underlying probability distribution we observe that the warm-start QAOA has a much higher probability of sampling the optimal solution."
msgstr ""

#: ../../tutorials/10_warm_start_qaoa.ipynb:817
msgid "The warm-start features above are available in the Qiskit optimization module as a single optimizer named ``WarmStartQAOAOptimizer`` which is illustrated below. This solver will solve a QUBO with a warm-start QAOA. It computes :math:`c^*` by relaxing the problem. This behavior is controlled by setting ``relax_for_pre_solver`` to ``True``."
msgstr ""

#: ../../tutorials/index.rst:3
msgid "Optimization Tutorials"
msgstr ""


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-28 08:39+0000\n"
"PO-Revision-Date: 2023-03-28 10:57\n"
"Last-Translator: \n"
"Language: es_UN\n"
"Language-Team: Spanish (United)\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: es-un\n"
"X-Crowdin-File: /master/machine-learning/docs/locale/en/LC_MESSAGES/tutorials/12_quantum_autoencoder.po\n"
"X-Crowdin-File-ID: 9929\n"

#: ../../tutorials/12_quantum_autoencoder.ipynb:9
msgid "This page was generated from `docs/tutorials/12_quantum_autoencoder.ipynb`__."
msgstr "Esta página fue generada a partir de `docs/tutorials/12_quantum_autoencoder.ipynb`__."

#: ../../tutorials/12_quantum_autoencoder.ipynb:22
#: ../../tutorials/12_quantum_autoencoder.ipynb:52
msgid "The Quantum Autoencoder"
msgstr "El Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:33
msgid "The goal of this tutorial is to build an Quantum Autoencoder, a circuit which can compress a quantum state onto a smaller amount of qubits, while retaining the information from the initial state."
msgstr "El objetivo de este tutorial es construir un Autocodificador Cuántico, un circuito que puede comprimir un estado cuántico en una cantidad más pequeña de qubits, mientras retiene la información del estado inicial."

#: ../../tutorials/12_quantum_autoencoder.ipynb:35
msgid "Throughout this tutorial, we explain the architecture of a Quantum Autoencoder and how one can design and train such a system to compress and encode information. Following this discussion, we give two examples to demonstrate the capabilities of such a system to compress different quantum states, as well as the ability to compress images of zeros and ones."
msgstr "A lo largo de este tutorial, explicamos la arquitectura de un Autocodificador Cuántico y cómo se puede diseñar y entrenar dicho sistema para comprimir y codificar información. Después de esta discusión, damos dos ejemplos para demostrar las capacidades de dicho sistema para comprimir diferentes estados cuánticos, así como la capacidad de comprimir imágenes de ceros y unos."

#: ../../tutorials/12_quantum_autoencoder.ipynb:47
msgid "Contents"
msgstr "Contenido"

#: ../../tutorials/12_quantum_autoencoder.ipynb:49
msgid "The following tutorial is broken down as follows:"
msgstr "El siguiente tutorial se desglosa de la siguiente manera:"

#: ../../tutorials/12_quantum_autoencoder.ipynb:51
msgid "What is an Autoencoder?"
msgstr "¿Qué es un Autocodificador?"

#: ../../tutorials/12_quantum_autoencoder.ipynb:53
msgid "Components of a Quantum Autoencoder"
msgstr "Componentes de un Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:54
msgid "Choosing a Loss Function"
msgstr "Elegir una Función de Pérdida"

#: ../../tutorials/12_quantum_autoencoder.ipynb:55
msgid "Building our Autoencoder"
msgstr "Construir nuestro Autocodificador"

#: ../../tutorials/12_quantum_autoencoder.ipynb:56
msgid "A Simple Example: The Domain Wall"
msgstr "Un Ejemplo Simple: La Pared de Dominio"

#: ../../tutorials/12_quantum_autoencoder.ipynb:57
msgid "A Quantum Autoencoder for Noisy Images of Digits"
msgstr "Un Autocodificador Cuántico para Imágenes Ruidosas de Dígitos"

#: ../../tutorials/12_quantum_autoencoder.ipynb:58
msgid "Applications of a Quantum Autoencoder"
msgstr "Aplicaciones de un Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:59
msgid "References"
msgstr "Referencias"

#: ../../tutorials/12_quantum_autoencoder.ipynb:71
msgid "1. What is an Autoencoder?"
msgstr "1. ¿Qué es un Autocodificador?"

#: ../../tutorials/12_quantum_autoencoder.ipynb:82
msgid "A classical autoencoder (CAE) is a type of neural network architecture that is commonly used to efficiently compress and encode information from the input using of representation learning. Following compression, one can then uncompress the data through the use of a decoder."
msgstr "Un autocodificador clásico (classical autoencoder, CAE) es un tipo de arquitectura de red neuronal que se usa comúnmente para comprimir y codificar de manera eficiente la información de la entrada mediante el aprendizaje de representación. Después de la compresión, se pueden descomprimir los datos mediante el uso de un decodificador."

#: ../../tutorials/12_quantum_autoencoder.ipynb:84
msgid "Typical autoencoders are commonly divided into three layers, as seen in Figure 1."
msgstr "Los autocodificadores típicos se dividen comúnmente en tres capas, como se ve en la Figura 1."

#: ../../tutorials/12_quantum_autoencoder.ipynb:95
msgid "|qae_fig1_wide.png| Figure 1: Example of a Classical Autoencoder which includes the input, bottleneck and output layer."
msgstr "|qae_fig1_wide.png| Figura 1: Ejemplo de un Autocodificador Clásico que incluye la capa de entrada, cuello de botella y salida."

#: ../../tutorials/12_quantum_autoencoder.ipynb:97
msgid "qae_fig1_wide.png"
msgstr "qae_fig1_wide.png"

#: ../../tutorials/12_quantum_autoencoder.ipynb:108
msgid "The first layer is called the Input Layer (1) and is the layer of which we input our data of length :math:`n`."
msgstr "La primera capa se llama Capa de Entrada (1) y es la capa en la que ingresamos nuestros datos de longitud :math:`n`."

#: ../../tutorials/12_quantum_autoencoder.ipynb:110
msgid "The input data then passes through an encoder and travels to the next layer, which has less nodes or is reduced in dimensions and is known as the Bottleneck Layer (2). The input layer is compressed through this process. Common CAEs may have several layers."
msgstr "Luego, los datos de entrada pasan a través de un codificador y viajan a la siguiente capa, que tiene menos nodos o tiene dimensiones reducidas y se conoce como la capa de Cuello de Botella (2). La capa de entrada se comprime a través de este proceso. Los CAE comunes pueden tener varias capas."

#: ../../tutorials/12_quantum_autoencoder.ipynb:112
msgid "The final layer is called the Output Layer (3). Here the compressed data is reconstructed to its original size, :math:`n`, from the compressed data through the process of a decoder."
msgstr "La capa final se llama Capa de Salida (3). Aquí, los datos comprimidos se reconstruyen a su tamaño original, :math:`n`, a partir de los datos comprimidos mediante el proceso de un decodificador."

#: ../../tutorials/12_quantum_autoencoder.ipynb:114
msgid "By passing our input data through a CAE, we are therefore able to reduce the dimensionality of our input data, as seen in the bottleneck layer, while retaining as much information as possible from the input data. Because of this feature, common uses of CAE are Image Denoising, Anomaly Detection and Facial Recognition devices. For more information on classical autoencoders, see [1]."
msgstr "Al pasar nuestros datos de entrada a través de un CAE, podemos reducir la dimensionalidad de nuestros datos de entrada, como se ve en la capa de cuello de botella, mientras retenemos la mayor cantidad de información posible de los datos de entrada. Debido a esta característica, los usos comunes del CAE son dispositivos de eliminación de ruido de imagen, detección de anomalías y reconocimiento facial. Para obtener más información sobre los autocodificadores clásicos, consulta [1]."

#: ../../tutorials/12_quantum_autoencoder.ipynb:126
msgid "2. The Quantum Autoencoder"
msgstr "2. El Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:137
msgid "We can also define a quantum counterpart to the CAE, the Quantum Autoencoder. Much like the CAE, the Quantum Autoencoder aims to reduce the dimensionality of the input of the neural network, in this case a quantum state. A pictorial representation of this can be seen in Figure 2."
msgstr "También podemos definir una contraparte cuántica del CAE, el Autocodificador Cuántico (Quantum Autoencoder). Al igual que el CAE, el Autocodificador Cuántico tiene como objetivo reducir la dimensionalidad de la entrada de la red neuronal, en este caso un estado cuántico. Una representación pictórica de esto se puede ver en la Figura 2."

#: ../../tutorials/12_quantum_autoencoder.ipynb:148
msgid "|qae_fig2_wide.png| Figure 2: Pictorial Representation of a Quantum Autoencoder. Here one can see the similarities with the CAE, with the circuit having an input state, bottleneck state and an output state."
msgstr "|qae_fig2_wide.png| Figura 2: Representación pictórica de un Autocodificador Cuántico. Aquí se pueden ver las similitudes con el CAE, teniendo el circuito un estado de entrada, un estado de cuello de botella y un estado de salida."

#: ../../tutorials/12_quantum_autoencoder.ipynb:150
msgid "qae_fig2_wide.png"
msgstr "qae_fig2_wide.png"

#: ../../tutorials/12_quantum_autoencoder.ipynb:161
msgid "Much like its classical counterpart, our circuit contains three layers. We first input our state :math:`|\\psi>` (which contains :math:`n` qubits), of which we wish to compress. This is our input layer (1)."
msgstr "Al igual que su contraparte clásica, nuestro circuito contiene tres capas. Primero ingresamos nuestro estado :math:`|\\psi>` (que contiene :math:`n` qubits), el cual deseamos comprimir. Esta es nuestra capa de entrada (1)."

#: ../../tutorials/12_quantum_autoencoder.ipynb:163
msgid "We then apply our parametrized circuit on our input state, which will act as our encoder and 'compresses' our quantum state, reducing the dimensionality of our state to :math:`n-k` qubits. Our new compressed state is of the form :math:`|\\psi_{comp}> \\otimes |0>^{\\otimes k}`, where :math:`|\\psi_{comp}>` contains :math:`n-k` qubits."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:165
msgid "This parametrized circuit will depend on a set of parameters, which will be the nodes of our Quantum Autoencoder. Throughout the training process, these parameters will be updated to optimize the loss function."
msgstr "Este circuito parametrizado dependerá de un conjunto de parámetros, que serán los nodos de nuestro Autocodificador Cuántico. A lo largo del proceso de entrenamiento, estos parámetros se actualizarán para optimizar la función de pérdida."

#: ../../tutorials/12_quantum_autoencoder.ipynb:167
msgid "We disregard the remaining :math:`k` qubits for the remainder of the circuit. This is our bottleneck layer (2) and our input state is now compressed."
msgstr "Ignoramos los :math:`k` qubits restantes para el resto del circuito. Esta es nuestra capa de cuello de botella (2) y nuestro estado de entrada ahora está comprimido."

#: ../../tutorials/12_quantum_autoencoder.ipynb:169
msgid "The final layer consists of the addition of :math:`k` qubits (all in the state :math:`|0\\rangle`) and applying another parametrized circuit between the compressed state and the new qubits. This parametrized circuit acts as our decoder and reconstructs the input state from the compressed state using the new qubits. After the decoder, we retain the original state as the state travels to the output layer (3)."
msgstr "La capa final consiste en la adición de :math:`k` qubits (todos en el estado :math:`|0\\rangle`) y aplicar otro circuito parametrizado entre el estado comprimido y los nuevos qubits. Este circuito parametrizado actúa como nuestro decodificador y reconstruye el estado de entrada a partir del estado comprimido usando los nuevos qubits. Después del decodificador, retenemos el estado original a medida que el estado viaja a la capa de salida (3)."

#: ../../tutorials/12_quantum_autoencoder.ipynb:181
msgid "3. Components of a Quantum Autoencoder"
msgstr "3. Componentes de un Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:192
msgid "Before building our Quantum Autoencoder, we must note a few subtleties."
msgstr "Antes de construir nuestro Autocodificador Cuántico, debemos tener en cuenta algunas sutilezas."

#: ../../tutorials/12_quantum_autoencoder.ipynb:194
msgid "We first note that we cannot introduce or disregard qubits in the middle of a Quantum Circuit when implementing an autoencoder using Qiskit."
msgstr "Primero notamos que no podemos introducir o descartar qubits en medio de un circuito cuántico cuando implementamos un autocodificador usando Qiskit."

#: ../../tutorials/12_quantum_autoencoder.ipynb:196
msgid "Because of this we must include our reference state as well as our auxiliary qubits (whose role will be described in later sections) at the beginning of the circuit."
msgstr "Por eso, debemos incluir nuestro estado de referencia, así como nuestros qubits auxiliares (cuya función se describirá en secciones posteriores) al comienzo del circuito."

#: ../../tutorials/12_quantum_autoencoder.ipynb:198
msgid "Therefore our input state will consist of our input state, reference state and one auxiliary qubit, as well as a classical register to perform measurements (which will be described in the next section). A pictorial representation of this can be seen in Figure 3."
msgstr "Por lo tanto, nuestra capa de entrada consistirá en nuestro estado de entrada, el estado de referencia y un qubit auxiliar, así como un registro clásico para realizar mediciones (que se describirá en la siguiente sección). Una representación pictórica de esto se puede ver en la Figura 3."

#: ../../tutorials/12_quantum_autoencoder.ipynb:209
msgid "|qae_fig3_wide.png| Figure 3: Pictorial Representation of input state of Quantum Autoencoder. Note that we must also include an auxiliary qubit, the reference state and classical register at the beginning of the circuit, even though they are not used until later in the circuit."
msgstr "|qae_fig3_wide.png| Figura 3: Representación pictórica del estado de entrada de un Autocodificador Cuántico. Ten en cuenta que también debemos incluir un qubit auxiliar, el estado de referencia y el registro clásico al comienzo del circuito, aunque no se usan hasta más adelante en el circuito."

#: ../../tutorials/12_quantum_autoencoder.ipynb:211
msgid "qae_fig3_wide.png"
msgstr "qae_fig3_wide.png"

#: ../../tutorials/12_quantum_autoencoder.ipynb:223
msgid "4. Choosing a Loss Function"
msgstr "4. Elegir una Función de Pérdida"

#: ../../tutorials/12_quantum_autoencoder.ipynb:234
msgid "We now define our cost function, which we will use to train our Quantum Autoencoder, to return the input state. There's a bit of math involved here, so skip this section if you're not interested!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:236
msgid "We take the cost function as defined in [2], which tries to maximize the fidelity between the input and output state of our Quantum Autoencoder."
msgstr "Tomamos la función de costo como se define en [2], que trata de maximizar la fidelidad entre el estado de entrada y salida de nuestro Autocodificador Cuántico."

#: ../../tutorials/12_quantum_autoencoder.ipynb:238
msgid "We first define subsystems :math:`A` and :math:`B` to contain :math:`n` and :math:`k` qubits respectively, while :math:`B'` is the space which will contain our reference space. We call the subsystem :math:`A` our latent space, which will contain the compressed qubit state, and :math:`B` our trash space, which contain the qubits of which we disregard throughout compression."
msgstr "Primero definimos los subsistemas :math:`A` y :math:`B` para contener :math:`n` y :math:`k` qubits respectivamente, mientras que :math:`B'` es el espacio que contendrá nuestro espacio de referencia. Llamamos al subsistema :math:`A` nuestro espacio latente, que contendrá el estado de qubit comprimido, y :math:`B` nuestro espacio basura, que contiene los qubits que ignoramos durante la compresión."

#: ../../tutorials/12_quantum_autoencoder.ipynb:240
msgid "Our input state therefore :math:`|\\psi_{AB}>` contains :math:`n + k` qubits. We define the reference space :math:`B'` which contains the reference state :math:`|a>_{B'}`. This space will contain the additional :math:`k` qubits we use in the decoder. All of these subsystems can be seen in Figure 3."
msgstr "Por lo tanto, nuestro estado de entrada :math:`|\\psi_{AB}>` contiene :math:`n + k` qubits. Definimos el espacio de referencia :math:`B'` que contiene el estado de referencia :math:`|a>_{B'}`. Este espacio contendrá los :math:`k` qubits adicionales que usamos en el decodificador. Todos estos subsistemas se pueden ver en la Figura 3."

#: ../../tutorials/12_quantum_autoencoder.ipynb:242
msgid "We define the parameterized circuit as :math:`U(\\theta)` which we will use as our encoder. However the structure and parameters of our parametrized circuit is currently unknown to us and may vary for different input states. To determine the parameters to compress our input state, we must train our device to maximally compress the state by adjusting the values of the parameters :math:`\\theta`. For the decoder we will use :math:`U^{\\dagger}(\\theta)`."
msgstr "Definimos el circuito parametrizado como :math:`U(\\theta)` que usaremos como nuestro codificador. Sin embargo, la estructura y los parámetros de nuestro circuito parametrizado son actualmente desconocidos para nosotros y pueden variar para diferentes estados de entrada. Para determinar los parámetros para comprimir nuestro estado de entrada, debemos entrenar nuestro dispositivo para comprimir al máximo el estado ajustando los valores de los parámetros :math:`\\theta`. Para el decodificador usaremos :math:`U^{\\dagger}(\\theta)`."

#: ../../tutorials/12_quantum_autoencoder.ipynb:244
msgid "Our goal therefore is to maximize the fidelity between the input and output states, i.e."
msgstr "Por lo tanto, nuestro objetivo es maximizar la fidelidad entre los estados de entrada y salida, es decir,"

#: ../../tutorials/12_quantum_autoencoder.ipynb:246
msgid "\\text{max }F(\\psi_{AB}, \\rho_{out})\n\n"
msgstr "\\text{max }F(\\psi_{AB}, \\rho_{out})\n\n"

#: ../../tutorials/12_quantum_autoencoder.ipynb:248
msgid "where"
msgstr "donde"

#: ../../tutorials/12_quantum_autoencoder.ipynb:250
msgid "\\rho_{out} = U^{\\dagger}(\\theta)_{AB'} \\text{Tr}_{B} [U(\\theta)_{AB}[\\psi_{AB} \\otimes a_{B'}]U^{\\dagger}(\\theta)_{AB}]U(\\theta)_{AB'}\n\n"
msgstr "\\rho_{out} = U^{\\dagger}(\\theta)_{AB'} \\text{Tr}_{B} [U(\\theta)_{AB}[\\psi_{AB} \\otimes a_{B'}]U^{\\dagger}(\\theta)_{AB}]U(\\theta)_{AB'}\n\n"

#: ../../tutorials/12_quantum_autoencoder.ipynb:252
msgid "We can maximize this fidelity by tuning the parameters :math:`\\theta` in our parametrized circuit. However, this fidelity can at times be complicated to determine and may require a large amount of gates needed to calculate the fidelity between two states, i.e. the larger the number of qubits, the more gates required which results to deeper circuits. Therefore we look for alternative means of comparing the input and output states."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:254
msgid "As shown in [2] a simpler way of determining an optimally compressed state is to perform a swap gate between the trash state and reference state. These states usually have a smaller number of qubits and are therefore easier to compare, due to the smaller amount of gates required. As shown in [2] maximizing the fidelity of such these two states is equivalent to maximizing the fidelity of the input and output state and thus determining an optimal compression of our input circuit."
msgstr "Como se muestra en [2], una forma más sencilla de determinar un estado comprimido de manera óptima es realizar una compuerta de intercambio entre el estado basura y el estado de referencia. Estos estados suelen tener una menor cantidad de qubits y, por lo tanto, son más fáciles de comparar debido a la menor cantidad de compuertas requeridas. Como se muestra en [2], maximizar la fidelidad de estos dos estados es equivalente a maximizar la fidelidad del estado de entrada y salida y, en consecuencia, determinar una compresión óptima de nuestro circuito de entrada."

#: ../../tutorials/12_quantum_autoencoder.ipynb:256
msgid "Keeping our reference state fixed, our cost function will now be a function of the trash state and is denoted as;"
msgstr "Manteniendo fijo nuestro estado de referencia, nuestra función de costo ahora será una función del estado basura y se denota como;"

#: ../../tutorials/12_quantum_autoencoder.ipynb:258
msgid "\\text{max }F(\\text{Tr}_{A} [ U(\\theta)_{AB}\\psi_{AB} U^{\\dagger}(\\theta)_{AB}], a_{B'})\n\n"
msgstr "\\text{max }F(\\text{Tr}_{A} [ U(\\theta)_{AB}\\psi_{AB} U^{\\dagger}(\\theta)_{AB}], a_{B'})\n\n"

#: ../../tutorials/12_quantum_autoencoder.ipynb:260
msgid "Throughout the training process, we adjust the parameters :math:`\\theta` in our encoder and perform a swap test (as described below) to determine the fidelity between these trash and reference states. In doing so, we must include an additional qubit, our auxiliary qubit, which will be used throughout the swap test and measured to determine the overall fidelity of the trash and reference states. This is the reason why we included both an auxiliary qubit and classical register in the previous section when initializing our circuit."
msgstr "A lo largo del proceso de entrenamiento, ajustamos los parámetros :math:`\\theta` en nuestro codificador y realizamos una prueba swap o de intercambio (como se describe a continuación) para determinar la fidelidad entre estos estados basura y de referencia. Al hacerlo, debemos incluir un qubit adicional, nuestro qubit auxiliar, que se usará a lo largo de la prueba swap y se medirá para determinar la fidelidad general de los estados basura y de referencia. Esta es la razón por la que incluimos un qubit auxiliar y un registro clásico en la sección anterior al inicializar nuestro circuito."

#: ../../tutorials/12_quantum_autoencoder.ipynb:273
msgid "The SWAP Test"
msgstr "La Prueba SWAP"

#: ../../tutorials/12_quantum_autoencoder.ipynb:284
msgid "The SWAP Test is a procedure commonly used to compare two states by applying CNOT gates to each qubit (for further information see [3]). By running the circuit :math:`M` times, and applying the SWAP test, we then measure the auxiliary qubit. We use the number of states in the state :math:`|1\\rangle` to compute:"
msgstr "La Prueba SWAP (prueba de intercambio) es un procedimiento comúnmente utilizado para comparar dos estados mediante la aplicación de compuertas CNOT a cada qubit (para obtener más información, consulta [3]). Al ejecutar el circuito :math:`M` veces y aplicar la prueba SWAP, medimos el qubit auxiliar. Usamos el número de estados en el estado :math:`|1\\rangle` a calcular:"

#: ../../tutorials/12_quantum_autoencoder.ipynb:286
msgid "S = 1 - \\frac{2}{M}L\n\n"
msgstr "S = 1 - \\frac{2}{M}L\n\n"

#: ../../tutorials/12_quantum_autoencoder.ipynb:288
msgid "where :math:`L` is the count for the states in the :math:`|1\\rangle` state. As shown in [3], maximizing this function corresponds to the two states of which we are comparing being identical. We therefore aim to maximize this function, i.e. minimize :math:`\\frac{2}{M}L`. This value will be therefore be our cost function."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:300
msgid "5. Building the Quantum Autoencoder Ansatz"
msgstr "5. Construir el Ansatz del Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:311
msgid "First, we implement IBM's Qiskit to build our Quantum Autoencoder. We first begin by importing in the necessary libraries and fixing the seed."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:349
msgid "We begin by defining our parametrized ansatz for the Quantum Autoencoder. This will be our parametrized circuit where we can tune the parameters to maximize the fidelity between the trash and reference states."
msgstr "Comenzamos definiendo nuestro ansatz parametrizado para el Autocodificador Cuántico. Este será nuestro circuito parametrizado donde podemos ajustar los parámetros para maximizar la fidelidad entre los estados basura y de referencia."

#: ../../tutorials/12_quantum_autoencoder.ipynb:352
msgid "The Parametrized Circuit"
msgstr "El Circuito Parametrizado"

#: ../../tutorials/12_quantum_autoencoder.ipynb:354
msgid "The parametrized circuit we will use below for our encoder is the RealAmplitude Ansatz available in Qiskit. One of the reasons why we have chosen this ansatz is because it is a 2-local circuit, the prepared quantum states will only have real amplitudes, and does not rely on full connectivity between each qubits, which is hard to implement or can lead to deep circuits."
msgstr "El circuito parametrizado que usaremos a continuación para nuestro codificador es el Ansatz RealAmplitude disponible en Qiskit. Una de las razones por las que hemos elegido este ansatz es porque es un circuito 2-local, los estados cuánticos preparados solo tendrán amplitudes reales y no dependen de la conectividad completa entre cada qubit, lo cual es difícil de implementar o puede conducir a circuitos profundos."

#: ../../tutorials/12_quantum_autoencoder.ipynb:356
msgid "We define our parametrized circuit for our Encoder below, where we set the repetition parameter to ``reps=5``, to increase the number of parameters in our circuit allowing greater flexibility."
msgstr "Definimos nuestro circuito parametrizado para nuestro codificador a continuación, donde configuramos el parámetro de repetición en ``reps=5``, para aumentar la cantidad de parámetros en nuestro circuito y permitir una mayor flexibilidad."

#: ../../tutorials/12_quantum_autoencoder.ipynb:378
msgid "Let's draw this ansatz with :math:`5` qubits and see what it looks like."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:410
msgid "We now apply this Encoder to the state we wish to compress. In this example, we divide our initial :math:`5` qubit state into a :math:`3` qubit latent state (:math:`n = 3`) and :math:`2` qubit trash space (:math:`k = 2`)."
msgstr "Ahora aplicamos este Codificador al estado que deseamos comprimir. En este ejemplo, dividimos nuestro estado inicial de :math:`5` qubits en un estado latente de :math:`3` qubits (:math:`n = 3`) y un espacio basura de :math:`2` qubits (:math:`k = 2`)."

#: ../../tutorials/12_quantum_autoencoder.ipynb:412
msgid "As explained in the previous section, we must also include a :math:`2` qubit reference space in our circuit, as well as an auxiliary qubit to perform the swap test between the reference and trash states. We will therefore have a total of :math:`2 + 3 + 2 + 1 = 8` qubits and :math:`1` classical register in our circuit."
msgstr "Como se explicó en la sección anterior, también debemos incluir un espacio de referencia de :math:`2` qubits en nuestro circuito, así como un qubit auxiliar para realizar la prueba swap entre los estados de referencia y basura. Por lo tanto, tendremos un total de :math:`2 + 3 + 2 + 1 = 8` qubits y :math:`1` registro clásico en nuestro circuito."

#: ../../tutorials/12_quantum_autoencoder.ipynb:414
msgid "After initializing our state, we apply our parametrized circuit."
msgstr "Después de inicializar nuestro estado, aplicamos nuestro circuito parametrizado."

#: ../../tutorials/12_quantum_autoencoder.ipynb:416
msgid "Following this, we then split our initial state into the latent space (the compressed state) and trash space (the part of the state we will disregard) and perform the swap test between the reference state and the trash space. The last qubit is then measured to determine the fidelity between the reference and trash states. A pictorial representation of this is given below in Figure 4."
msgstr "Después de esto, dividimos nuestro estado inicial en el espacio latente (el estado comprimido) y el espacio basura (la parte del estado que descartaremos) y realizamos la prueba swap entre el estado de referencia y el espacio basura. Luego se mide el último qubit para determinar la fidelidad entre los estados de referencia y basura. Una representación pictórica de esto se da a continuación en la Figura 4."

#: ../../tutorials/12_quantum_autoencoder.ipynb:427
msgid "|qae_fig4_wide.png|"
msgstr "|qae_fig4_wide.png|"

#: ../../tutorials/12_quantum_autoencoder.ipynb:429
msgid "qae_fig4_wide.png"
msgstr "qae_fig4_wide.png"

#: ../../tutorials/12_quantum_autoencoder.ipynb:440
msgid "Figure 4: Example of a Quantum Autoencoder in the training process. We use the swap test to determine the fidelity between the trash and reference space."
msgstr "Figura 4: Ejemplo de un Autocodificador Cuántico en proceso de entrenamiento. Usamos la prueba swap para determinar la fidelidad entre los espacios basura y de referencia."

#: ../../tutorials/12_quantum_autoencoder.ipynb:451
msgid "We define a function below to implement the above circuit configuration to the :math:`5` qubit domain wall state :math:`|00111\\rangle` and plot an example below. Here qubits :math:`5` and :math:`6` are the reference state, :math:`0, 1, 2, 3, 4` are the initial state we wish to compress and qubit :math:`7` is our auxiliary qubit which is used in the swap test. We also include a classical register to measure the results of qubit :math:`7` in the swap test."
msgstr "Definimos una función a continuación para implementar la configuración del circuito anterior en el estado de pared de dominio :math:`|00111\\rangle` de :math:`5` qubits y graficar un ejemplo a continuación. Aquí los qubits :math:`5` y :math:`6` son el estado de referencia, :math:`0, 1, 2, 3, 4` son el estado inicial que deseamos comprimir y el qubit :math:`7` es nuestro qubit auxiliar que se usa en la prueba swap. También incluimos un registro clásico para medir los resultados del qubit :math:`7` en la prueba swap."

#: ../../tutorials/12_quantum_autoencoder.ipynb:501
msgid "In order to reconstruct the original input state, we must apply the adjoint of our parametrized circuit after the swap test. However, during training, we are only interested in the trash state and the reference state. We can therefore exclude the gates following compression until we wish to reconstruct our initial input."
msgstr "Para reconstruir el estado de entrada original, debemos aplicar el adjunto de nuestro circuito parametrizado después de la prueba swap. Sin embargo, durante el entrenamiento, solo nos interesa el estado basura y el estado de referencia. Por lo tanto, podemos excluir las compuertas que siguen a la compresión hasta que deseemos reconstruir nuestra entrada inicial."

#: ../../tutorials/12_quantum_autoencoder.ipynb:503
msgid "After building our Quantum Autoencoder, the next step is to train our Quantum Autoencoder to compress the state and maximize the cost function and determine the parameters :math:`\\theta`."
msgstr "Después de construir nuestro Autocodificador Cuántico, el siguiente paso es entrenarlo para comprimir el estado y maximizar la función de costo y determinar los parámetros :math:`\\theta`."

#: ../../tutorials/12_quantum_autoencoder.ipynb:515
msgid "6. A Simple Example: The Domain Wall Autoencoder"
msgstr "6. Un Ejemplo Simple: El Autocodificador de la Pared de Dominio"

#: ../../tutorials/12_quantum_autoencoder.ipynb:526
msgid "Let's first begin with a simple example, a state known as the Domain Wall, which for :math:`5` qubits is given by :math:`|00111\\rangle`. Here we will try and compress this state from :math:`5` qubits to :math:`3` qubits, with the remaining qubits in the trash space, in the state :math:`|00\\rangle`. We can create a function to build the domain wall state below."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:564
msgid "Now let's train our Autoencoder to compress this state from 5 qubits to 3 qubits (qubits 0,1 and 2), with the remaining qubits in the trash space (qubits 3 and 4) being in the \\|00> state."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:575
msgid "We create a circuit to be used in the loss function, as described in Section 4, which determines the fidelity between the two states below using the swap test for our particular AutoEncoder function. For further information on the swap test, see [1]."
msgstr "Creamos un circuito para usar en la función de pérdida, como se describe en la Sección 4, que determina la fidelidad entre los dos estados a continuación usando la prueba swap para nuestra función particular de Autocodificador. Para obtener más información sobre la prueba swap, consulta [1]."

#: ../../tutorials/12_quantum_autoencoder.ipynb:609
msgid "Then, we create a quantum neural network and pass the circuit as a parameter. We note that this network must take an interpret function, which determines how we map the output of the network to the output shape. Since we measure only one qubit, the output of the network is a bit string either :math:`0` or :math:`1`, so the output shape is :math:`2`, the number of possible outcomes. Then, we introduce an identity mapping. The output of the network is a vector of probabilities of getting interpret-mapped bit strings. Thus, we get probabilities of getting :math:`0` or :math:`1` and this is exactly what we are looking for. In the cost function we make use of the probability of getting :math:`1` and penalize the outcomes that lead to :math:`1`, therefore maximizing the fidelity between the trash space and the reference space."
msgstr "Luego, creamos una red neuronal cuántica y pasamos el circuito como parámetro. Notamos que esta red debe tomar una función de interpretación, que determina cómo mapeamos la salida de la red a la forma de salida. Dado que medimos solo un qubit, la salida de la red es una cadena de bits, ya sea :math:`0` o :math:`1`, por lo que la forma de salida es :math:`2`, el número de resultados posibles. Luego, introducimos un mapeo de identidad. La salida de la red es un vector de probabilidades de obtener cadenas de bits interpretadas. Por lo tanto, obtenemos las probabilidades de obtener :math:`0` o :math:`1` y esto es exactamente lo que estamos buscando. En la función de costo hacemos uso de la probabilidad de obtener :math:`1` y penalizamos los resultados que llevan a :math:`1`, maximizando así la fidelidad entre el espacio basura y el espacio de referencia."

#: ../../tutorials/12_quantum_autoencoder.ipynb:642
msgid "Next we create our cost function. As described in the previous section, our aim is to minimize :math:`\\frac{2}{M}L`, which is the twice the probability of getting the final qubit in the :math:`|1\\rangle` state. We therefore wish to minimize the of getting a :math:`|1\\rangle` on qubit 7."
msgstr "A continuación, creamos nuestra función de costo. Como se describe en la sección anterior, nuestro objetivo es minimizar :math:`\\frac{2}{M}L`, que es el doble de probabilidad de obtener el qubit final en el estado :math:`|1\\rangle`. Por lo tanto, deseamos minimizar la posibilidad de obtener un :math:`|1\\rangle` en el qubit 7."

#: ../../tutorials/12_quantum_autoencoder.ipynb:644
msgid "The cost function will also plot out the objective value at each cost function evaluation."
msgstr "La función de costo también graficará el valor objetivo en cada evaluación de la función de costo."

#: ../../tutorials/12_quantum_autoencoder.ipynb:678
msgid "Now we will train our Autoencoder to reduce the dimension of the Hilbert space from :math:`5` qubits to :math:`3`, while leaving the trash space in the state :math:`|00\\rangle`. We initially set the parameters :math:`\\theta` to random values and tune these parameters to minimize our cost function through the use of the COBYLA optimizer."
msgstr "Ahora entrenaremos nuestro Autocodificador para reducir la dimensión del espacio de Hilbert de :math:`5` qubits a :math:`3`, dejando el espacio basura en el estado :math:`|00\\rangle`. Inicialmente, establecemos los parámetros :math:`\\theta` en valores aleatorios y ajustamos estos parámetros para minimizar nuestra función de costo mediante el uso del optimizador COBYLA."

#: ../../tutorials/12_quantum_autoencoder.ipynb:743
msgid "Looks like it has converged! After training our Quantum Autoencoder, let's build it and see how well it compresses the state!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:745
msgid "To do this, we first apply our Autoencoder to a :math:`5` qubit Domain Wall state. After applying this state, the compressed state should be of the form :math:`|00\\rangle`. Therefore resetting the last two qubits should not effect our over all state."
msgstr "Para hacer esto, primero aplicamos nuestro autocodificador a un estado de pared de dominio de :math:`5` qubits. Después de aplicar este estado, el estado comprimido debe tener la forma :math:`|00\\rangle`. Por lo tanto, restablecer los dos últimos qubits no debería afectar a nuestro estado general."

#: ../../tutorials/12_quantum_autoencoder.ipynb:747
msgid "After resetting we apply our decoder (the hermitian conjugate of our encoder) and compare it to the initial state by determining the fidelity. If our fidelity is one, then our Autoencoder has encoded all the information of the domain wall efficiently into a smaller set of qubits and when decoding, we retain the original state!"
msgstr "Después de restablecer, aplicamos nuestro decodificador (el conjugado hermitiano de nuestro codificador) y lo comparamos con el estado inicial determinando la fidelidad. Si nuestra fidelidad es uno, entonces nuestro Autocodificador ha codificado toda la información de la pared de dominio de manera eficiente en un conjunto más pequeño de qubits y al decodificar, ¡retenemos el estado original!"

#: ../../tutorials/12_quantum_autoencoder.ipynb:758
msgid "Let's first apply our circuit to the Domain Wall State, using the parameters we obtained when training our Quantum Autoencoder. (Note we have included barriers in our circuit below, however these are not necessary for the implementation of the Quantum Autoencoder and are used to determine between different sections of our circuit)."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:798
msgid "Now we assign the parameter values obtained in the training."
msgstr "Ahora asignamos los valores de los parámetros obtenidos en el entrenamiento."

#: ../../tutorials/12_quantum_autoencoder.ipynb:819
msgid "Now let's get the statevectors of our Domain Wall state and output circuit and calculate the fidelity!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:868
msgid "As you can see our fidelity is quite high and our Autoencoder has thus compressed our dataset while retaining all the information from the input state!"
msgstr "Como puedes ver, nuestra fidelidad es bastante alta y, por lo tanto, nuestro autocodificador ha comprimido nuestro conjunto de datos mientras ¡retiene toda la información del estado de entrada!"

#: ../../tutorials/12_quantum_autoencoder.ipynb:870
msgid "Now we will see if we can apply such a Quantum Autoencoder to more complicated datasets containing noise, such as images of the numbers zero and one."
msgstr "Ahora veremos si podemos aplicar dicho Autocodificador Cuántico a conjuntos de datos más complicados que contienen ruido, como imágenes de los números cero y uno."

#: ../../tutorials/12_quantum_autoencoder.ipynb:882
msgid "7. A Quantum Autoencoder for Digital Compression"
msgstr "7. Un Autocodificador Cuántico para Compresión Digital"

#: ../../tutorials/12_quantum_autoencoder.ipynb:893
msgid "One can also apply a Quantum Autoencoder to more complicated examples, such as a set of handwritten digits in order to compress the dataset. Below, we will show that we can indeed train an Quantum Autoencoder to compress such an example, giving us the ability to store data more efficiently on a Quantum Computer."
msgstr "También se puede aplicar un Autocodificador Cuántico a ejemplos más complicados, como un conjunto de dígitos escritos a mano para comprimir el conjunto de datos. A continuación, mostraremos que, de hecho, podemos entrenar un Autocodificador Cuántico para comprimir un ejemplo de este tipo, lo que nos brinda la capacidad de almacenar datos de manera más eficiente en una computadora cuántica."

#: ../../tutorials/12_quantum_autoencoder.ipynb:895
msgid "For this tutorial, we will build a Quantum Autoencoder for a noisy dataset containing zeros and ones, which can be seen below."
msgstr "Para este tutorial, crearemos un Autocodificador Cuántico para un conjunto de datos ruidoso que contiene ceros y unos, que se puede ver a continuación."

#: ../../tutorials/12_quantum_autoencoder.ipynb:897
msgid "Each image contains :math:`32` pixels of which can be encoded into :math:`5` qubits by Amplitude Encoding. This can be done using Qiskit's ``RawFeatureVector`` feature map."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1002
msgid "After encoding our image into :math:`5` qubits, we begin to train our Quantum Autoencoder to compress this state into :math:`3` qubits."
msgstr "Después de codificar nuestra imagen en :math:`5` qubits, comenzamos a entrenar nuestro Autocodificador Cuántico para comprimir este estado en :math:`3` qubits."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1004
msgid "We repeat the steps in the previous example and write a cost function, again based on the Swap Test between the trash and latent space. We can also use the same Autoencoder function as given in the previous example, as the input state and trash space contain the same amount of qubits."
msgstr "Repetimos los pasos del ejemplo anterior y escribimos una función de costo, nuevamente basada en la Prueba Swap entre los espacios basura y latente. También podemos usar la misma función de Autocodificador que se proporciona en el ejemplo anterior, ya que el estado de entrada y el espacio basura contienen la misma cantidad de qubits."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1006
msgid "Let's input one of our digits and see our circuit for the Autoencoder below."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1047
msgid "Again, we can see the swap test being performed on the qubits :math:`3`, :math:`4`, :math:`5` and :math:`6`, which will determine the value of our cost function."
msgstr "Nuevamente, podemos ver la prueba swap que se realiza en los qubits :math:`3`, :math:`4`, :math:`5` y :math:`6`, que determinarán el valor de nuestra función de costo."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1078
msgid "We build our cost function, based on the swap test between the reference and trash space for the digit dataset. To do this, we again use Qiskit's CircuitQNN network and use the same interpret function as we are measuring the probability of getting the final qubit in the :math:`|1\\rangle` state."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1112
msgid "Since model training may take a long time we have already pre-trained the model for some iterations and saved the pre-trained weights. We'll continue training from that point by setting ``initial_point`` to a vector of pre-trained weights."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1134
msgid "By minimizing this cost function, we can thus determine the required parameters to compress our noisy images. Let's see if we can encode our images!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1197
msgid "Looks like it has converged!"
msgstr "¡Parece que ha convergido!"

#: ../../tutorials/12_quantum_autoencoder.ipynb:1199
msgid "Now let's build our Encoder and Decoder using the parameters obtained from the training period. After applying this circuit to our new dataset, we can then compare our input and output data and see if we were able to retain the images efficiently throughout the compression!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1265
msgid "It looks like our Quantum Autoencoder can be trained to encode digits as well! Now it's your turn to build your own Quantum Autoencoder and come up with ideas and datasets to compress!"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1277
msgid "8. Applications of a Quantum Autoencoder"
msgstr "8. Aplicaciones de un Autocodificador Cuántico"

#: ../../tutorials/12_quantum_autoencoder.ipynb:1288
msgid "Quantum Autoencoder's can be used for various different applications, including"
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1290
msgid "Digital Compression: where information can be encoded into a smaller amount of qubits. This can be hugely beneficial for near term quantum devices, as smaller systems of qubits are less prone to noise."
msgstr "Compresión digital: donde la información se puede codificar en una cantidad menor de qubits. Esto puede ser muy beneficioso para los dispositivos cuánticos de término cercano, ya que los sistemas de qubits más pequeños son menos propensos al ruido."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1291
msgid "Denoising: where one can use Quantum Autoencoder to extract relevant features from the initial quantum state or encoded data, while neglecting any additional noise."
msgstr "Eliminación de ruido: donde se puede usar Autocodificación Cuántica para extraer características relevantes del estado cuántico inicial o datos codificados, mientras se ignora cualquier ruido adicional."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1292
msgid "Quantum Chemistry: in which a Quantum Autoencoder can be used as an ansatz for systems, such as the Hubbard Model. This is commonly used to describe electron-electron interactions in molecules."
msgstr "Química Cuántica: en la que se puede utilizar un Autocodificador Cuántico como ansatz para sistemas, como el Modelo Hubbard. Esto se usa comúnmente para describir las interacciones electrón-electrón en las moléculas."

#: ../../tutorials/12_quantum_autoencoder.ipynb:1304
msgid "9. References"
msgstr "9. Referencias"

#: ../../tutorials/12_quantum_autoencoder.ipynb:1315
msgid "A wikipedia page on Autoencoder: https://en.wikipedia.org/wiki/Autoencoder"
msgstr "Una página de wikipedia sobre el Autocodificador: https://en.wikipedia.org/wiki/Autoencoder"

#: ../../tutorials/12_quantum_autoencoder.ipynb:1317
msgid "Romero, Jonathan, Jonathan P. Olson, and Alan Aspuru-Guzik. \"Quantum autoencoders for efficient compression of quantum data.\" Quantum Science and Technology 2.4 (2017): 045001."
msgstr ""

#: ../../tutorials/12_quantum_autoencoder.ipynb:1319
msgid "Swap Test Algorithm: https://en.wikipedia.org/wiki/Swap_test"
msgstr "Algoritmo de la Prueba de Swap: https://en.wikipedia.org/wiki/Swap_test"


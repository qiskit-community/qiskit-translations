msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-12 22:17+0000\n"
"PO-Revision-Date: 2021-07-12 23:05\n"
"Last-Translator: \n"
"Language-Team: Turkish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: tr\n"
"X-Crowdin-File: /master/finance/docs/locale/en/LC_MESSAGES/tutorials.po\n"
"X-Crowdin-File-ID: 9618\n"
"Language: tr_TR\n"

#: ../../tutorials/01_portfolio_optimization.ipynb:13
#: ../../tutorials/02_portfolio_diversification.ipynb:13
#: ../../tutorials/03_european_call_option_pricing.ipynb:13
#: ../../tutorials/04_european_put_option_pricing.ipynb:13
#: ../../tutorials/05_bull_spread_pricing.ipynb:13
#: ../../tutorials/06_basket_option_pricing.ipynb:13
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:13
#: ../../tutorials/08_fixed_income_pricing.ipynb:13
#: ../../tutorials/09_credit_risk_analysis.ipynb:13
#: ../../tutorials/10_qgan_option_pricing.ipynb:13
#: ../../tutorials/11_time_series.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr "Jupyter not defterinde interaktif olarak çalıştırın."

#: ../../tutorials/01_portfolio_optimization.ipynb:9
msgid "Portfolio Optimization"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:21
#: ../../tutorials/02_portfolio_diversification.ipynb:12
#: ../../tutorials/03_european_call_option_pricing.ipynb:21
#: ../../tutorials/04_european_put_option_pricing.ipynb:21
#: ../../tutorials/05_bull_spread_pricing.ipynb:21
#: ../../tutorials/06_basket_option_pricing.ipynb:21
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:21
#: ../../tutorials/08_fixed_income_pricing.ipynb:21
#: ../../tutorials/09_credit_risk_analysis.ipynb:21
#: ../../tutorials/10_qgan_option_pricing.ipynb:12
#: ../../tutorials/11_time_series.ipynb:21
msgid "Introduction"
msgstr "Giriş"

#: ../../tutorials/01_portfolio_optimization.ipynb:23
msgid "This tutorial shows how to solve the following mean-variance portfolio optimization problem for :math:`n` assets:"
msgstr "Bu eğitici belge, :math:`n` varlıkları için aşağıdaki ortalama varyans portföy optimizasyon probleminin nasıl çözüleceğini gösterir:"

#: ../../tutorials/01_portfolio_optimization.ipynb:25
msgid "\\begin{aligned}\n"
"\\min_{x \\in \\{0, 1\\}^n}  q x^T \\Sigma x - \\mu^T x\\\\\n"
"\\text{subject to: } 1^T x = B\n"
"\\end{aligned}"
msgstr "\\begin{aligned}\n"
"\\min_{x \\in \\{0, 1\\}^n}  q x^T \\Sigma x - \\mu^T x\\\\\n"
"\\text{subject to: } 1^T x = B\n"
"\\end{aligned}"

#: ../../tutorials/01_portfolio_optimization.ipynb:32
msgid "where we use the following notation:"
msgstr "burada aşağıdaki gösterimi kullanırız:"

#: ../../tutorials/01_portfolio_optimization.ipynb:34
msgid ":math:`x \\in \\{0, 1\\}^n` denotes the vector of binary decision variables, which indicate which assets to pick (:math:`x[i] = 1`) and which not to pick (:math:`x[i] = 0`),"
msgstr ":math:`x \\in \\{0, 1\\}^n` ikili karar değişkenlerin vektörünü temsil eder, hangi varlıkların seçileceğini (:math:`x[i] = 1`) ve hangilerinin seçilmeyeceğini (:math:`x[i] = 0`) gösterir,"

#: ../../tutorials/01_portfolio_optimization.ipynb:35
msgid ":math:`\\mu \\in \\mathbb{R}^n` defines the expected returns for the assets,"
msgstr ":math:`\\mu \\in \\mathbb{R}^ n` varlıkları için beklenen geri dönüşü tanımlar,"

#: ../../tutorials/01_portfolio_optimization.ipynb:36
msgid ":math:`\\Sigma \\in \\mathbb{R}^{n \\times n}` specifies the covariances between the assets,"
msgstr ":math:`\\Sigma \\in \\mathbb{R}^{n \\times n}` varlıklar arasındaki kovaryansı belirler,"

#: ../../tutorials/01_portfolio_optimization.ipynb:37
msgid ":math:`q > 0` controls the risk appetite of the decision maker,"
msgstr ":math:`q > 0` karar vericinin risk isteğini kontrol eder,"

#: ../../tutorials/01_portfolio_optimization.ipynb:38
msgid "and :math:`B` denotes the budget, i.e. the number of assets to be selected out of :math:`n`."
msgstr "ve :math:`B`, bütçeyi, yani :math:`n` dışında seçilecek varlıkların sayısını belirtir."

#: ../../tutorials/01_portfolio_optimization.ipynb:40
msgid "We assume the following simplifications: - all assets have the same price (normalized to 1), - the full budget :math:`B` has to be spent, i.e. one has to select exactly :math:`B` assets."
msgstr "Şu sadeleştirmelerin geçerli olduğunu varsayarız: - tüm varlıklar aynı fiyata sahiptir (1’e normalize edilmiştir), - bütçenin tamamı :math:`B` harcanmalıdır, yani tam olarak :math:`B` varlık seçilmesi gerekir."

#: ../../tutorials/01_portfolio_optimization.ipynb:42
msgid "The equality constraint :math:`1^T x = B` is mapped to a penalty term :math:`(1^T x - B)^2` which is scaled by a parameter and subtracted from the objective function. The resulting problem can be mapped to a Hamiltonian whose ground state corresponds to the optimal solution. This notebook shows how to use the Variational Quantum Eigensolver (VQE) or the Quantum Approximate Optimization Algorithm (QAOA) to find the optimal solution for a given set of parameters."
msgstr "Eşitlik kısıtı :math:`1^T x = B`, bir parametre ile ölçeklenip amaç fonksiyonundan çıkartılan ceza terimi :math:`(1^T x-B)^2` ile eşlenir. Sonuçta ortaya çıkan problem, taban enerji seviyesi optimal çözüme denk gelen bir Hamiltonian ile eşlenebilir. Bu not defteri, verilen parametrelerle optimal çözümü bulmak için Variational Quantum Eigensolver (VQE)’ın ya da Kuantum Yaklaşık Optimizasyon Algoritması (QAOA)’ın nasıl kullanılacağını gösterir."

#: ../../tutorials/01_portfolio_optimization.ipynb:44
msgid "Experiments on real quantum hardware for this problem are reported for instance in the following paper: `Improving Variational Quantum Optimization using CVaR. Barkoutsos et al. 2019. <https://arxiv.org/abs/1907.04769>`__"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:78
msgid "[Optional] Setup token to run the experiment on a real device"
msgstr "[Optional] Denemeyi gerçek bir cihazda çalıştırmak için kurulum erişim-anahtarı"

#: ../../tutorials/01_portfolio_optimization.ipynb:80
msgid "If you would like to run the experiment on a real device, you need to setup your account first."
msgstr "Denemeyi gerçek bir cihazda çalıştırmak istiyorsanız, önce hesabınızı ayarlamanız gerekir."

#: ../../tutorials/01_portfolio_optimization.ipynb:82
msgid "Note: If you do not store your token yet, use ``IBMQ.save_account('MY_API_TOKEN')`` to store it first."
msgstr "Not: Erişim anahtarını henüz kaydetmediyseniz, önce kaydetmek için ``IBMQ.save_account('MY_API_TOKEN')`` kullanın."

#: ../../tutorials/01_portfolio_optimization.ipynb:94
msgid "Define problem instance"
msgstr "Sorun örneğini tanımlayın"

#: ../../tutorials/01_portfolio_optimization.ipynb:96
msgid "Here an Operator instance is created for our Hamiltonian. In this case the paulis are from an Ising Hamiltonian translated from the portfolio problem. We use a random portfolio problem for this notebook. It is straight-forward to extend this to using real financial data as illustrated here: `Loading and Processing Stock-Market Time-Series Data <11_time_series.ipynb>`__"
msgstr "Burada Hamiltonian’ımız için bir Operator örneği oluşturulmuştur. Bu durumda, pauliler portföy probleminden çevrilen Ising Hamiltonian’ından gelir. Bu not defteri için rastgele bir portföy problemi kullanıyoruz. `Loading and Processing Stock-Market Time-Series Data <11_time_series.ipynb>`__‘da gösterildiği gibi gerçek finansal veriyle genişletilebilir"

#: ../../tutorials/01_portfolio_optimization.ipynb:236
msgid "We define some utility methods to print the results in a nice format."
msgstr "Sonuçları güzel bir formatta yazdırmak için bazı yardımcı yöntemler tanımlarız."

#: ../../tutorials/01_portfolio_optimization.ipynb:280
msgid "NumPyMinimumEigensolver (as a classical reference)"
msgstr "NumPyMinimumEigensolver (klasik bir referans olarak)"

#: ../../tutorials/01_portfolio_optimization.ipynb:282
msgid "Lets solve the problem. First classically…"
msgstr "Sorunu çözelim. Önce klasik olarak…"

#: ../../tutorials/01_portfolio_optimization.ipynb:284
msgid "We can now use the Operator we built above without regard to the specifics of how it was created. We set the algorithm for the NumPyMinimumEigensolver so we can have a classical reference. The problem is set for ‘ising’. Backend is not required since this is computed classically not using quantum computation. The result is returned as a dictionary."
msgstr "Artık yukarıda oluşturduğumuz Operatörü nasıl oluşturulduğuna bakmadan kullanabiliriz. NumPyMinimumEigensolver algoritmasını klasik bir referansa sahip olabilmemiz için ayarladık. Sorun ‘ising için ayarlandı. Bu, klasik olarak kuantum hesaplama kullanılmadan hesaplandığından arka uç gerekli değildir. Sonuç bir sözlük olarak döndürülür."

#: ../../tutorials/01_portfolio_optimization.ipynb:370
msgid "Solution using VQE"
msgstr "VQE kullanarak çözüm"

#: ../../tutorials/01_portfolio_optimization.ipynb:372
msgid "We can now use the Variational Quantum Eigensolver (VQE) to solve the problem. We will specify the optimizer and variational form to be used."
msgstr "Problemi çözmek için şimdi Variational Quantum Eigensolver (VQE)'ı kullanabiliriz. Kullanılacak optimize ediciyi ve değişimsel yapıyı belirleyeceğiz."

#: ../../tutorials/01_portfolio_optimization.ipynb:374
msgid "Note: You can switch to different backends by providing the name of backend."
msgstr "Not: Arkayüz adını vererek farklı arkayüzlere geçiş yapabilirsiniz."

#: ../../tutorials/01_portfolio_optimization.ipynb:468
msgid "Solution using QAOA"
msgstr "QAOA kullanarak çözüm"

#: ../../tutorials/01_portfolio_optimization.ipynb:470
msgid "We also show here a result using the Quantum Approximate Optimization Algorithm (QAOA). This is another variational algorithm and it uses an internal variational form that is created based on the problem."
msgstr "Burada ayrıca, Kuantum Yaklaşık Optimizasyon Algoritması (QAOA) kullanılarak elde edilmiş bir sonuç da gösterilmektedir. Bu, başka bir değişimsel algoritmadır ve probleme dayanarak geliştirilmiş dahili bir değişimsel yapı kullanır."

#: ../../tutorials/02_portfolio_diversification.ipynb:9
msgid "Portfolio Diversification"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:14
msgid "In asset management, there are broadly two approaches: active and passive investment management. Within passive investment management, there are index-tracking funds and there are approaches based on portfolio diversification, which aim at representing a portfolio with a large number of assets by a smaller number of representative stocks. This notebook illustrates a portfolio diversification problem, which has recently become popular for two reasons: 1. it makes it possible to mimic the performance of an index (or a similarly large set of assets) with a limited budget, at limited transaction costs. That is: traditional index-tracking may purchase all assets in the index, ideally with the same weights as in the index. This may be impractical for a number of reasons: the total of even a single round lot per asset may amount to more than the assets under management, the large scale of the index-tracking problem with integrality constraints may render the optimization problem difficult, and the transaction costs of the frequent rebalancing to adjust the positions to the weights in the index may render the approach expensive. Thus, a popular approach is to select a portfolio of :math:`q` assets that represent the market with :math:`n` assets, where :math:`q` is significantly smaller than :math:`n`, but where the portfolio replicates the behavior of the underlying market. To determine how to group assets into :math:`q` clusters and how to determine which :math:`q` assets should represent the :math:`q` clusters amounts to solving a large-scale optimization problem. In the following we describe the mathematical model for the portfolio diversification problem as introduced in [Cornuejols & Tutuncu, 2006] 2. it allows for similarity measures between time-series beyond the covariance matrix. Notice that traditionally, modern portfolio theory considers the covariance matrix as a measure of similarity between the assets. As such, however, the covariance matrix is imperfect. Consider, for instance, a company listed both in London and New York. Although both listings should be very similar, only parts of the time series of the prices of the two listings will overlap, because of the partial overlap of the times the markets open. Instead of covariance, one can consider, for example, dynamic time warping of [Berndt and Clifford, 1994] as a measure of similarity between two time series, which allows for the fact that for some time periods, the data are captured by only one of the time series, while for others, both time series exhibit the similarity due to the parallel evolution of the stock price."
msgstr "Varlık yönteminde, genellikle iki yaklaşım vardır. Bunlar: aktif ve pasif yatırım yönetimi. Pasif yatırım yönetiminde, endeks takip fonları ve portföy çeşitlendirmesine dayalı yaklaşımlar bulunmaktadır. Bu yaklaşımlar, çok sayıda varlığa sahip bir portföyü daha az sayıda temsili hisse senedi ile temsil etmeyi amaçlamaktadır. Bu not defteri, son zamanlarda iki nedenden dolayı popüler hale gelen bir portföy çeşitlendirme sorununu örneklerle açıklamaktadır: 1. bir endeksin (veya benzer şekilde büyük bir varlık grubunun) performansını sınırlı bir bütçeyle, sınırlı işlem maliyetleriyle taklit etmeyi mümkün kılar. Yani: geleneksel endeks takibi, endeksteki tüm varlıkları, ideal olarak endeksteki aynı ağırlıklarda satın alabilir. Bu, birkaç nedenden ötürü pratik olmayabilir: varlık başına tek bir yuvarlak lotun toplamı, yönetilen varlıklardan daha fazlasına ulaşabilir, tümlevsel koşulları olan indeks takibi probleminin büyüklüğü optimizasyon problemini zorlaştırabilir ve pozisyonları endeksteki ağırlıklara göre ayarlamak için sık sık yeniden dengelemenin işlem maliyetleri, yaklaşımı pahalı hale getirebilir. Bu nedenle, :math:`q`'nun :math:`n`'den önemli ölçüde küçük olduğu ancak portföyün, piyasanın davranışını kopyaladığı, :math:`n` varlıkla pazarı temsil eden :math:`q` varlık portföyü seçmek popüler bir yaklaşımdır. Varlıkların :math:`q` kümelerine nasıl gruplanacağını belirlemek ve hangi :math:`q` varlıklarının :math:`q` kümelerini temsil edeceğini nasıl belirleneceğini belirlemek büyük ölçekli bir optimizasyon problemini çözmek demektir. Aşağıda, [Cornuejols ve Tutuncu, 2006] 'da gösterilen portföy çeşitlendirme problemi için matematiksel modeli açıklıyoruz. 2. Bu, kovaryans matrisinin ötesinde zaman serileri arasında benzerlik ölçümlerine izin verir. Geleneksel olarak, modern portföy teorisi, kovaryans matrisi, varlıklar arasındaki benzerliğin ölçüsü olarak değerlendirmektedir. Bununla birlikte, kovaryans matrisi eksiktir. Örneğin, bir şirketin hem Londra'da hem de New York'da listelendiğini düşünün. İkisinin de çok benzer olması gerekmesine rağmen, piyasaların açılma zamanlarının kısmi olarak örtüşmesi sebebiyle, fiyatlarının zaman serilerinin sadece bazı kısımları örtüşecektir. Kovaryans yerine, örneğin [Berndt ve Clifford, 1994] 'ün dinamik zaman atlaması iki zaman serisi arasındaki benzerliğin bir ölçüsü olarak değerlendirilebilir. Bu, bazı zaman aralıkları için verinin sadece tek bir zaman serisi tarafından yakalanmasını sağlar, diğerleri içinse, hisse senedi fiyatının paralel olarak ilerlemesinden dolayı her iki zaman serisi benzerlik göstermektedir."

#: ../../tutorials/02_portfolio_diversification.ipynb:21
msgid "The overall workflow we demonstrate comprises:"
msgstr "Gösterdiğimiz genel iş akışı şunları içerir:"

#: ../../tutorials/02_portfolio_diversification.ipynb:23
msgid "pick the ground set of assets. In our case, this is a small number of US stocks."
msgstr "temel varlık kümesini seçin. Bizim durumumuzda, bu az sayıda ABD hisse senedidir."

#: ../../tutorials/02_portfolio_diversification.ipynb:25
msgid "load the time series capturing the evolution of the prices of assets. In our case, this is a simplistic load of adjusted daily closing price data from Wikipedia or Nasdaq or LSE or EuroNext, whereas in a real asset management, a much higher frequency may be considered."
msgstr "varlık fiyatlarının değişimini gösteren zaman serilerini yükleyin. Bizim örneğimizde bu, Wikipedia, Nasdaq, LSE veya EuroNext’ten alınan ayarlanmış günlük kapanış fiyat verilerinin basit bir yüklemesidir, oysa gerçek bir varlık yönetiminde, çok daha yüksek bir frekans değerlendirilebilir."

#: ../../tutorials/02_portfolio_diversification.ipynb:27
msgid "compute the pair-wise similarity among the time series. In our case, we run a linear-time approximation of the dynamic time warping, still on the classical computer."
msgstr "zaman serileri arasındaki ikili benzerliği hesaplayın. Bizim durumumuzda, dinamik zaman atlamasının doğrusal zaman yaklaştırımını hala klasik bilgisayarda çalıştırıyoruz."

#: ../../tutorials/02_portfolio_diversification.ipynb:29
msgid "compute the actual portfolio of :math:`q` representative assets, based on the similarity measure. This step is run twice, actually. First, we obtain a reference value by a run of an IBM solver (IBM ILOG CPLEX or the Exact Eigensolver) on the classical computer. Second, we run an alternative, hybrid algorithm partly on the quantum computer."
msgstr "benzerlik ölçüsüne göre temsil edecek nitelikteki :math:`q` varlığının gerçek portföyünü hesaplayın. Bu adım aslında iki kez çalıştırılır. İlk olarak, klasik bilgisayarda bir IBM çözüm aracının (IBM ILOG CPLEX veya Exact Eigensolver) çalıştırılmasıyla bir referans değeri elde ederiz. İkinci olarak, kuantum bilgisayarda alternatif, hibrit bir algoritmayı kısmen çalıştırırız."

#: ../../tutorials/02_portfolio_diversification.ipynb:31
msgid "visualization of the results. In our case, this is again a simplistic plot."
msgstr "sonuçların görselleştirilmesi. Bizim durumumuzda, bu yine basit bir çizim."

#: ../../tutorials/02_portfolio_diversification.ipynb:33
msgid "In the following, we first explain the model used in (4) above, before we proceed with the installation of the pre-requisites and the data loading."
msgstr "Aşağıda, ön koşulların kurulumu ve veri yükleme işlemine geçmeden önce yukarıda (4)‘te kullanılan modeli açıklıyoruz."

#: ../../tutorials/02_portfolio_diversification.ipynb:36
msgid "The Model"
msgstr "Model"

#: ../../tutorials/02_portfolio_diversification.ipynb:38
msgid "As discussed in [Cornuejols & Tutuncu, 2006], we describe a mathematical model that clusters assets into groups of similar ones and selects one representative asset from each group to be included in the index fund portfolio. The model is based on the following data, which we will discuss in more detail later:"
msgstr "[Cornuejols & Tutuncu, 2006]‘da ele alındığı gibi, varlıkları benzer gruplar halinde kümeleyen ve her gruptan endeks fon portföyüne dahil edilecek temsili bir varlık seçen matematiksel bir model tanımlıyoruz. Model, daha sonra ayrıntılı olarak ele alacağımız aşağıdaki verilere dayanmaktadır:"

#: ../../tutorials/02_portfolio_diversification.ipynb:40
msgid "\\rho_{ij} = \\textrm{similarity}\\, \\textrm{between}\\, \\textrm{stock}\\, i \\, \\textrm{and}\\, \\textrm{stock}\\, j."
msgstr "\\rho_{ij} = \\textrm{similarity}\\, \\textrm{between}\\, \\textrm{stock}\\, i \\, \\textrm{and}\\, \\textrm{stock}\\, j."

#: ../../tutorials/02_portfolio_diversification.ipynb:45
msgid "For example, :math:`\\rho_{ii} = 1`, :math:`\\rho_{ij} \\leq 1` for :math:`i \\neq j` and :math:`\\rho_{ij}` is larger for more similar stocks. An example of this is the correlation between the returns of stocks :math:`i` and :math:`j`. But one could choose other similarity indices :math:`\\rho_{ij}`."
msgstr "Örneğin, :math:`i \\neq j` ve :math:`\\rho_{ij}` için :math:`\\rho_{ii} = 1`, :math:`\\rho_{ij} \\leq 1` daha benzer hisse senetleri için daha büyüktür. Hisse senedi getirileri :math:`i` ve :math:`j` arasındaki korelasyon bunun bir örneğidir. Fakat diğer benzerlik indeksleri :math:`\\rho_{ij}` seçilebilir."

#: ../../tutorials/02_portfolio_diversification.ipynb:47
msgid "The problem that we are interested in solving is:"
msgstr "Çözmeye çalıştığımız problem şudur:"

#: ../../tutorials/02_portfolio_diversification.ipynb:49
msgid "(M) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"
msgstr "(M) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"

#: ../../tutorials/02_portfolio_diversification.ipynb:54
msgid "subject to the clustering constraint:"
msgstr "kümeleme kısıtlamasına tabi:"

#: ../../tutorials/02_portfolio_diversification.ipynb:56
msgid "\\sum_{j=1}^n y_j = q,"
msgstr "\\sum_{j=1}^n y_j = q,"

#: ../../tutorials/02_portfolio_diversification.ipynb:61
msgid "to consistency constraints:"
msgstr "tutarlılık koşullarına:"

#: ../../tutorials/02_portfolio_diversification.ipynb:63
msgid "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n"
"\\quad x_{ij} \\leq y_j,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n"
"\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n,"
msgstr "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n"
"\\quad x_{ij} \\leq y_j,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n"
"\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n,"

#: ../../tutorials/02_portfolio_diversification.ipynb:70
msgid "and integral constraints:"
msgstr "ve integral kısıtlamaları:"

#: ../../tutorials/02_portfolio_diversification.ipynb:72
msgid "\\quad  x_{ij}, y_j \\in\\{0,1\\}, \\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n."
msgstr "\\quad  x_{ij}, y_j \\in\\{0,1\\}, \\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n."

#: ../../tutorials/02_portfolio_diversification.ipynb:77
msgid "The variables :math:`y_j` describe which stocks :math:`j` are in the index fund (:math:`y_j = 1` if :math:`j` is selected in the fund, :math:`0` otherwise). For each stock :math:`i = 1,\\dots,n`, the variable :math:`x_{ij}` indicates which stock :math:`j` in the index fund is most similar to :math:`i` (:math:`x_{ij} = 1` if :math:`j` is the most similar stock in the index fund, :math:`0` otherwise)."
msgstr ":math:`y_j` değişkenleri hangi :math:`j` hisse senetlerinin endeks fonunda olduğunu ifade eder (eğer :math:`j` fonda seçildiyse :math:`y_j = 1`, seçilmediyse :math:`0`). Her bir :math:`i = 1,\\dots,n` hisse senedi için, :math:`x_{ij}` değişkeni endeks fonundaki hangi :math:`j` hisse senedinin :math:`i`'ye en çok benzediğini gösterir (fondaki en benzer hisse senedi :math:`j` ise :math:`x_{ij} = 1`, değilse :math:`0`)."

#: ../../tutorials/02_portfolio_diversification.ipynb:79
msgid "The first constraint selects :math:`q` stocks in the fund. The second constraint imposes that each stock :math:`i` has exactly one representative stock :math:`j` in the fund. The third and fourth constraints guarantee that stock :math:`i` can be represented by stock :math:`j` only if :math:`j` is in the fund. The objective of the model maximizes the similarity between the :math:`n` stocks and their representatives in the fund. Different cost functions can also be considered."
msgstr "Birinci koşul, fondaki :math:`q` hisse senedini seçer. İkinci koşul, her :math:`i` hisse senedinin fonda tam olarak bir temsili :math:`j` hisse senedine sahip olduğunu belirtir. Üçüncü ve dördüncü koşullar, :math:`i` hisse senedinin yalnızca :math:`j`’nin fonda olması durumunda :math:`j` hisse senedi ile temsil edilebileceğini garanti etmektedir. Modelin amacı, :math:`n` hisse senetleri ile fondaki temsilcileri arasındaki benzerliği maksimuma çıkarmaktır. Farklı maliyet fonksiyonları da düşünülebilir."

#: ../../tutorials/02_portfolio_diversification.ipynb:81
msgid "Let us concatenate the decision variables in one vector"
msgstr "Karar değişkenlerini bir vektörde birleştirelim"

#: ../../tutorials/02_portfolio_diversification.ipynb:83
msgid "{\\bf z} = [x_{11},x_{12},\\ldots,x_{1n}, x_{22},\\ldots,x_{nn}, y_{1},\\ldots,y_{n}],"
msgstr "{\\bf z} = [x_{11},x_{12},\\ldots,x_{1n}, x_{22},\\ldots,x_{nn}, y_{1},\\ldots,y_{n}],"

#: ../../tutorials/02_portfolio_diversification.ipynb:88
msgid "whose dimension is :math:`{\\bf z} \\in \\{0,1\\}^N`, with :math:`N = n (n+1)` and denote the optimal solution with :math:`{\\bf z}^*`, and the optimal cost :math:`f^*`."
msgstr "boyutu :math:`N = n (n+1)` olacak şekilde :math:`{\\bf z} \\in \\{0,1\\}^N`‘dir ve :math:`{\\bf z}^*` ile en uygunu çözümü ve en uygun maliyet :math:`f^*`’i göstermektedir."

#: ../../tutorials/02_portfolio_diversification.ipynb:91
msgid "A Hybrid Approach"
msgstr "Hibrit Bir Yaklaşım"

#: ../../tutorials/02_portfolio_diversification.ipynb:93
msgid "Here, we demonstrate an approach that combines classical and quantum computing steps, following the quantum approximate optimization approach of Farhi, Goldstone, and Gutmann (2014)."
msgstr "Burada, Farhi, Goldstone ve Gutman'ın (2014) kuantum yaklaşık optimizasyon yöntemini izleyerek klasik ve kuantum hesaplama adımlarını birleştiren bir yöntemi gösteriyoruz."

#: ../../tutorials/02_portfolio_diversification.ipynb:96
msgid "Construct a binary polynomial optimization"
msgstr "İkili bir polinom optimizasyonu oluşturun"

#: ../../tutorials/02_portfolio_diversification.ipynb:98
msgid "From :math:`(M)` one can construct a binary polynomial optimization with equality constraints only, by substituting the :math:`x_{ij} \\leq y_j` inequality constraints with the equivalent equality constraints :math:`x_{ij} (1- y_j) = 0`. Then the problem becomes:"
msgstr ":math:`x_{ij} \\leq y_j` eşitsizlik koşulları, eşdeğer eşitlik koşulları :math:`x_{ij} (1- y_j) = 0` ile değiştirilerek sadece eşitlik koşulları ile :math:`(M)`‘den ikili bir polinom optimizasyonu oluşturulabilmektedir. O zaman problem şuna dönüşür:"

#: ../../tutorials/02_portfolio_diversification.ipynb:100
msgid "(BPO) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"
msgstr "(BPO) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"

#: ../../tutorials/02_portfolio_diversification.ipynb:105
msgid "subject to the clustering constraint, the integral constraints, and the following modified consistency constraints:"
msgstr "kümeleme kısıtlamasına, integral kısıtlamalarına ve aşağıdaki değiştirilmiş tutarlılık kısıtlamalarına tabidir:"

#: ../../tutorials/02_portfolio_diversification.ipynb:107
msgid "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n\n"
msgstr "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n\n"

#: ../../tutorials/02_portfolio_diversification.ipynb:109
msgid "\\quad x_{ij} (1- y_j) = 0,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n\n"
msgstr "\\quad x_{ij} (1- y_j) = 0,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n\n"

#: ../../tutorials/02_portfolio_diversification.ipynb:111
msgid "\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n.\n\n"
msgstr "\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n.\n\n"

#: ../../tutorials/02_portfolio_diversification.ipynb:114
msgid "Construct the Ising Hamiltonian"
msgstr "Ising Hamilton’u Oluşturun"

#: ../../tutorials/02_portfolio_diversification.ipynb:116
msgid "We can now construct the Ising Hamiltonian (QUBO) by penalty methods (introducing a penalty coefficient :math:`A` for each equality constraint) as"
msgstr "Artık Ising Hamiltonian’ı (QUBO) ceza yöntemleriyle (her bir eşitlik kısıtı için bir ceza katsayısı :math:`A` ekleyerek) şu şekilde oluşturabiliriz"

#: ../../tutorials/02_portfolio_diversification.ipynb:118
msgid "(IH) \\quad H = \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} + A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 + \\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 + \\sum_{j=1}^n A (x_{jj}-y_j)^2 +\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right)."
msgstr "(IH) \\quad H = \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} + A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 + \\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 + \\sum_{j=1}^n A (x_{jj}-y_j)^2 +\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right)."

#: ../../tutorials/02_portfolio_diversification.ipynb:124
msgid "From Hamiltonian to Quadratic Programming (QP) formulation"
msgstr "Hamiltonyen'den Kuadratik Programlama (KP) formülasyonuna"

#: ../../tutorials/02_portfolio_diversification.ipynb:126
msgid "In the vector :math:`{\\bf z}`, the Ising Hamiltonian elements can be rewritten as follows,"
msgstr ":math:`{\\bf z}` vektöründe, Ising Hamiltonyen öğeleri aşağıdaki gibi yazılabilir,"

#: ../../tutorials/02_portfolio_diversification.ipynb:128
msgid "First term:"
msgstr "İlk terim:"

#: ../../tutorials/02_portfolio_diversification.ipynb:130
msgid "\\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} = [\\rho_{11},\\rho_{12},\\ldots,\\rho_{1n}, \\rho_{22},\\ldots,\\rho_{nn}|{\\bf 0}_n ]{\\bf z} =: {\\bf c}_0^T {\\bf z}"
msgstr "\\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} = [\\rho_{11},\\rho_{12},\\ldots,\\rho_{11}, \\rho_{22},\\ldots,\\rho_{nn}|{\\bf 0}_n ]{\\bf z} =: {\\bf c}_0^T {\\bf z}"

#: ../../tutorials/02_portfolio_diversification.ipynb:135
msgid "Second term:"
msgstr "İkinci terim:"

#: ../../tutorials/02_portfolio_diversification.ipynb:137
msgid "A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 = A \\Big(\\sum_{j=1}^n y_j\\Big)^2 - 2 Aq \\sum_{j=1}^n y_j + A q^2 = A {\\bf z}^T \\left[\\begin{array}{c}{\\bf 0}_{n^2} \\\\ \\hline  {\\bf 1}_n  \\end{array}\\right]\\left[\\begin{array}{cc}{\\bf 0}_{n^2} | {\\bf 1}_n  \\end{array}\\right]{\\bf z} - 2 A q [{\\bf 0}_{n^2}|{\\bf 1}_n]{\\bf z} + A q^2 =: {\\bf z}^T {\\bf Q}_0 {\\bf z} + {\\bf c}_1^T {\\bf z} + r_0"
msgstr "A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 = A \\Big(\\sum_{j=1}^n y_j\\Big)^2 - 2 Aq \\sum_{j=1}^n y_j + A q^2 = A {\\bf z}^T \\left[\\begin{array}{c}{\\bf 0}_{n^2} \\\\ \\hline  {\\bf 1}_n  \\end{array}\\right]\\left[\\begin{array}{cc}{\\bf 0}_{n^2} | {\\bf 1}_n  \\end{array}\\right]{\\bf z} - 2 A q [{\\bf 0}_{n^2}|{\\bf 1}_n]{\\bf z} + A q^2 =: {\\bf z}^T {\\bf Q}_0 {\\bf z} + {\\bf c}_1^T {\\bf z} + r_0"

#: ../../tutorials/02_portfolio_diversification.ipynb:142
msgid "Third term:"
msgstr "Üçüncü terim:"

#: ../../tutorials/02_portfolio_diversification.ipynb:144
msgid "\\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 = A\\sum_{i=1}^n \\Big(\\sum_{j=1}^n x_{ij}\\Big)^2 - 2 A \\sum_{i=1}^n\\sum_{j=1}^n x_{ij} + n A = \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad"
msgstr "\\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 = A\\sum_{i=1}^n \\Big(\\sum_{j=1}^n x_{ij}\\Big)^2 - 2 A \\sum_{i=1}^n\\sum_{j=1}^n x_{ij} + n A = \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad"

#: ../../tutorials/02_portfolio_diversification.ipynb:149
msgid "which is equivalent to:"
msgstr "bu da aşağıdakine eşittir:"

#: ../../tutorials/02_portfolio_diversification.ipynb:151
msgid "\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad = A {\\bf z}^T \\left(\\sum_{i=1}^n \\left[\\begin{array}{c}{\\bf 0}_{n(i-1)}  \\\\ {\\bf 1}_n  \\\\ {\\bf 0}_{n(n-i)} \\\\ \\hline {\\bf 0}_{n} \\end{array}\\right]\\left[\\begin{array}{cccc}{\\bf 0}_{n(i-1)} & {\\bf 1}_n  & {\\bf 0}_{n(n-i)} & | {\\bf 0}_{n} \\end{array}\\right]\\right){\\bf z} - 2 A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + n A =: {\\bf z}^T {\\bf Q}_1 {\\bf z} + {\\bf c}_2^T {\\bf z} + r_1"
msgstr "\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad = A {\\bf z}^T \\left(\\sum_{i=1}^n \\left[\\begin{array}{c}{\\bf 0}_{n(i-1)}  \\\\ {\\bf 1}_n  \\\\ {\\bf 0}_{n(n-i)} \\\\ \\hline {\\bf 0}_{n} \\end{array}\\right]\\left[\\begin{array}{cccc}{\\bf 0}_{n(i-1)} & {\\bf 1}_n  & {\\bf 0}_{n(n-i)} & | {\\bf 0}_{n} \\end{array}\\right]\\right){\\bf z} - 2 A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + n A =: {\\bf z}^T {\\bf Q}_1 {\\bf z} + {\\bf c}_2^T {\\bf z} + r_1"

#: ../../tutorials/02_portfolio_diversification.ipynb:156
msgid "Fourth term:"
msgstr "Dördüncü terim:"

#: ../../tutorials/02_portfolio_diversification.ipynb:158
msgid "A \\sum_{j=1}^n  (x_{jj}-y_j)^2 = A {\\bf z}^T  \\left(\\sum_{j=0}^{n-1} \\left[\\begin{array}{c}{\\bf 0}_{nj + j}  \\\\ 1  \\\\ {\\bf 0}_{n^2-(nj+j+1)} \\\\ \\hline {\\bf 0}_{j} \\\\ -1 \\\\ {\\bf 0}_{n-j-1} \\end{array}\\right]\\left[\\begin{array}{cccccc}{\\bf 0}_{nj + j} & 1  & {\\bf 0}_{n^2-(nj+j+1)} & | {\\bf 0}_{j} & -1 & {\\bf 0}_{n-j-1}  \\end{array}\\right]\\right){\\bf z} = A {\\bf z}^T {\\bf Q}_2 {\\bf z}"
msgstr "A \\sum_{j=1}^n  (x_{jj}-y_j)^2 = A {\\bf z}^T  \\left(\\sum_{j=0}^{n-1} \\left[\\begin{array}{c}{\\bf 0}_{nj + j}  \\\\ 1  \\\\ {\\bf 0}_{n^2-(nj+j+1)} \\\\ \\hline {\\bf 0}_{j} \\\\ -1 \\\\ {\\bf 0}_{n-j-1} \\end{array}\\right]\\left[\\begin{array}{cccccc}{\\bf 0}_{nj + j} & 1  & {\\bf 0}_{n^2-(nj+j+1)} & | {\\bf 0}_{j} & -1 & {\\bf 0}_{n-j-1}  \\end{array}\\right]\\right){\\bf z} = A {\\bf z}^T {\\bf Q}_2 {\\bf z}"

#: ../../tutorials/02_portfolio_diversification.ipynb:163
msgid "Fifth term:"
msgstr "Beşinci terim:"

#: ../../tutorials/02_portfolio_diversification.ipynb:165
msgid "\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right) = A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + A {\\bf z}^T \\left( \\sum_{i=1}^n \\sum_{j=1}^n \\left[\\begin{array}{ccc|c}  &  & & \\\\ & {\\bf 0}_{n^2\\times n^2} & & -1/2_{(ij,j)}  \\\\ & & & \\\\ \\hline & -1/2_{(j, ij)} &  & {\\bf 0}_{n} \\end{array}\\right] \\right) {\\bf z} =:  {\\bf z}^T {\\bf Q}_3 {\\bf z} + {\\bf c}_3^T {\\bf z}"
msgstr "\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right) = A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + A {\\bf z}^T \\left( \\sum_{i=1}^n \\sum_{j=1}^n \\left[\\begin{array}{ccc|c}  &  & & \\\\ & {\\bf 0}_{n^2\\times n^2} & & -1/2_{(ij,j)}  \\\\ & & & \\\\ \\hline & -1/2_{(j, ij)} &  & {\\bf 0}_{n} \\end{array}\\right] \\right) {\\bf z} =:  {\\bf z}^T {\\bf Q}_3 {\\bf z} + {\\bf c}_3^T {\\bf z}"

#: ../../tutorials/02_portfolio_diversification.ipynb:170
msgid "Therefore, the formulation becomes,"
msgstr "Böylece, formülasyon şu hale gelir,"

#: ../../tutorials/02_portfolio_diversification.ipynb:172
msgid "(IH-QP)\\quad \\max_{{\\bf z}\\in\\{0,1\\}^{n(n+1)}} \\, {\\bf z}^T ({\\bf Q}_0+{\\bf Q}_1+ {\\bf Q}_2 + {\\bf Q}_3 ){\\bf z} + ({\\bf c}_0+{\\bf c}_1+{\\bf c}_2+{\\bf c}_3)^T {\\bf z} +r_0+r_1+r_2"
msgstr "(IH-QP)\\quad \\max_{{\\bf z}\\in\\{0,1\\}^{n(n+1)}} \\, {\\bf z}^T ({\\bf Q}_0+{\\bf Q}_1+ {\\bf Q}_2 + {\\bf Q}_3 ){\\bf z} + ({\\bf c}_0+{\\bf c}_1+{\\bf c}_2+{\\bf c}_3)^T {\\bf z} +r_0+r_1+r_2"

#: ../../tutorials/02_portfolio_diversification.ipynb:177
msgid "which can be passed to the variational quantum eigensolver."
msgstr "variational quantum eigensolver‘a geçirilebilir."

#: ../../tutorials/02_portfolio_diversification.ipynb:180
msgid "References"
msgstr "Kaynaklar"

#: ../../tutorials/02_portfolio_diversification.ipynb:182
msgid "[1] G. Cornuejols, M. L. Fisher, and G. L. Nemhauser, *Location of bank accounts to optimize float: an analytical study of exact and approximate algorithms*, Management Science, vol. 23(8), 1997"
msgstr "[1] G. Cornuejols, M. L. Fisher, and G. L. Nemhauser, *Location of bank accounts to optimize float: an analytical study of exact and approximate algorithms*, Management Science, vol. 23(8), 1997"

#: ../../tutorials/02_portfolio_diversification.ipynb:184
msgid "[2] E. Farhi, J. Goldstone, S. Gutmann e-print `arXiv 1411.4028, 2014 <https://arxiv.org/abs/1411.4028>`__"
msgstr "[2] E. Farhi, J. Goldstone, S. Gutmann e-print `arXiv 1411.4028, 2014 <https://arxiv.org/abs/1411.4028>`__"

#: ../../tutorials/02_portfolio_diversification.ipynb:186
msgid "[3] G. Cornuejols and R. Tutuncu, `Optimization methods in finance <http://web.math.ku.dk/~rolf/CT_FinOpt.pdf>`__, 2006"
msgstr "[3] G. Cornuejols and R. Tutuncu, `Optimization methods in finance <http://web.math.ku.dk/~rolf/CT_FinOpt.pdf>`__, 2006"

#: ../../tutorials/02_portfolio_diversification.ipynb:188
msgid "[4] DJ. Berndt and J. Clifford, *Using dynamic time warping to find patterns in time series*. In KDD workshop 1994 (Vol. 10, No. 16, pp. 359-370)."
msgstr "[4] DJ. Berndt and J. Clifford, *Using dynamic time warping to find patterns in time series*. In KDD workshop 1994 (Vol. 10, No. 16, pp. 359-370)."

#: ../../tutorials/02_portfolio_diversification.ipynb:190
msgid "[5] `Max-Cut and Traveling Salesman Problem <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__"
msgstr "[5] `Max-Cut and Traveling Salesman Problem <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__"

#: ../../tutorials/02_portfolio_diversification.ipynb:202
msgid "The Implementation"
msgstr "Uygulama"

#: ../../tutorials/02_portfolio_diversification.ipynb:204
msgid "First, we import the requisite modules."
msgstr "İlk olarak, gerekli modülleri içe aktarıyoruz."

#: ../../tutorials/02_portfolio_diversification.ipynb:246
msgid "Next, we download price data for two stocks and compute their pair-wise similarity matrix (`dynamic time warping <https://en.wikipedia.org/wiki/Dynamic_time_warping>`__ distance normalized to (0,1] by taking the reciprocal). If this fails, e.g., due to you being offline or exceeding the daily limit for accesses to the stock-market data, we consider a constant matrix instead."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:278
msgid "Now we decide on the number of clusters. This has to be smaller than the number of stocks we have loaded."
msgstr "Şimdi küme sayılarına karar veriyoruz. Bu, yüklediğimiz hisse senetlerinin sayısından daha küçük olmalı."

#: ../../tutorials/02_portfolio_diversification.ipynb:300
msgid "Classical solution using IBM ILOG CPLEX"
msgstr "IBM ILOG CPLEX kullanılarak klasik çözüm"

#: ../../tutorials/02_portfolio_diversification.ipynb:302
msgid "For a classical solution, we use IBM CPLEX. CPLEX is able to find the exact solution of this problem. We first define a ClassicalOptimizer class that encodes the problem in a way that CPLEX can solve, and then instantiate the class and solve it."
msgstr "Klasik bir çözüm için IBM CPLEX kullanırız. CPLEX, bu sorunun tam çözümünü bulabilmektedir. Önce, problemi CPLEX'in çözebileceği şekilde kodlayan bir ClassicalOptimizer sınıfı tanımlıyoruz ve ardından sınıfı örnekleyerek çözüyoruz."

#: ../../tutorials/02_portfolio_diversification.ipynb:471
msgid "Solution shows the selected stocks via the stars and in green the links (via similarities) with other stocks that are represented in the fund by the linked stock."
msgstr "Çözüm, seçilen hisse senetlerini yıldızlarla ve bağlı hisse senetleri ile fonda temsil edilen diğer hisse senetleriyle olan bağlantıları (benzerlikler yoluyla) yeşil renkte gösterir."

#: ../../tutorials/02_portfolio_diversification.ipynb:483
msgid "Quantum Computing with IBM Q"
msgstr "IBM Q ile Kuantum Hesaplama"

#: ../../tutorials/02_portfolio_diversification.ipynb:485
msgid "For the quantum solution, we use Qiskit. We first define a class QuantumOptimizer that encodes the quantum approach to solve the problem and then we instantiate it and solve it. We define the following methods inside the class:"
msgstr "Kuantum çözümü için Qiskit’i kullanıyoruz. Problemi çözmek için önce, kuantum yaklaşımını kodlayan bir QuantumOptimizer sınıfı tanımlıyoruz ve sonra onu örnekleyip çözüyoruz. Aşağıdaki metotları sınıf içinde tanımlıyoruz:"

#: ../../tutorials/02_portfolio_diversification.ipynb:487
msgid "``exact_solution`` : to make sure that the Ising Hamiltonian is correctly encoded in the :math:`Z` basis, we can compute its eigendecomposition classically, i.e., considering a symmetric matrix of dimension :math:`2^N \\times 2^N`. For the problem at hand :math:`n=3`, that is :math:`N = 12`, seems to be the limit for many laptops;"
msgstr "``exact_solution``: Ising Hamiltonyen'in :math:`Z` bazında doğru kodlandığından emin olmak için, :math:`2^N \\times 2^N` boyutunun simetrik bir matrisini dikkate alarak, özdeğerlerine ve özvektörlerine ayırmasını klasik olarak hesaplayabiliriz. Elimizdeki problem için :math:`n=3`, yani :math:`N = 12`, birçok dizüstü bilgisayar için sınır olarak görünüyor;"

#: ../../tutorials/02_portfolio_diversification.ipynb:488
msgid "``vqe_solution`` : solves the problem :math:`(M)` via the variational quantum eigensolver (VQE);"
msgstr "``vqe_solution`` : :math:`(M)` problemini variational quantum eigensolver (VQE) aracılığıyla çözer;"

#: ../../tutorials/02_portfolio_diversification.ipynb:489
msgid "``qaoa_solution`` : solves the problem :math:`(M)` via a Quantum Approximate Optimization Algorithm (QAOA)."
msgstr "``qaoa_solution`` : :math:`(M)` problemini bir Kuantum Yaklaşık Optimizasyon Algoritması (QAOA) aracılığıyla çözer."

#: ../../tutorials/02_portfolio_diversification.ipynb:557
msgid "Step 1"
msgstr "1. Adım"

#: ../../tutorials/02_portfolio_diversification.ipynb:559
msgid "Instantiate the quantum optimizer class with parameters: - the similarity matrix ``rho``; - the number of assets and clusters ``n`` and ``q``;"
msgstr "Kuantum en iyileştirici sınıfını şu parametrelerle örnekleyin: - benzerlik matrisi ``rho``; - varlıkların ve kümelerin sayısı ``n`` ve ``q``;"

#: ../../tutorials/02_portfolio_diversification.ipynb:582
msgid "Step 2"
msgstr "2. Adım"

#: ../../tutorials/02_portfolio_diversification.ipynb:584
msgid "Encode the problem as a binary formulation (IH-QP)."
msgstr "Problemi ikili formülasyon (IH-QP) olarak kodlayın."

#: ../../tutorials/02_portfolio_diversification.ipynb:586
msgid "Sanity check: make sure that the binary formulation in the quantum optimizer is correct (i.e., yields the same cost given the same solution)."
msgstr "Sağlama: kuantum en iyileyicideki ikili formülasyonun doğru olduğundan emin olun (yani, aynı çözüm verildiğinde aynı maliyet sonucunu vermeli)."

#: ../../tutorials/02_portfolio_diversification.ipynb:643
msgid "Step 3"
msgstr "3. Adım"

#: ../../tutorials/02_portfolio_diversification.ipynb:645
msgid "Encode the problem as an Ising Hamiltonian in the Z basis."
msgstr "Problemi Z bazında Ising Hamiltonyen olarak kodlayın."

#: ../../tutorials/02_portfolio_diversification.ipynb:647
msgid "Sanity check: make sure that the formulation is correct (i.e., yields the same cost given the same solution)"
msgstr "Sağlama: formülasyonun doğru olduğundan emin olun (yani, aynı çözüm verildiğinde aynı maliyeti sağlamalı)"

#: ../../tutorials/02_portfolio_diversification.ipynb:698
msgid "Step 4"
msgstr "4. Adım"

#: ../../tutorials/02_portfolio_diversification.ipynb:700
msgid "Solve the problem via VQE. Notice that depending on the number of qubits, this can take a while: for 6 qubits it takes 15 minutes on a 2015 Macbook Pro, for 12 qubits it takes more than 12 hours. For longer runs, logging may be useful to observe the workings; otherwise, you just have to wait until the solution is printed."
msgstr "Problemi VQE ile çözün. Kübit sayısına bağlı olarak bunun biraz zaman alabileceğine dikkat etmelisiniz: 6 kübit için 2015 Macbook Pro'da 15 dakika, 12 kübit için 12 saatten fazla sürer. Daha uzun süreli çalıştırmalarda, çalışmaları gözlemlemek için kayıt tutmak yararlı olabilir; aksi takdirde, çözüm yazdırılana kadar beklemeniz gerekir."

#: ../../tutorials/02_portfolio_diversification.ipynb:755
msgid "Step 5"
msgstr "5. Adım"

#: ../../tutorials/02_portfolio_diversification.ipynb:757
msgid "Visualize the solution"
msgstr "Çözümü görselleştirme"

#: ../../tutorials/02_portfolio_diversification.ipynb:832
msgid "Solution shows the selected stocks via the stars and in green the links (via similarities) with other stocks that are represented in the fund by the linked stock. Keep in mind that VQE is a heuristic working on the QP formulation of the Ising Hamiltonian, though. For suitable choices of A, local optima of the QP formulation will be feasible solutions to the ILP. While for some small instances, as above, we can find optimal solutions of the QP formulation which coincide with optima of the ILP, finding optimal solutions of the ILP is harder than finding local optima of the QP formulation, in general. Even within the VQE, one may provide stronger guarantees, for specific variational forms (trial wave functions)."
msgstr "Çözüm, seçilen hisse senetlerini yıldızlarla ve bağlı hisse senedi ile fonda temsil edilen diğer hisse senetleriyle bağlantılarını (benzerlikler yoluyla) yeşil renkte gösterir. Yine de, VQE'nin Ising Hamiltonyen'in QP formülasyonunda buluşsal bir çalışma olduğunu unutmayınız. Uygun A seçimleri için, QP formülasyonunun yerel optimumları, ILP'ye yönelik uygun çözümler olacaktır. Yukarıdaki gibi bazı küçük örnekler için, ILP'nin optimumları ile örtüşen QP formülasyonunun optimal çözümlerini bulabilsek de, genel olarak, ILP'nin optimal çözümlerinin bulunması QP formülasyonunun optimal çözümlerinin bulunmasından daha zordur. VQE içinde bile, belirli değişimsel formlar için (deneme dalga fonksiyonları) daha güçlü güvenceler sağlanabilir."

#: ../../tutorials/03_european_call_option_pricing.ipynb:9
msgid "Pricing European Call Options"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:23
msgid "Suppose a European call option with strike price :math:`K` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr "Kullanım fiyatı :math:`K` olan bir Avrupa alım opsiyonu ve :math:`S_T` vadesindeki spot fiyatı belirli bir rasgele dağılımı izleyen bir dayanak varlık varsayalım. Karşılık gelen getiri fonksiyonu şu şekilde tanımlanır:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:25
msgid "\\max\\{S_T - K, 0\\}\n\n"
msgstr "\\max\\{S_T - K, 0\\}\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:27
#: ../../tutorials/04_european_put_option_pricing.ipynb:27
#: ../../tutorials/05_bull_spread_pricing.ipynb:27
#: ../../tutorials/06_basket_option_pricing.ipynb:27
msgid "In the following, a quantum algorithm based on amplitude estimation is used to estimate the expected payoff, i.e., the fair price before discounting, for the option:"
msgstr "Aşağıda, beklenen getiriyi, yani indirimden önceki adil fiyatı tahmin etmek için genlik tahminine dayalı bir kuantum algoritması kullanılmaktadır:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{S_T - K, 0\\} \\right]\n\n"
msgstr "\\mathbb{E}\\left[ \\max\\{S_T - K, 0\\} \\right]\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:31
#: ../../tutorials/04_european_put_option_pricing.ipynb:31
#: ../../tutorials/05_bull_spread_pricing.ipynb:31
msgid "as well as the corresponding :math:`\\Delta`, i.e., the derivative of the option price with respect to the spot price, defined as:"
msgstr "ve karşılık gelen :math:`\\Delta` da, yani opsiyon fiyatının spot fiyata göre türevi de, şöyle tanımlanır:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[S_T \\geq K\\right]"
msgstr "\\Delta = \\mathbb{P}\\left[S_T \\geq K\\right]"

#: ../../tutorials/03_european_call_option_pricing.ipynb:38
#: ../../tutorials/04_european_put_option_pricing.ipynb:38
#: ../../tutorials/05_bull_spread_pricing.ipynb:38
#: ../../tutorials/06_basket_option_pricing.ipynb:31
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:44
msgid "The approximation of the objective function and a general introduction to option pricing and risk analysis on quantum computers are given in the following papers:"
msgstr "Amaç fonksiyonun yaklaştırımı ve kuantum bilgisayarlarda opsiyon fiyatlamasına ve risk analizine genel bir giriş aşağıdaki makalelerde verilmiştir:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:40
msgid "`Quantum Risk Analysis. Woerner, Egger. 2018. <https://www.nature.com/articles/s41534-019-0130-6>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:41
msgid "`Option Pricing using Quantum Computers. Stamatopoulos et al. 2019. <https://quantum-journal.org/papers/q-2020-07-06-291/>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:71
#: ../../tutorials/04_european_put_option_pricing.ipynb:82
#: ../../tutorials/05_bull_spread_pricing.ipynb:71
#: ../../tutorials/06_basket_option_pricing.ipynb:66
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:79
#: ../../tutorials/08_fixed_income_pricing.ipynb:66
#: ../../tutorials/09_credit_risk_analysis.ipynb:120
#: ../../tutorials/10_qgan_option_pricing.ipynb:48
msgid "Uncertainty Model"
msgstr "Belirsizlik Modeli"

#: ../../tutorials/03_european_call_option_pricing.ipynb:73
#: ../../tutorials/04_european_put_option_pricing.ipynb:84
#: ../../tutorials/05_bull_spread_pricing.ipynb:73
msgid "We construct a circuit factory to load a log-normal random distribution into a quantum state. The distribution is truncated to a given interval :math:`[\\text{low}, \\text{high}]` and discretized using :math:`2^n` grid points, where :math:`n` denotes the number of qubits used. The unitary operator corresponding to the circuit factory implements the following:"
msgstr "Log-normal rasgele dağılımı bir kuantum durumuna yüklemek için bir devre fabrikası oluşturuyoruz. Dağılım, verilen bir :math:`[\\text{low}, \\text{high}]` aralığına indirgenir ve :math:`2^n` ızgara noktası kullanılarak ayıştırılır. Burada :math:`n` kulanılan kübit sayısını belirtir. Devre fabrikasına karşılık gelen üniter operatör aşağıdakini uygular:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:75
#: ../../tutorials/04_european_put_option_pricing.ipynb:86
#: ../../tutorials/05_bull_spread_pricing.ipynb:75
msgid "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i=0}^{2^n-1} \\sqrt{p_i}\\big|i\\rangle_{n},\n\n"
msgstr "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i=0}^{2^n-1} \\sqrt{p_i}\\big|i\\rangle_{n},\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:77
#: ../../tutorials/04_european_put_option_pricing.ipynb:88
#: ../../tutorials/05_bull_spread_pricing.ipynb:77
msgid "where :math:`p_i` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i` is mapped to the right interval using the affine map:"
msgstr "burada :math:`p_i` indirgenmiş ve ayrıştırılmış dağılıma karşılık gelen olasılıkları belirtmektedir ve :math:`i` afin harita kullanılarak doğru aralık ile eşlenmektedir:"

#: ../../tutorials/03_european_call_option_pricing.ipynb:79
#: ../../tutorials/04_european_put_option_pricing.ipynb:90
#: ../../tutorials/05_bull_spread_pricing.ipynb:79
msgid "\\{0, \\ldots, 2^n-1\\} \\ni i \\mapsto \\frac{\\text{high} - \\text{low}}{2^n - 1} * i + \\text{low} \\in [\\text{low}, \\text{high}].\n\n"
msgstr "\\{0, \\ldots, 2^n-1\\} \\ni i \\mapsto \\frac{\\text{high} - \\text{low}}{2^n - 1} * i + \\text{low} \\in [\\text{low}, \\text{high}].\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:159
#: ../../tutorials/04_european_put_option_pricing.ipynb:170
#: ../../tutorials/05_bull_spread_pricing.ipynb:158
#: ../../tutorials/06_basket_option_pricing.ipynb:171
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:184
msgid "Payoff Function"
msgstr "Getiri Fonksiyonu"

#: ../../tutorials/03_european_call_option_pricing.ipynb:161
msgid "The payoff function equals zero as long as the spot price at maturity :math:`S_T` is less than the strike price :math:`K` and then increases linearly. The implementation uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\geq K`, and this ancilla is used to control the linear part of the payoff function."
msgstr ":math:`S_T` vadesindeki spot fiyat, kullanım fiyatı :math:`K`'dan düşük olduğu sürece, getiri fonksiyonu sıfıra eşittir. Sonrasında da doğrusal olarak artış gösterir. Uygulama, :math:`S_T \\geq K` ise bir yardımcı kübiti :math:`\\big|0\\rangle`'dan :math:`\\big|1\\rangle`'e çeviren bir karşılaştırıcı kullanır ve bu yardımcı, getiri fonksiyonunun doğrusal kısmını kontrol etmek için kullanılır."

#: ../../tutorials/03_european_call_option_pricing.ipynb:163
#: ../../tutorials/05_bull_spread_pricing.ipynb:162
msgid "The linear part itself is then approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr "Doğrusal kısma şu şekilde bir yaklaşımda bulunabiliriz. Küçük :math:`|y|` için :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` durumundan faydalanabiliriz. Böylece, verilen yaklaştırım ölçeklendirme katsayısı :math:`c_\\text{approx} \\in [0, 1]` ve :math:`x \\in [0, 1]` için aşağıdakini dikkate alırız"

#: ../../tutorials/03_european_call_option_pricing.ipynb:165
#: ../../tutorials/04_european_put_option_pricing.ipynb:176
#: ../../tutorials/05_bull_spread_pricing.ipynb:164
#: ../../tutorials/06_basket_option_pricing.ipynb:178
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:195
msgid "\\sin^2( \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + \\pi/4) \\approx \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + 1/2\n\n"
msgstr "\\sin^2( \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + \\pi/4) \\approx \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + 1/2\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:167
#: ../../tutorials/04_european_put_option_pricing.ipynb:178
#: ../../tutorials/06_basket_option_pricing.ipynb:180
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:197
msgid "\\ for small :math:`c_\\text{approx}`."
msgstr "\\ for small :math:`c_\\text{approx}`."

#: ../../tutorials/03_european_call_option_pricing.ipynb:169
#: ../../tutorials/04_european_put_option_pricing.ipynb:180
#: ../../tutorials/05_bull_spread_pricing.ipynb:168
#: ../../tutorials/06_basket_option_pricing.ipynb:182
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:199
msgid "We can easily construct an operator that acts as"
msgstr "Şu şekilde davranan bir operatörü kolayca oluşturabiliriz"

#: ../../tutorials/03_european_call_option_pricing.ipynb:171
#: ../../tutorials/04_european_put_option_pricing.ipynb:182
#: ../../tutorials/05_bull_spread_pricing.ipynb:170
#: ../../tutorials/06_basket_option_pricing.ipynb:184
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:201
msgid "\\big|x\\rangle \\big|0\\rangle \\mapsto \\big|x\\rangle \\left( \\cos(a*x+b) \\big|0\\rangle + \\sin(a*x+b) \\big|1\\rangle \\right),\n\n"
msgstr "\\big|x\\rangle \\big|0\\rangle \\mapsto \\big|x\\rangle \\left( \\cos(a*x+b) \\big|0\\rangle + \\sin(a*x+b) \\big|1\\rangle \\right),\n\n"

#: ../../tutorials/03_european_call_option_pricing.ipynb:173
#: ../../tutorials/04_european_put_option_pricing.ipynb:184
#: ../../tutorials/05_bull_spread_pricing.ipynb:172
#: ../../tutorials/06_basket_option_pricing.ipynb:186
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:203
msgid "using controlled Y-rotations."
msgstr "kontrollü Y-rotasyonları kullanarak."

#: ../../tutorials/03_european_call_option_pricing.ipynb:175
#: ../../tutorials/04_european_put_option_pricing.ipynb:186
#: ../../tutorials/05_bull_spread_pricing.ipynb:174
#: ../../tutorials/06_basket_option_pricing.ipynb:188
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:205
msgid "Eventually, we are interested in the probability of measuring :math:`\\big|1\\rangle` in the last qubit, which corresponds to :math:`\\sin^2(a*x+b)`. Together with the approximation above, this allows to approximate the values of interest. The smaller we choose :math:`c_\\text{approx}`, the better the approximation. However, since we are then estimating a property scaled by :math:`c_\\text{approx}`, the number of evaluation qubits :math:`m` needs to be adjusted accordingly."
msgstr "Sonunda, :math:`\\sin^2(a*x+b)`ye karşılık gelen son kübitte :math:`\\big|1\\rangle`yi ölçme olasılığıyla ilgileniyoruz. Yukarıdaki yaklaştırımla birlikte, bu, ilgilenilen değerlerin yaklaşık olarak tahmin edilmesine izin vermektedir. :math:`c_\\text{approx}`u ne kadar küçük seçersek, yaklaşım o kadar iyi olur. Bununla birlikte, daha sonra :math:`c_\\text{approx}` ile ölçeklenen bir özelliği tahmin ettiğimiz için, değerlendirme kübit sayısı :math:`m`nin buna göre ayarlanması gerekir."

#: ../../tutorials/03_european_call_option_pricing.ipynb:177
msgid "For more details on the approximation, we refer to: `Quantum Risk Analysis. Woerner, Egger. 2018. <https://www.nature.com/articles/s41534-019-0130-6>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:376
#: ../../tutorials/04_european_put_option_pricing.ipynb:306
#: ../../tutorials/05_bull_spread_pricing.ipynb:295
#: ../../tutorials/06_basket_option_pricing.ipynb:417
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:612
#: ../../tutorials/10_qgan_option_pricing.ipynb:95
#: ../../tutorials/10_qgan_option_pricing.ipynb:191
msgid "Evaluate Expected Payoff"
msgstr "Beklenen Getirileri Değerlendir"

#: ../../tutorials/03_european_call_option_pricing.ipynb:537
msgid "Instead of constructing these circuits manually, Qiskit’s finance module offers the ``EuropeanCallPricing`` circuit, which already implements this functionality as building block."
msgstr "Bu devreleri manuel olarak oluşturmak yerine, Qiskit'in finans modülü bu işlevi hali hazırda yapı taşı olarak uygulayan ``EuropeanCallPricing`` devresini sunmaktadır."

#: ../../tutorials/03_european_call_option_pricing.ipynb:611
#: ../../tutorials/04_european_put_option_pricing.ipynb:383
#: ../../tutorials/05_bull_spread_pricing.ipynb:372
msgid "Evaluate Delta"
msgstr "Delta'yı Değerlendir"

#: ../../tutorials/03_european_call_option_pricing.ipynb:613
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use a comparator circuit and an ancilla qubit to identify the cases where :math:`S_T > K`. However, since we are only interested in the probability of this condition being true, we can directly use this ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr "Delta'yı değerlendirmek, beklenen getiriden biraz daha basittir. Beklenen getiriye benzer şekilde, :math:`S_T > K`'nın bulunduğu durumları tanımlamak için bir karşılaştırıcı devre ve bir yardımcı kübit kullanıyoruz. Bununla birlikte, sadece bu koşulun doğru olma olasılığıyla ilgilendiğimiz için, bu yardımcı kübiti, daha fazla yaklaşıma gerek olmadan, genlik tahmininde hedef kübit olarak doğrudan kullanabiliriz."

#: ../../tutorials/04_european_put_option_pricing.ipynb:9
msgid "Pricing European Put Options"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:23
msgid "Suppose a European put option with strike price :math:`K` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr "Kullanım fiyatı :math:`K` olan bir Avrupa satım opsiyonu ve :math:`S_T` vadesindeki spot fiyatı belirli bir rasgele dağılımı izleyen bir dayanak varlık varsayalım. Karşılık gelen getiri fonksiyonu şu şekilde tanımlanır:"

#: ../../tutorials/04_european_put_option_pricing.ipynb:25
msgid "\\max\\{K - S_T, 0\\}\n\n"
msgstr "\\max\\{K - S_T, 0\\}\n\n"

#: ../../tutorials/04_european_put_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{K - S_T, 0\\} \\right]\n\n"
msgstr "\\mathbb{E}\\left[ \\max\\{K - S_T, 0\\} \\right]\n\n"

#: ../../tutorials/04_european_put_option_pricing.ipynb:33
msgid "\\Delta = -\\mathbb{P}\\left[S_T \\leq K\\right]"
msgstr "\\Delta = -\\mathbb{P}\\left[S_T \\leq K\\right]"

#: ../../tutorials/04_european_put_option_pricing.ipynb:40
#: ../../tutorials/05_bull_spread_pricing.ipynb:40
#: ../../tutorials/06_basket_option_pricing.ipynb:33
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:46
msgid "`Quantum Risk Analysis. Woerner, Egger. 2018. <https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:41
#: ../../tutorials/05_bull_spread_pricing.ipynb:41
#: ../../tutorials/06_basket_option_pricing.ipynb:34
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:47
msgid "`Option Pricing using Quantum Computers. Stamatopoulos et al. 2019. <https://arxiv.org/abs/1905.02666>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:172
msgid "The payoff function decreases linearly with an increasing spot price at maturity :math:`S_T` until it reaches zero for a spot price equal to the strike price :math:`K`, it stays constant to zero for larger spot prices. The implementation uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\leq K`, and this ancilla is used to control the linear part of the payoff function."
msgstr "Getiri fonksiyonu, :math:`S_T` vadesinde artan bir spot fiyatla, kullanım fiyatı :math:`K`'ya eşit bir spot fiyat için sıfıra ulaşana kadar doğrusal olarak azalır, daha büyük spot fiyatlar için sıfıra sabit kalır. Uygulama, :math:`S_T \\leq K` ise bir yardımcı kübiti :math:`\\big|0\\rangle`'dan :math:`\\big|1\\rangle`'e çeviren bir karşılaştırıcı kullanır ve bu yardımcı, getiri fonksiyonunun doğrusal kısmını kontrol etmek için kullanılır."

#: ../../tutorials/04_european_put_option_pricing.ipynb:174
msgid "The linear part itself is then approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling scaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr "Doğrusal kısma şu şekilde bir yaklaşımda bulunabiliriz. Küçük :math:`|y|` için :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` durumundan faydalanabiliriz. Böylece, verilen ölçeklendirme katsayısı :math:`c_\\text{approx} \\in [0, 1]` ve :math:`x \\in [0, 1]` için aşağıdakini dikkate alırız"

#: ../../tutorials/04_european_put_option_pricing.ipynb:188
#: ../../tutorials/05_bull_spread_pricing.ipynb:176
#: ../../tutorials/06_basket_option_pricing.ipynb:190
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:207
msgid "For more details on the approximation, we refer to: `Quantum Risk Analysis. Woerner, Egger. 2018. <https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:385
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use a comparator circuit and an ancilla qubit to identify the cases where :math:`S_T \\leq K`. However, since we are only interested in the (negative) probability of this condition being true, we can directly use this ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr "Delta'yı değerlendirmek, beklenen getiriden biraz daha basittir. Beklenen getiriye benzer şekilde, :math:`S_T \\leq K`'nın bulunduğu durumları tanımlamak için bir karşılaştırıcı devre ve bir yardımcı kübit kullanıyoruz. Bununla birlikte, sadece bu koşulun doğru olma olasılığıyla (negatif) ilgilendiğimiz için, bu yardımcı kübiti, daha fazla yaklaşıma gerek olmadan, genlik tahmininde hedef kübit olarak doğrudan kullanabiliriz."

#: ../../tutorials/05_bull_spread_pricing.ipynb:9
msgid "Pricing Bull Spreads"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:23
msgid "Suppose a `bull spread <http://www.theoptionsguide.com/bull-call-spread.aspx>`__ with strike prices :math:`K_1 < K_2` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:25
msgid "\\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\}\n\n"
msgstr "\\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\}\n\n"

#: ../../tutorials/05_bull_spread_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\} \\right]\n\n"
msgstr "\\mathbb{E}\\left[ \\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\} \\right]\n\n"

#: ../../tutorials/05_bull_spread_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[K_1 \\leq S \\leq K_2\\right]"
msgstr "\\Delta = \\mathbb{P}\\left[K_1 \\leq S \\leq K_2\\right]"

#: ../../tutorials/05_bull_spread_pricing.ipynb:160
msgid "The payoff function equals zero as long as the spot price at maturity :math:`S_T` is less than the strike price :math:`K_1`, then increases linearly, and is bounded by :math:`K_2`. The implementation uses two comparators, that flip an ancilla qubit each from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\geq K_1` and :math:`S_T \\leq K_2`, and these ancillas are used to control the linear part of the payoff function."
msgstr ":math:`S_T` vadesindeki spot fiyat, kullanım fiyatı :math:`K_1`den düşük olduğu sürece, getiri fonksiyonu sıfıra eşittir. Sonrasında da doğrusal olarak artış gösterir ve :math:`K_2` ile sınırlıdır. Uygulama, eğer :math:`S_T \\geq K_1` ve :math:`S_T \\leq K_2` ise, her biri için bir yardımcı kübiti :math:`\\big|0\\rangle`dan :math:`\\big|1\\rangle`e çeviren iki karşılaştırıcı kullanır ve bu yardımcılar, getiri fonksiyonunun doğrusal kısmını kontrol etmek için kullanılır."

#: ../../tutorials/05_bull_spread_pricing.ipynb:166
msgid "for small :math:`c_\\text{approx}`."
msgstr "küçük :math:`c_\\text{approx}` için."

#: ../../tutorials/05_bull_spread_pricing.ipynb:374
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use comparator circuits and ancilla qubits to identify the cases where :math:`K_1 \\leq S_T \\leq K_2`. However, since we are only interested in the probability of this condition being true, we can directly use an ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr "Delta'yı değerlendirmek, beklenen getiriden biraz daha basittir. Beklenen getiriye benzer şekilde, :math:`K_1 \\leq S_T \\leq K_2`'nın bulunduğu durumları tanımlamak için karşılaştırıcı devreler ve yardımcı kübitler kullanıyoruz. Bununla birlikte, sadece bu koşulun doğru olma olasılığıyla ilgilendiğimiz için, bu yardımcı kübiti, daha fazla yaklaşıma gerek olmadan, genlik tahmininde hedef kübit olarak doğrudan kullanabiliriz."

#: ../../tutorials/06_basket_option_pricing.ipynb:9
msgid "Pricing Basket Options"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:23
msgid "Suppose a basket option with strike price :math:`K` and two underlying assets whose spot price at maturity :math:`S_T^1`, :math:`S_T^2` follow given random distributions. The corresponding payoff function is defined as:"
msgstr "Kullanım fiyatı :math:`K` olan bir sepet opsiyonu ve :math:`S_T^1`, :math:`S_T^2` vadelerindeki spot fiyatları belirli bir rasgele dağılımı izleyen iki dayanak varlık varsayalım. Karşılık gelen getiri fonksiyonu şu şekilde tanımlanır:"

#: ../../tutorials/06_basket_option_pricing.ipynb:25
msgid "\\max\\{S_T^1 + S_T^2 - K, 0\\}\n\n"
msgstr "\\max\\{S_T^1 + S_T^2 - K, 0\\}\n\n"

#: ../../tutorials/06_basket_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{S_T^1 + S_T^2 - K, 0\\} \\right].\n\n"
msgstr "\\mathbb{E}\\left[ \\max\\{S_T^1 + S_T^2 - K, 0\\} \\right].\n\n"

#: ../../tutorials/06_basket_option_pricing.ipynb:68
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:81
msgid "We construct a circuit factory to load a multivariate log-normal random distribution into a quantum state on :math:`n` qubits. For every dimension :math:`j = 1,\\ldots,d`, the distribution is truncated to a given interval :math:`[\\text{low}_j, \\text{high}_j]` and discretized using :math:`2^{n_j}` grid points, where :math:`n_j` denotes the number of qubits used to represent dimension :math:`j`, i.e., :math:`n_1+\\ldots+n_d = n`. The unitary operator corresponding to the circuit factory implements the following:"
msgstr ":math:`n` kübitlik bir kuantum durumuna çok değişkenli log-normal rastgele dağılımı yüklemek için bir devre fabrikası oluşturuyoruz. Her bir :math:`j = 1,\\ldots,d` boyutu için dağılım, verilen bir :math:`[\\text{low}_j, \\text{high}_j]` aralığına indirgenir ve :math:`2^{n_j}` ızgara noktası kullanılarak ayıştırılır. Burada :math:`n_j`, :math:`j`, yani, :math:`n_1+\\ldots+n_d = n` boyutunu temsil etmek için kulanılan kübit sayısını belirtir. Devre fabrikasına karşılık gelen üniter operatör aşağıdakini uygular:"

#: ../../tutorials/06_basket_option_pricing.ipynb:71
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:84
msgid "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i_1,\\ldots,i_d} \\sqrt{p_{i_1\\ldots i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"
msgstr "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i_1,\\ldots,i_d} \\sqrt{p_{i_1\\ldots i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"

#: ../../tutorials/06_basket_option_pricing.ipynb:73
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:86
msgid "where :math:`p_{i_1\\ldots i_d}` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i_j` is mapped to the right interval using the affine map:"
msgstr "burada :math:`p_{i_1\\ldots i_d}` indirgenmiş ve ayrıştırılmış dağılıma karşılık gelen olasılıkları belirtmektedir ve :math:`i_j` afin harita kullanılarak doğru aralık ile eşlenmektedir:"

#: ../../tutorials/06_basket_option_pricing.ipynb:75
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:88
msgid "\\{0, \\ldots, 2^{n_j}-1\\} \\ni i_j \\mapsto \\frac{\\text{high}_j - \\text{low}_j}{2^{n_j} - 1} * i_j + \\text{low}_j \\in [\\text{low}_j, \\text{high}_j].\n\n"
msgstr "\\{0, \\ldots, 2^{n_j}-1\\} \\ni i_j \\mapsto \\frac{\\text{high}_j - \\text{low}_j}{2^{n_j} - 1} * i_j + \\text{low}_j \\in [\\text{low}_j, \\text{high}_j].\n\n"

#: ../../tutorials/06_basket_option_pricing.ipynb:77
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:90
msgid "For simplicity, we assume both stock prices are independent and identically distributed. This assumption just simplifies the parametrization below and can be easily relaxed to more complex and also correlated multivariate distributions. The only important assumption for the current implementation is that the discretization grid of the different dimensions has the same step size."
msgstr "Basitleştirmek adına, her iki hisse senedi fiyatının da bağımsız ve aynı şekilde dağılmış olduğunu varsayıyoruz. Bu varsayım, aşağıdaki parametrik hale getirme işlemini basitleştirmektedir ve daha karmaşık ve aynı zamanda birbiriyle ilişkili çok değişkenli dağılımlara kolayca esnetilebilmektedir. Mevcut uygulama için tek önemli varsayım, farklı boyutların ayrıştırma ızgarasının aynı adım büyüklüğüne sahip olmasıdır."

#: ../../tutorials/06_basket_option_pricing.ipynb:173
msgid "The payoff function equals zero as long as the sum of the spot prices at maturity :math:`(S_T^1 + S_T^2)` is less than the strike price :math:`K` and then increases linearly. The implementation first uses a weighted sum operator to compute the sum of the spot prices into an ancilla register, and then uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_T^1 + S_T^2) \\geq K`. This ancilla is used to control the linear part of the payoff function."
msgstr ":math:`(S_T^1 + S_T^2)` vadesindeki spot fiyatların toplamı, kullanım fiyatı :math:`K`den düşük olduğu sürece, getiri fonksiyonu sıfıra eşittir. Sonrasında da doğrusal olarak artış gösterir. Uygulama ilk önce spot fiyatların toplamını yardımcı bir yazmaçta hesaplamak için ağırlıklı toplam operatörü kullanır. Ardından, :math:`(S_T^1 + S_T^2) \\geq K` ise, yardımcı bir kübiti :math:`\\big|0\\rangle`dan :math:`\\big|1\\rangle`e çeviren bir karşılaştırıcı kullanır. Bu yardımcı, getiri fonksiyonunun doğrusal kısmını kontrol etmek için kullanılır."

#: ../../tutorials/06_basket_option_pricing.ipynb:176
msgid "The linear part itself is approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr "Doğrusal kısma şu şekilde bir yaklaşımda bulunabiliriz. Küçük :math:`|y|` için :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` durumundan faydalanabiliriz. Böylece, verilen yaklaştırım ölçeklendirme katsayısı :math:`c_\\text{approx} \\in [0, 1]` ve :math:`x \\in [0, 1]` için aşağıdakini dikkate alırız"

#: ../../tutorials/06_basket_option_pricing.ipynb:192
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:209
msgid "Since the weighted sum operator (in its current implementation) can only sum up integers, we need to map from the original ranges to the representable range to estimate the result, and reverse this mapping before interpreting the result. The mapping essentially corresponds to the affine mapping described in the context of the uncertainty model above."
msgstr "Ağırlıklı toplam operatörü (mevcut uygulamasında olan) yalnızca tam sayıları toplayabileceğinden, sonucu tahmin etmek için orijinal aralıklardan temsil edilebilir aralığa eşleştirmemiz ve sonucu yorumlamadan önce bu eşleştirmeyi tersine çevirmemiz gerekmektedir. Eşleme, esasen, yukarıdaki belirsizlik modeli bağlamında açıklanan afin eşlemeye karşılık gelir."

#: ../../tutorials/06_basket_option_pricing.ipynb:419
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:614
msgid "We first verify the quantum circuit by simulating it and analyzing the resulting probability to measure the :math:`|1\\rangle` state in the objective qubit."
msgstr "Kuantum devresini simüle edip ortaya çıkan nesnel kübitteki :math:`|1\\rangle` durumunun ölçülme olasılığını analiz ederek önce devreyi doğrularız."

#: ../../tutorials/06_basket_option_pricing.ipynb:522
msgid "Next we use amplitude estimation to estimate the expected payoff."
msgstr "Ardından genlik tahminini kullanarak getiri fonksiyonunu tahmin ederiz."

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:9
msgid "Pricing Asian Barrier Spreads"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:23
msgid "An Asian barrier spread is a combination of 3 different option types, and as such, combines multiple possible features that the Qiskit Finance option pricing framework supports:"
msgstr "Bir Asya bariyer yayılımı 3 farklı opsiyon tipinin birleşimidir. Bu bakımdan Qiskit Finance opsiyon fiyatlaması çerçevesinin desteklediği birçok olası özelliği birleştirir:"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:25
msgid "`Asian option <https://www.investopedia.com/terms/a/asianoption.asp>`__: The payoff depends on the average price over the considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:26
msgid "`Barrier Option <https://www.investopedia.com/terms/b/barrieroption.asp>`__: The payoff is zero if a certain threshold is exceeded at any time within the considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:27
msgid "`(Bull) Spread <https://www.investopedia.com/terms/b/bullspread.asp>`__: The payoff follows a piecewise linear function (depending on the average price) starting at zero, increasing linear, staying constant."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:29
msgid "Suppose strike prices :math:`K_1 < K_2` and time periods :math:`t=1,2`, with corresponding spot prices :math:`(S_1, S_2)` following a given multivariate distribution (e.g. generated by some stochastic process), and a barrier threshold :math:`B>0`. The corresponding payoff function is defined as"
msgstr "Kullanım fiyatlarını :math:`K_1 < K_2` ve zaman periyotlarını :math:`t=1,2`, bunlara karşılık gelen, verilen çok değişkenli bir dağılımını izleyen spot fiyatlarını :math:`(S_1, S_2)` (örneğin herhangi bir stokastik süreç tarafından üretilen) ve bariyer eşiğini :math:`B>0` varsayalım. Karşılık gelen getiri fonksiyonu şu şekilde tanımlanır"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:31
msgid "P(S_1, S_2) =\n"
"\\begin{cases}\n"
"\\min\\left\\{\\max\\left\\{\\frac{1}{2}(S_1 + S_2) - K_1, 0\\right\\}, K_2 - K_1\\right\\}, & \\text{ if } S_1, S_2 \\leq B \\\\\n"
"0, & \\text{otherwise.}\n"
"\\end{cases}"
msgstr "P(S_1, S_2) =\n"
"\\begin{cases}\n"
"\\min\\left\\{\\max\\left\\{\\frac{1}{2}(S_1 + S_2) - K_1, 0\\right\\}, K_2 - K_1\\right\\}, & \\text{ if } S_1, S_2 \\leq B \\\\\n"
"0, & \\text{otherwise.}\n"
"\\end{cases}"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:40
msgid "In the following, a quantum algorithm based on amplitude estimation is used to estimate the expected payoff, i.e., the fair price before discounting, for the option"
msgstr "Aşağıda, beklenen getiriyi, yani indirimden önceki adil fiyatı tahmin etmek için genlik tahminine dayalı bir kuantum algoritması kullanılmaktadır"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:42
msgid "\\mathbb{E}\\left[ P(S_1, S_2) \\right].\n\n"
msgstr "\\mathbb{E}\\left[ P(S_1, S_2) \\right].\n\n"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:186
msgid "For simplicity, we consider the sum of the spot prices instead of their average. The result can be transformed to the average by just dividing it by 2."
msgstr "Basitleştirmek adına, ortalamaları yerine spot fiyatların toplamını dikkate alıyoruz. Sonuç sadece 2'ye bölünerek ortalamaya dönüştürülebilir."

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:188
msgid "The payoff function equals zero as long as the sum of the spot prices :math:`(S_1 + S_2)` is less than the strike price :math:`K_1` and then increases linearly until the sum of the spot prices reaches :math:`K_2`. Then payoff stays constant to :math:`K_2 - K_1` unless any of the two spot prices exceeds the barrier threshold :math:`B`, then the payoff goes immediately down to zero. The implementation first uses a weighted sum operator to compute the sum of the spot prices into an ancilla register, and then uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_1 + S_2) \\geq K_1` and another comparator/ancilla to capture the case that :math:`(S_1 + S_2) \\geq K_2`. These ancillas are used to control the linear part of the payoff function."
msgstr ":math:`(S_1 + S_2)` spot fiyatların toplamı, kullanım fiyatı :math:`K_1`den düşük olduğu sürece, getiri fonksiyonu sıfıra eşittir. Sonrasında da spot fiyatların toplamı :math:`K_2` ulaşana kadar doğrusal olarak artış gösterir. Daha sonra iki spot fiyattan biri :math:`B` bariyer eşiğini geçmediği sürece getiri, :math:`K_2 - K_1`e sabit kalır, ardından getiri hemen sıfıra düşer. Uygulama ilk önce spot fiyatların toplamını yardımcı bir yazmaçta hesaplamak için ağırlıklı toplam operatörü kullanır. Ardından, :math:`(S_1 + S_2) \\geq K_1` ise, yardımcı bir kübiti :math:`\\big|0\\rangle`'dan :math:`\\big|1\\rangle`e çeviren bir karşılaştırıcı kullanır. :math:`(S_1 + S_2) \\geq K_2` durumunu tutmak için de başka bir karşılaştırıcı/yardımcı kullanır. Bu yardımcılar, getiri fonksiyonunun doğrusal kısmını kontrol etmek için kullanılır."

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:191
msgid "In addition, we add another ancilla variable for each time step and use additional comparators to check whether :math:`S_1`, respectively :math:`S_2`, exceed the barrier threshold :math:`B`. The payoff function is only applied if :math:`S_1, S_2 \\leq B`."
msgstr "Buna ek olarak, her bir zaman adımı için başka bir yardımcı değişken ekliyoruz ve sırasıyla :math:`S_1`, :math:`S_2`'in bariyer eşiği :math:`B`'yi geçip geçmediğini kontrol etmek için ek karşılaştırıcılar kullanıyoruz. Getiri fonksiyonu yalnızca :math:`S_1, S_2 \\leq B` ise uygulanır."

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:193
msgid "The linear part itself is approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation scaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr "Doğrusal kısma şu şekilde bir yaklaşımda bulunabiliriz. Küçük :math:`|y|` için :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` durumundan faydalanabiliriz. Böylece, verilen yaklaştırım ölçeklendirme katsayısı :math:`c_\\text{approx} \\in [0, 1]` ve :math:`x \\in [0, 1]` için aşağıdakini dikkate alırız"

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:720
msgid "Next we use amplitude estimation to estimate the expected payoff. Note that this can take a while since we are simulating a large number of qubits. The way we designed the operator (asian_barrier_spread) implies that the number of actual state qubits is significantly smaller, thus, helping to reduce the overall simulation time a bit."
msgstr "Ardından genlik tahminini kullanarak getiri fonksiyonunu tahmin ediyoruz. Çok sayıda kübiti simüle ettiğimiz için bunun biraz zaman alabileceğini unutmayın. Operatörü (asian_barrier_spread) tasarlama şeklimiz, gerçek durum kübitlerinin sayısının önemli ölçüde daha küçük olduğunu belirtir. Bu da toplam simülasyon süresini bir miktar azaltmaya yardımcı olur."

#: ../../tutorials/08_fixed_income_pricing.ipynb:9
msgid "Pricing Fixed-Income Assets"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:23
msgid "We seek to price a fixed-income asset knowing the distributions describing the relevant interest rates. The cash flows :math:`c_t` of the asset and the dates at which they occur are known. The total value :math:`V` of the asset is thus the expectation value of:"
msgstr "İlgili faiz oranlarını tanımlayan dağılımları bilerek sabit getirili bir varlığı fiyatlandırmaya çalışıyoruz. Varlığın nakit akışları :math:`c_t` ve bunların oluştuğu tarihler bilinmektedir. Varlığın toplam değeri :math:`V` bu nedenle aşağıdakilerin beklenen değeridir:"

#: ../../tutorials/08_fixed_income_pricing.ipynb:25
msgid "V = \\sum_{t=1}^T \\frac{c_t}{(1+r_t)^t}\n\n"
msgstr "V = \\sum_{t=1}^T \\frac{c_t}{(1+r_t)^t}\n\n"

#: ../../tutorials/08_fixed_income_pricing.ipynb:27
msgid "Each cash flow is treated as a zero coupon bond with a corresponding interest rate :math:`r_t` that depends on its maturity. The user must specify the distribution modeling the uncertainty in each :math:`r_t` (possibly correlated) as well as the number of qubits he wishes to use to sample each distribution. In this example we expand the value of the asset to first order in the interest rates :math:`r_t`. This corresponds to studying the asset in terms of its duration. The approximation of the objective function follows the following paper: `Quantum Risk Analysis. Woerner, Egger. 2018. <https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:68
msgid "We construct a circuit factory to load a multivariate normal random distribution in :math:`d` dimensions into a quantum state. The distribution is truncated to a given box :math:`\\otimes_{i=1}^d [low_i, high_i]` and discretized using :math:`2^{n_i}` grid points, where :math:`n_i` denotes the number of qubits used for dimension :math:`i = 1,\\ldots, d`. The unitary operator corresponding to the circuit factory implements the following:"
msgstr "Bir kuantum durumuna :math:`d` boyutlarında çok değişkenli log-normal rastgele dağılımı yüklemek için bir devre fabrikası oluşturuyoruz. Dağılım, verilen bir :math:`\\otimes_{i=1}^d [low_i, high_i]` kutuya indirgenir ve :math:`2^{n_i}` ızgara noktası kullanılarak ayrıştırılır. Burada :math:`n_i`, :math:`i = 1,\\ldots, d` boyutunu temsil etmek için kulanılan kübit sayısını belirtir. Devre fabrikasına karşılık gelen üniter operatör aşağıdakini uygular:"

#: ../../tutorials/08_fixed_income_pricing.ipynb:70
msgid "\\big|0\\rangle_{n_1}\\ldots\\big|0\\rangle_{n_d} \\mapsto \\big|\\psi\\rangle = \\sum_{i_1=0}^{2^n_-1}\\ldots\\sum_{i_d=0}^{2^n_-1} \\sqrt{p_{i_1,...,i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"
msgstr "\\big|0\\rangle_{n_1}\\ldots\\big|0\\rangle_{n_d} \\mapsto \\big|\\psi\\rangle = \\sum_{i_1=0}^{2^n_-1}\\ldots\\sum_{i_d=0}^{2^n_-1} \\sqrt{p_{i_1,...,i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"

#: ../../tutorials/08_fixed_income_pricing.ipynb:72
msgid "where :math:`p_{i_1, ..., i_d}` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i_j` is mapped to the right interval :math:`[low_j, high_j]` using the affine map:"
msgstr "burada :math:`p_{i_1, ..., i_d}` indirgenmiş ve ayrıştırılmış dağılıma karşılık gelen olasılıkları belirtmektedir ve :math:`i_j` afin harita kullanılarak :math:`[low_j, high_j]` doğru aralığına eşlenmektedir:"

#: ../../tutorials/08_fixed_income_pricing.ipynb:74
msgid "\\{0, \\ldots, 2^{n_{j}}-1\\} \\ni i_j \\mapsto \\frac{high_j - low_j}{2^{n_j} - 1} * i_j + low_j \\in [low_j, high_j].\n\n"
msgstr "\\{0, \\ldots, 2^{n_{j}}-1\\} \\ni i_j \\mapsto \\frac{high_j - low_j}{2^{n_j} - 1} * i_j + low_j \\in [low_j, high_j].\n\n"

#: ../../tutorials/08_fixed_income_pricing.ipynb:76
msgid "In addition to the uncertainty model, we can also apply an affine map, e.g. resulting from a principal component analysis. The interest rates used are then given by:"
msgstr "Belirsizlik modeline ek olarak, bir afin harita da uygulayabiliriz (örneğin, temel bileşen analizinden elde edilir). Kullanılan faiz oranları daha sonra şu şekilde verilir:"

#: ../../tutorials/08_fixed_income_pricing.ipynb:78
msgid "\\vec{r} = A * \\vec{x} + b,\n\n"
msgstr "\\vec{r} = A * \\vec{x} + b,\n\n"

#: ../../tutorials/08_fixed_income_pricing.ipynb:80
msgid "where :math:`\\vec{x} \\in \\otimes_{i=1}^d [low_i, high_i]` follows the given random distribution."
msgstr ":math:`\\vec{x} \\in \\otimes_{i=1}^d [low_i, high_i]` verilen rasgele dağılımı izler."

#: ../../tutorials/08_fixed_income_pricing.ipynb:155
msgid "Cash flow, payoff function, and exact expected value"
msgstr "Nakit akışı, getiri fonksiyonu ve tam beklenen değer"

#: ../../tutorials/08_fixed_income_pricing.ipynb:157
msgid "In the following we define the cash flow per period, the resulting payoff function and evaluate the exact expected value."
msgstr "Aşağıda dönem başına nakit akışını, sonuçta ortaya çıkan getiri fonksiyonunu tanımlıyor ve tam beklenen değeri değerlendiriyoruz."

#: ../../tutorials/08_fixed_income_pricing.ipynb:159
msgid "For the payoff function we first use a first order approximation and then apply the same approximation technique as for the linear part of the payoff function of the `European Call Option <03_european_call_option_pricing.ipynb>`__."
msgstr "Getiri fonksiyonu için, ilk olarak birinci dereceden bir yaklaşım kullanırız ve daha sonra, `European Call Option <03_european_call_option_pricing.ipynb>`__ 'in getiri fonksiyonunun doğrusal kısmı için olduğu gibi aynı yaklaşım tekniğini uygularız."

#: ../../tutorials/09_credit_risk_analysis.ipynb:9
msgid "Credit Risk Analysis"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:23
msgid "This tutorial shows how quantum algorithms can be used for credit risk analysis. More precisely, how Quantum Amplitude Estimation (QAE) can be used to estimate risk measures with a quadratic speed-up over classical Monte Carlo simulation. The tutorial is based on the following papers:"
msgstr "Bu eğitim belgesi, kuantum algoritmalarının kredi risk analizi için nasıl kullanılabileceğini gösterir. Daha iyi anlatmak gerekirse, klasik Monte Carlo simülasyonlarına karşılık kuadratik bir hızlanma ile risk ölçümlerini tahmin etmek için Kuantum Genlik Tahmini (QAE)'nin nasıl kullanılabileceğini gösterir. Eğitsel aşağıdaki makalelere dayanmaktadır:"

#: ../../tutorials/09_credit_risk_analysis.ipynb:25
msgid "`Quantum Risk Analysis. Stefan Woerner, Daniel J. Egger. <https://www.nature.com/articles/s41534-019-0130-6>`__ [Woerner2019]"
msgstr "`Quantum Risk Analysis. Stefan Woerner, Daniel J. Egger. <https://www.nature.com/articles/s41534-019-0130-6>`__ [Woerner2019]"

#: ../../tutorials/09_credit_risk_analysis.ipynb:26
msgid "`Credit Risk Analysis using Quantum Computers. Egger et al. (2019) <https://arxiv.org/abs/1907.03044>`__ [Egger2019]"
msgstr "`Credit Risk Analysis using Quantum Computers. Egger et al. (2019) <https://arxiv.org/abs/1907.03044>`__ [Egger2019]"

#: ../../tutorials/09_credit_risk_analysis.ipynb:28
msgid "A general introduction to QAE can be found in the following paper:"
msgstr "QAE'ye genel bir giriş şu makalede bulunabilir:"

#: ../../tutorials/09_credit_risk_analysis.ipynb:30
msgid "`Quantum Amplitude Amplification and Estimation. Gilles Brassard et al. <http://arxiv.org/abs/quant-ph/0005055>`__"
msgstr "`Quantum Amplitude Amplification and Estimation. Gilles Brassard et al. <http://arxiv.org/abs/quant-ph/0005055>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:32
msgid "The structure of the tutorial is as follows:"
msgstr "Dersin yapısı şu şekildedir:"

#: ../../tutorials/09_credit_risk_analysis.ipynb:34
msgid "`Problem Definition <#Problem-Definition>`__"
msgstr "`Problem Definition <#Problem-Definition>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:35
msgid "`Uncertainty Model <#Uncertainty-Model>`__"
msgstr "`Uncertainty Model <#Uncertainty-Model>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:36
msgid "`Expected Loss <#Expected-Loss>`__"
msgstr "`Expected Loss <#Expected-Loss>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:37
msgid "`Cumulative Distribution Function <#Cumulative-Distribution-Function>`__"
msgstr "`Cumulative Distribution Function <#Cumulative-Distribution-Function>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:38
msgid "`Value at Risk <#Value-at-Risk>`__"
msgstr "`Value at Risk <#Value-at-Risk>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:39
msgid "`Conditional Value at Risk <#Conditional-Value-at-Risk>`__"
msgstr "`Conditional Value at Risk <#Conditional-Value-at-Risk>`__"

#: ../../tutorials/09_credit_risk_analysis.ipynb:67
msgid "Problem Definition"
msgstr "Problem Tanımı"

#: ../../tutorials/09_credit_risk_analysis.ipynb:69
msgid "In this tutorial we want to analyze the credit risk of a portfolio of :math:`K` assets. The default probability of every asset :math:`k` follows a *Gaussian Conditional Independence* model, i.e., given a value :math:`z` sampled from a latent random variable :math:`Z` following a standard normal distribution, the default probability of asset :math:`k` is given by"
msgstr "Bu eğitim belgesinde, :math:`K` varlıktan oluşan bir portföyün kredi riskini analiz etmek istiyoruz. Her varlığın varsayılan olasılığı :math:`k`, bir *Gauss Koşullu Bağımsızlık* modelini takip eder, yani standart bir normal dağılımın ardından gizli bir rastgele değişken :math:`Z`den örneklenen bir :math:`z` değeri verildiğinde, varlığın varsayılan olasılığı :math:`k` aşağıdaki gibi verilir"

#: ../../tutorials/09_credit_risk_analysis.ipynb:71
msgid "p_k(z) = F\\left( \\frac{F^{-1}(p_k^0) - \\sqrt{\\rho_k}z}{\\sqrt{1 - \\rho_k}} \\right)\n\n"
msgstr "p_k(z) = F\\left( \\frac{F^{-1}(p_k^0) - \\sqrt{\\rho_k}z}{\\sqrt{1 - \\rho_k}} \\right)\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:73
msgid "where :math:`F` denotes the cumulative distribution function of :math:`Z`, :math:`p_k^0` is the default probability of asset :math:`k` for :math:`z=0` and :math:`\\rho_k` is the sensitivity of the default probability of asset :math:`k` with respect to :math:`Z`. Thus, given a concrete realization of :math:`Z` the individual default events are assumed to be independent from each other."
msgstr "burada :math:`F`, :math:`Z`nin kümülatif dağılım fonksiyonunu belirtir, :math:`p_k^0`, :math:`z=0` için :math:`k` varlığının varsayılan olasılığıdır ve :math:`\\rho_k`, :math:`k` öğesinin varsayılan olasılığının :math:`Z`ye göre duyarlılığıdır. Böylece, :math:`Z`nin somut bir şekilde gerçekleşmesi göz önüne alındığında, her bir varsayılan olayın birbirinden bağımsız olduğu varsayılır."

#: ../../tutorials/09_credit_risk_analysis.ipynb:75
msgid "We are interested in analyzing risk measures of the total loss"
msgstr "Toplam kaybın risk ölçümlerini analiz etmekle ilgileniyoruz"

#: ../../tutorials/09_credit_risk_analysis.ipynb:77
msgid "L = \\sum_{k=1}^K \\lambda_k X_k(Z)\n\n"
msgstr "L = \\sum_{k=1}^K \\lambda_k X_k(Z)\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:79
msgid "where :math:`\\lambda_k` denotes the *loss given default* of asset :math:`k`, and given :math:`Z`, :math:`X_k(Z)` denotes a Bernoulli variable representing the default event of asset :math:`k`. More precisely, we are interested in the expected value :math:`\\mathbb{E}[L]`, the Value at Risk (VaR) of :math:`L` and the Conditional Value at Risk of :math:`L` (also called Expected Shortfall). Where VaR and CVaR are defined as"
msgstr "burada :math:`\\lambda_k`, :math:`k` öğesinin *temerrüt halinde kaybını* belirtir ve :math:`Z` verildiğinde, :math:`X_k(Z)` :math:`k`nin varsayılan olayını temsil eden bir Bernoulli değişkenini belirtir. Daha doğrusu, beklenen değer :math:`\\mathbb{E}[L]`, :math:`L`nin Riske Maruz Değeri (VaR) ve :math:`L`nin Koşullu Riske Maruz Değeri (Beklenen Kayıp olarak da adlandırılır) ile ilgileniyoruz. VaR ve CVaR şu şekilde tanımlanır"

#: ../../tutorials/09_credit_risk_analysis.ipynb:81
msgid "\\text{VaR}_{\\alpha}(L) = \\inf \\{ x \\mid \\mathbb{P}[L <= x] \\geq 1 - \\alpha \\}\n\n"
msgstr "\\text{VaR}_{\\alpha}(L) = \\inf \\{ x \\mid \\mathbb{P}[L <= x] \\geq 1 - \\alpha \\}\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:83
msgid "with confidence level :math:`\\alpha \\in [0, 1]`, and"
msgstr "güven düzeyiyle :math:`\\alpha \\in [0, 1]`, and"

#: ../../tutorials/09_credit_risk_analysis.ipynb:85
msgid "\\text{CVaR}_{\\alpha}(L) = \\mathbb{E}[ L \\mid L \\geq \\text{VaR}_{\\alpha}(L) ].\n\n"
msgstr "\\text{CVaR}_{\\alpha}(L) = \\mathbb{E}[ L \\mid L \\geq \\text{VaR}_{\\alpha}(L) ].\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:87
msgid "For more details on the considered model, see, e.g., `Regulatory Capital Modeling for Credit Risk. Marek Rutkowski, Silvio Tarca <https://arxiv.org/abs/1412.1183>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:89
msgid "The problem is defined by the following parameters: - number of qubits used to represent :math:`Z`, denoted by :math:`n_z` - truncation value for :math:`Z`, denoted by :math:`z_{\\text{max}}`, i.e., Z is assumed to take :math:`2^{n_z}` equidistant values in :math:`\\{-z_{max}, ..., +z_{max}\\}` - the base default probabilities for each asset :math:`p_0^k \\in (0, 1)`, :math:`k=1, ..., K` - sensitivities of the default probabilities with respect to :math:`Z`, denoted by :math:`\\rho_k \\in [0, 1)` - loss given default for asset :math:`k`, denoted by :math:`\\lambda_k` - confidence level for VaR / CVaR :math:`\\alpha \\in [0, 1]`."
msgstr "Sorun aşağıdaki parametrelerle tanımlanır: - :math:`Z`yi temsil etmek için kullanılan kübit sayısı, :math:`n_z` ile gösterilir - :math:`Z` için kesme değeri, :math:`z_{\\text{max}}` ile gösterilir, yani Z'nin :math:`2^{n_z}` :math:`\\{-z_{max}, ..., +z_{max}\\ içinde eşit uzaklık değerleri aldığı varsayılır }` - her varlık için temel varsayılan olasılıklar :math:`p_0^k \\in (0, 1)`, :math:`k=1, ..., K` - varsayılan olasılıkların : math:`Z`, :math:`\\rho_k \\in [0, 1)` ile gösterilir - varlık :math:`k` için varsayılan olarak verilen kayıp, :math:`\\lambda_k` ile gösterilir - VaR için güven seviyesi / CVaR :math:`\\alpha \\in [0, 1]`."

#: ../../tutorials/09_credit_risk_analysis.ipynb:122
msgid "We now construct a circuit that loads the uncertainty model. This can be achieved by creating a quantum state in a register of :math:`n_z` qubits that represents :math:`Z` following a standard normal distribution. This state is then used to control single qubit Y-rotations on a second qubit register of :math:`K` qubits, where a :math:`|1\\rangle` state of qubit :math:`k` represents the default event of asset :math:`k`. The resulting quantum state can be written as"
msgstr "Şimdi belirsizlik modelini yükleyen bir devre oluşturuyoruz. Bu, standart bir normal dağılımın ardından :math:`Z`yi temsil eden :math:`n_z` kübitlerinin bir kaydında bir kuantum durumu yaratılarak başarılabilir. Bu durum daha sonra :math:`K` kübitlerinin ikinci bir kübit kaydındaki tek kübit Y-dönüşlerini kontrol etmek için kullanılır; burada :math:`|1\\rangle` qubit :math:`k` durumu varsayılan olayı temsil eder varlığın :math:`k`. Ortaya çıkan kuantum durumu şu şekilde yazılabilir"

#: ../../tutorials/09_credit_risk_analysis.ipynb:124
msgid " |\\Psi\\rangle = \\sum_{i=0}^{2^{n_z}-1} \\sqrt{p_z^i} |z_i \\rangle \\bigotimes_{k=1}^K\n"
"\\left( \\sqrt{1 - p_k(z_i)}|0\\rangle + \\sqrt{p_k(z_i)}|1\\rangle\\right),"
msgstr " |\\Psi\\rangle = \\sum_{i=0}^{2^{n_z}-1} \\sqrt{p_z^i} |z_i \\rangle \\bigotimes_{k=1}^K\n"
"\\left( \\sqrt{1 - p_k(z_i)}|0\\rangle + \\sqrt{p_k(z_i)}|1\\rangle\\right),"

#: ../../tutorials/09_credit_risk_analysis.ipynb:129
msgid "where we denote by :math:`z_i` the :math:`i`-th value of the discretized and truncated :math:`Z` [Egger2019]."
msgstr "burada ayrıklaştırılmış ve kesilmiş :math:`Z` [Egger2019] öğesinin :math:`i`-ci değerini :math:`z_i` ile belirtiriz."

#: ../../tutorials/09_credit_risk_analysis.ipynb:218
msgid "We now use the simulator to validate the circuit that constructs :math:`|\\Psi\\rangle` and compute the corresponding exact values for - expected loss :math:`\\mathbb{E}[L]` - PDF and CDF of :math:`L` - value at risk :math:`VaR(L)` and corresponding probability - conditional value at risk :math:`CVaR(L)`"
msgstr "Şimdi, :math:`|\\Psi\\rangle` açısını oluşturan devreyi doğrulamak ve karşılık gelen tam değerleri hesaplamak için simülatörü kullanıyoruz - beklenen kayıp :math:`\\mathbb{E}`\\mathbb {E}[L]` - :math:`L`-değeri risk :math:` VaR(L)` ve karşılık gelen olasılık-koşullu değer risk :math:`CVaR(L)`"

#: ../../tutorials/09_credit_risk_analysis.ipynb:435
msgid "Expected Loss"
msgstr "Beklenen Kayıp"

#: ../../tutorials/09_credit_risk_analysis.ipynb:437
msgid "To estimate the expected loss, we first apply a weighted sum operator to sum up individual losses to total loss:"
msgstr "Beklenen kaybı tahmin etmek için, önce bireysel kayıpları toplam kayıpla toplamak için ağırlıklı bir toplam operatörü uygularız:"

#: ../../tutorials/09_credit_risk_analysis.ipynb:439
msgid "\\mathcal{S}: |x_1, ..., x_K \\rangle_K |0\\rangle_{n_S} \\mapsto |x_1, ..., x_K \\rangle_K |\\lambda_1x_1 + ... + \\lambda_K x_K\\rangle_{n_S}.\n\n"
msgstr "\\mathcal{S}: |x_1, ..., x_K \\rangle_K |0\\rangle_{n_S} \\mapsto |x_1, ..., x_K \\rangle_K |\\lambda_1x_1 + ... + \\lambda_K x_K\\rangle_{n_S}.\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:441
msgid "The required number of qubits to represent the result is given by"
msgstr "Sonucu temsil etmek için gereken kübit sayısı şu şekilde verilmektedir"

#: ../../tutorials/09_credit_risk_analysis.ipynb:443
msgid "n_s = \\lfloor \\log_2( \\lambda_1 + ... + \\lambda_K ) \\rfloor + 1.\n\n"
msgstr "n_s = \\lfloor \\log_2( \\lambda_1 + ... + \\lambda_K ) \\rfloor + 1.\n\n"

#: ../../tutorials/09_credit_risk_analysis.ipynb:445
msgid "Once we have the total loss distribution in a quantum register, we can use the techniques described in [Woerner2019] to map a total loss :math:`L \\in \\{0, ..., 2^{n_s}-1\\}` to the amplitude of an objective qubit by an operator"
msgstr "Bir kuantum kaydındaki toplam kayıp dağılımını elde ettiğimiz zaman, [Woerner2019] 'de açıklanan teknikleri, toplam kaybı :math:`L \\in \\{ 0, ..., 2^{n_s}-1\\}`i bir operatör tarafından yapılan bir amacın genleşmesine eşleştirmek için kullanabiliriz"

#: ../../tutorials/09_credit_risk_analysis.ipynb:447
msgid " | L \\rangle_{n_s}|0\\rangle \\mapsto\n"
"| L \\rangle_{n_s} \\left( \\sqrt{1 - L/(2^{n_s}-1)}|0\\rangle + \\sqrt{L/(2^{n_s}-1)}|1\\rangle \\right),"
msgstr " | L \\rangle_{n_s}|0\\rangle \\mapsto\n"
"| L \\rangle_{n_s} \\left( \\sqrt{1 - L/(2^{n_s}-1)}|0\\rangle + \\sqrt{L/(2^{n_s}-1)}|1\\rangle \\right),"

#: ../../tutorials/09_credit_risk_analysis.ipynb:452
msgid "which allows to run amplitude estimation to evaluate the expected loss."
msgstr "beklenen kaybı değerlendirmek için genlik tahminini çalıştırmaya izin verir."

#: ../../tutorials/09_credit_risk_analysis.ipynb:504
msgid "Create the state preparation circuit:"
msgstr "Durumu hazırlama devresini oluşturun:"

#: ../../tutorials/09_credit_risk_analysis.ipynb:628
msgid "Before we use QAE to estimate the expected loss, we validate the quantum circuit representing the objective function by just simulating it directly and analyzing the probability of the objective qubit being in the :math:`|1\\rangle` state, i.e., the value QAE will eventually approximate."
msgstr "Beklenen kaybı tahmin etmek için QAE'yi kullanmadan önce, sadece doğrudan simüle ederek ve objektif kübitin :math:`|1\\rangle` durumunda, yani değerde olma olasılığını analiz ederek, amaç fonksiyonunu temsil eden kuantum devresini doğrularız. QAE sonunda yaklaşık olacaktır."

#: ../../tutorials/09_credit_risk_analysis.ipynb:692
msgid "Next we run QAE to estimate the expected loss with a quadratic speed-up over classical Monte Carlo simulation."
msgstr "Ardından, klasik Monte Carlo simülasyonu üzerinde ikinci dereceden bir hızlanma ile beklenen kaybı tahmin etmek için QAE'yi çalıştırıyoruz."

#: ../../tutorials/09_credit_risk_analysis.ipynb:753
msgid "Cumulative Distribution Function"
msgstr "Kümülatif Dağılım Fonksiyonu"

#: ../../tutorials/09_credit_risk_analysis.ipynb:755
msgid "Instead of the expected loss (which could also be estimated efficiently using classical techniques) we now estimate the cumulative distribution function (CDF) of the loss. Classically, this either involves evaluating all the possible combinations of defaulting assets, or many classical samples in a Monte Carlo simulation. Algorithms based on QAE have the potential to significantly speed up this analysis in the future."
msgstr "Beklenen kayıp yerine (klasik teknikler kullanılarak verimli bir şekilde tahmin edilebilir), şimdi kaybın kümülatif dağılım fonksiyonunu (CDF) tahmin ediyoruz. Klasik olarak, bu ya temerrüde düşen varlıkların tüm olası kombinasyonlarının ya da bir Monte Carlo simülasyonunda birçok klasik örneğin değerlendirilmesini içerir. QAE'ye dayalı algoritmalar, gelecekte bu analizi önemli ölçüde hızlandırma potansiyeline sahiptir."

#: ../../tutorials/09_credit_risk_analysis.ipynb:757
msgid "To estimate the CDF, i.e., the probability :math:`\\mathbb{P}[L \\leq x]`, we again apply :math:`\\mathcal{S}` to compute the total loss, and then apply a comparator that for a given value :math:`x` acts as"
msgstr "CDF'yi, yani :math:`\\mathbb{P}[L \\leq x]` ​​olasılığını tahmin etmek için, toplam kaybı hesaplamak için tekrar :math:`\\mathcal{S}` uygularız ve ardından bir karşılaştırıcı uygularız belirli bir değer için :math:`x` şu işlevi görür"

#: ../../tutorials/09_credit_risk_analysis.ipynb:759
msgid " \\mathcal{C}: |L\\rangle_n|0> \\mapsto\n"
"\\begin{cases}\n"
"|L\\rangle_n|1> & \\text{if}\\quad L \\leq x \\\\\n"
"|L\\rangle_n|0> & \\text{if}\\quad L > x.\n"
"\\end{cases}"
msgstr " \\mathcal{C}: |L\\rangle_n|0> \\mapsto\n"
"\\begin{cases}\n"
"|L\\rangle_n|1> & \\text{if}\\quad L \\leq x \\\\\n"
"|L\\rangle_n|0> & \\text{if}\\quad L > x.\n"
"\\end{cases}"

#: ../../tutorials/09_credit_risk_analysis.ipynb:767
msgid "The resulting quantum state can be written as"
msgstr "Elde edilen kuantum durumu şu şekilde yazılabilir"

#: ../../tutorials/09_credit_risk_analysis.ipynb:769
msgid " \\sum_{L = 0}^{x} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle +\n"
"\\sum_{L = x+1}^{2^{n_s}-1} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle,"
msgstr " \\sum_{L = 0}^{x} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle +\n"
"\\sum_{L = x+1}^{2^{n_s}-1} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle,"

#: ../../tutorials/09_credit_risk_analysis.ipynb:774
msgid "where we directly assume the summed up loss values and corresponding probabilities instead of presenting the details of the uncertainty model."
msgstr "burada belirsizlik modelinin ayrıntılarını sunmak yerine, özetlenen kayıp değerlerini ve karşılık gelen olasılıkları doğrudan varsayıyoruz."

#: ../../tutorials/09_credit_risk_analysis.ipynb:776
msgid "The CDF(\\ :math:`x`) equals the probability of measuring :math:`|1\\rangle` in the objective qubit and QAE can be directly used to estimate it."
msgstr "CDF(\\ :math:`x`), objektif kübitte :math:`|1\\rangle` ölçme olasılığına eşittir ve QAE bunu tahmin etmek için doğrudan kullanılabilir."

#: ../../tutorials/09_credit_risk_analysis.ipynb:894
#: ../../tutorials/09_credit_risk_analysis.ipynb:1460
msgid "Again, we first use quantum simulation to validate the quantum circuit."
msgstr "Yine, kuantum devresini doğrulamak için önce kuantum simülasyonunu kullanıyoruz."

#: ../../tutorials/09_credit_risk_analysis.ipynb:1045
msgid "Next we run QAE to estimate the CDF for a given :math:`x`."
msgstr "Ardından, verilen bir : :math:`x` için CDF'yi tahmin etmek üzere QAE'yi çalıştırırız."

#: ../../tutorials/09_credit_risk_analysis.ipynb:1105
msgid "Value at Risk"
msgstr "Riske Maruz Değer"

#: ../../tutorials/09_credit_risk_analysis.ipynb:1107
msgid "In the following we use a bisection search and QAE to efficiently evaluate the CDF to estimate the value at risk."
msgstr "Aşağıda, risk altındaki değeri tahmin etmek için CDF'yi verimli bir şekilde değerlendirmek için bir ikiye bölme araması ve QAE kullanıyoruz."

#: ../../tutorials/09_credit_risk_analysis.ipynb:1296
msgid "Conditional Value at Risk"
msgstr "Risk Altındaki Koşullu Değer"

#: ../../tutorials/09_credit_risk_analysis.ipynb:1298
msgid "Last, we compute the CVaR, i.e. the expected value of the loss conditional to it being larger than or equal to the VaR. To do so, we evaluate a piecewise linear objective function :math:`f(L)`, dependent on the total loss :math:`L`, that is given by"
msgstr "Son olarak, CVaR'yi hesaplıyoruz, yani VaR'den büyük veya ona eşit olmasına bağlı olarak kaybın beklenen değeri.Bunu yapmak için, toplam kayba bağlı olarak :math:`f(L)` parçalı doğrusal bir amaç fonksiyonunu değerlendiririz :math:`L` , tarafından verilen"

#: ../../tutorials/09_credit_risk_analysis.ipynb:1300
msgid "f(L) = \\begin{cases}\n"
"0 & \\text{if}\\quad L \\leq VaR \\\\\n"
"L & \\text{if}\\quad L > VaR.\n"
"\\end{cases}"
msgstr "f(L) = \\begin{cases}\n"
"0 & \\text{if}\\quad L \\leq VaR \\\\\n"
"L & \\text{if}\\quad L > VaR.\n"
"\\end{cases}"

#: ../../tutorials/09_credit_risk_analysis.ipynb:1308
msgid "To normalize, we have to divide the resulting expected value by the VaR-probability, i.e. \\ :math:`\\mathbb{P}[L \\leq VaR]`."
msgstr "Normalleştirmek için, elde edilen beklenen değeri VaR olasılığına bölmemiz gerekir, yani \\ :math:`\\mathbb{P}[L \\leq VaR]`."

#: ../../tutorials/09_credit_risk_analysis.ipynb:1526
msgid "Next we run QAE to estimate the CVaR."
msgstr "Ardından CVaR'ı tahmin etmek için QAE'yi çalıştırırız."

#: ../../tutorials/10_qgan_option_pricing.ipynb:9
msgid "Option Pricing with qGANs"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:14
msgid "In this notebook, we discuss how a Quantum Machine Learning Algorithm, namely a quantum Generative Adversarial Network (qGAN), can facilitate the pricing of a European call option. More specifically, a qGAN can be trained such that a quantum circuit models the spot price of an asset underlying a European call option. The resulting model can then be integrated into a Quantum Amplitude Estimation based algorithm to evaluate the expected payoff - see `European Call Option Pricing <03_european_call_option_pricing.ipynb>`__. For further details on learning and loading random distributions by training a qGAN please refer to `Quantum Generative Adversarial Networks for Learning and Loading Random Distributions. Zoufal, Lucchi, Woerner. 2019. <https://www.nature.com/articles/s41534-019-0223-2>`__"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:50
msgid "The Black-Scholes model assumes that the spot price at maturity :math:`S_T` for a European call option is log-normally distributed. Thus, we can train a qGAN on samples from a log-normal distribution and use the result as an uncertainty model underlying the option. In the following, we construct a quantum circuit that loads the uncertainty model. The circuit output reads"
msgstr "Black-Scholes modeli, bir Avrupa alım opsiyonu için vade sonundaki spot fiyatın :math:`S_T` log-normal olarak dağıldığını varsayar. Böylece, bir log-normal dağılımdan alınan örnekler üzerinde bir qGAN eğitebilir ve sonucu, seçeneğin altında yatan bir belirsizlik modeli olarak kullanabiliriz. Aşağıda, belirsizlik modelini yükleyen bir kuantum devresi oluşturuyoruz. Devre çıkışı okur"

#: ../../tutorials/10_qgan_option_pricing.ipynb:52
msgid "\\big| g_{\\theta}\\rangle = \\sum_{j=0}^{2^n-1}\\sqrt{p_{\\theta}^{j}} \\big| j \\rangle ,\n\n"
msgstr "\\big| g_{\\theta}\\rangle = \\sum_{j=0}^{2^n-1}\\sqrt{p_{\\theta}^{j}} \\big| j \\rangle ,\n\n"

#: ../../tutorials/10_qgan_option_pricing.ipynb:54
msgid "where the probabilities :math:`p_{\\theta}^{j}`, for :math:`j\\in \\left\\{0, \\ldots, {2^n-1} \\right\\}`, represent a model of the target distribution."
msgstr "burada  :math:`p_{\\theta}^{j}`, for :math:`j\\in \\left\\{0, \\ldots, {2^n-1} \\right\\}` olasılıkları, hedef dağılımın bir modelini temsil eder."

#: ../../tutorials/10_qgan_option_pricing.ipynb:97
msgid "Now, the trained uncertainty model can be used to evaluate the expectation value of the option’s payoff function with Quantum Amplitude Estimation."
msgstr "Şimdi, eğitimli belirsizlik modeli, opsiyonun getiri fonksiyonunun beklenti değerini Kuantum Genlik Tahmini ile ölçmek için kullanılabilir."

#: ../../tutorials/10_qgan_option_pricing.ipynb:123
msgid "Plot the probability distribution"
msgstr "Olasılık dağılımını çizin"

#: ../../tutorials/10_qgan_option_pricing.ipynb:125
msgid "Next, we plot the trained probability distribution and, for reasons of comparison, also the target probability distribution."
msgstr "Sonra, eğitilmiş olasılık dağılımını ve karşılaştırma amacıyla hedef olasılık dağılımını çiziyoruz."

#: ../../tutorials/10_qgan_option_pricing.ipynb:193
msgid "Now, the trained uncertainty model can be used to evaluate the expectation value of the option’s payoff function analytically and with Quantum Amplitude Estimation."
msgstr "Şimdi, eğitimli belirsizlik modeli, opsiyonun getiri fonksiyonunun beklenti değerini analitik olarak ve Kuantum Genlik Tahmini ile birlikte ölçmek için kullanılabilir."

#: ../../tutorials/11_time_series.ipynb:9
msgid "Loading and Processing Stock-Market Time-Series Data"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:23
msgid "Across many problems in finance, one starts with time series. Here, we showcase how to generate pseudo-random time-series, download actual stock-market time series from a number of common providers, and how to compute time-series similarity measures."
msgstr "Finanstaki birçok problemlerin karşısında, birine zaman serileri ile başlanır. Burada, sahte rasgele zaman serilerinin nasıl oluşturulacağını, bir dizi ortak sağlayıcıdan gerçek borsa zaman serilerinin nasıl indirileceğini ve zaman serisi benzerlik ölçülerinin nasıl hesaplanacağını gösteriyoruz."

#: ../../tutorials/11_time_series.ipynb:64
msgid "Once the data are loaded, you can run a variety of algorithms on those to aggregate the data. Notably, you can compute the covariance matrix or a variant, which would consider alternative time-series similarity measures based on `dynamic time warping <https://en.wikipedia.org/wiki/Dynamic_time_warping>`__ (DTW). In DTW, changes that vary in speed, e.g., one stock’s price following another stock’s price with a small delay, can be accommodated."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:168
msgid "If you wish, you can look into the underlying pseudo-random time-series using. Please note that the private class members (starting with underscore) may change in future releases of Qiskit."
msgstr "Dilerseniz altta yatan sahte-rastgele zaman serilerini kullanarak inceleyebilirsiniz. Özel sınıf üyelerinin (alt çizgi ile başlayan) Qiskit'in gelecek sürümlerinde değişebileceğini lütfen unutmayın."

#: ../../tutorials/11_time_series.ipynb:252
msgid "Clearly, you can adapt the number and names of tickers and the range of dates:"
msgstr "Açıkça, kayıtların sayısını ve adlarını ve tarih aralığını uyarlayabilirsiniz:"

#: ../../tutorials/11_time_series.ipynb:291
msgid "Access to closing-price time-series"
msgstr "Kapanış fiyatı zaman serisine erişim"

#: ../../tutorials/11_time_series.ipynb:293
msgid "While the access to real-time data usually requires a payment, it is possible to access historical (adjusted) closing prices via Wikipedia and Quandl free of charge, following registration at: https://www.quandl.com/?modal=register In the code below, one needs to specify actual tickers of actual NASDAQ issues and the access token you obtain from Quandl; by running the code below, you agree to the Quandl terms and conditions, including a liability waiver. Notice that at least two tickers are required for the computation of covariance and time-series matrices, but hundreds of tickers may go beyond the fair usage limits of Quandl."
msgstr "Gerçek zamanlı verilere erişim genellikle bir ödeme gerektirirken, https://www.quandl.com/?modal=register adresinden kayıt olduktan sonra, Wikipedia ve Quandl aracılığıyla tarihsel (düzeltilmiş) kapanış fiyatlarına ücretsiz olarak erişmek mümkündür: Aşağıdaki kodda, gerçek NASDAQ sorunlarının gerçek kayıtlarını ve Quandl'dan elde ettiğiniz erişim jetonunuzu belirtmeniz gerekir; Aşağıdaki kodu çalıştırarak, sorumluluktan feragat dahil Quandl hüküm ve koşullarını kabul etmiş olursunuz. Kovaryans ve zaman serisi matrislerinin hesaplanması için en az iki etiketin gerekli olduğuna dikkat edin, ancak yüzlerce etiketler Quandl'ın adil kullanım sınırlarının ötesine geçebilir."

#: ../../tutorials/11_time_series.ipynb:328
msgid "Once the data are loaded, you can again compute the covariance matrix or its DTW variants."
msgstr "Veriler yüklendikten sonra kovaryans matrisini veya onun DTW türevlerini tekrar hesaplayabilirsiniz."

#: ../../tutorials/11_time_series.ipynb:366
msgid "If you wish, you can look into the underlying time-series using:"
msgstr "İsterseniz, aşağıdakileri kullanarak temel zaman serisine bakabilirsiniz:"

#: ../../tutorials/11_time_series.ipynb:401
msgid "[Optional] Setup token to access recent, fine-grained time-series"
msgstr "[Optional] En son, ayrıntılı zaman serilerine erişmek için kurulum belirteci"

#: ../../tutorials/11_time_series.ipynb:403
msgid "If you would like to download professional data, you will have to set-up a token with one of the major providers. Let us now illustrate the data with NASDAQ Data on Demand, which can supply bid and ask prices in arbitrary resolution, as well as aggregates such as daily adjusted closing prices, for NASDAQ and NYSE issues."
msgstr "Eğer profesyonel verileri indirmek istiyorsanız, büyük sağlayıcılardan biriyle bir jeton ayarlamanız gerekecektir. Şimdi verileri, NASDAQ ve NYSE ihraçları için günlük olarak ayarlanmış kapanış fiyatları gibi toplamların yanı sıra, isteğe bağlı çözünürlükte alış ve satış fiyatları sağlayabilen NASDAQ talep üzerine verileri ile gösterelim."

#: ../../tutorials/11_time_series.ipynb:414
msgid "If you don’t have NASDAQ Data on Demand license, you can contact NASDAQ (cf. https://business.nasdaq.com/intel/GIS/Nasdaq-Data-on-Demand.html) to obtain a trial or paid license."
msgstr "NASDAQ Data on Demand lisansına sahip değilseniz, bir deneme veya ücretli lisans almak için NASDAQ (bkz. https://business.nasdaq.com/intel/GIS/Nasdaq-Data-on-Demand.html) ile iletişime geçebilirsiniz."

#: ../../tutorials/11_time_series.ipynb:416
msgid "If and when you have access to NASDAQ Data on Demand using your own token, you should replace REPLACE-ME below with the token. To assure the security of the connection, you should also have your own means of validating NASDAQ’s certificates. The DataOnDemandProvider constructor has an optional argument ``verify``, which can be ``None`` or a string or a boolean. If it is ``None``, certify certificates will be used (default). If verify is a string, it should be pointing to a certificate for the HTTPS connection to NASDAQ (dataondemand.nasdaq.com), either in the form of a CA_BUNDLE file or a directory wherein to look."
msgstr "Eğer kendi jetonunuzu kullanarak NASDAQ Talep Üzerine Verilerine erişiminiz varsa, aşağıdaki REPLACE-ME'yi jetonuyla değiştirmelisiniz. Bağlantının güvenliğini sağlamak için NASDAQ sertifikalarını doğrulamak için kendi yöntemleriniz de olmalıdır. DataOnDemandProvider yapıcısı, ``None`` veya bir dize ya da boolean olabilen isteğe bağlı bir ``verify`` bağımsız değişkenine sahiptir. ``None`` ise, sertifika sertifikaları kullanılacaktır (varsayılan). Doğrulama bir dizeyse, NASDAQ'a (dataondemand.nasdaq.com) HTTPS bağlantısı için bir CA_BUNDLE dosyası veya aranacak bir dizin biçiminde bir sertifikaya işaret ediyor olmalıdır."

#: ../../tutorials/11_time_series.ipynb:453
msgid "Another major vendor of stock market data is Exchange Data International (EDI), whose API can be used to query over 100 emerging and frontier markets that are Africa, Asia, Far East, Latin America and Middle East, as well as the more established ones. See: https://www.exchange-data.com/pricing-data/adjusted-prices.php#exchange-coverage for an overview of the coverage."
msgstr "Borsa verilerinin bir başka önemli satıcısı, API'si Afrika, Asya, Uzak Doğu, Latin Amerika ve Orta Doğu'nun yanı sıra daha yerleşik 100'den fazla gelişmekte olan ve sınır pazarını sorgulamak için kullanılabilen Exchange Data International'dır (EDI). Kapsama genel bir bakış için bkz: https://www.exchange-data.com/pricing-data/adjusted-prices.php#exchange-coverage."

#: ../../tutorials/11_time_series.ipynb:455
msgid "The access again requires a valid access token to replace REPLACE-ME below. The token can be obtained on a trial or paid-for basis at: https://www.quandl.com/"
msgstr "Erişim, aşağıdaki REPLACE-ME'yi değiştirmek için tekrar geçerli bir erişim işareti gerektirir. Erişim deneme amaçlı veya ücretli olarak şu adresten edinilebilir: https://www.quandl.com/"

#: ../../tutorials/11_time_series.ipynb:493
msgid "One can also access Yahoo Finance Data, no token needed, from Yahoo! Finance."
msgstr "Ayrıca Yahoo Finans Verilerine, belirteç gerekmeden erişebilirsiniz, Yahoo! Finans."

#: ../../tutorials/11_time_series.ipynb:535
msgid "For the actual use of the data, please see the portfolio_optimization or portfolio_diversification notebooks."
msgstr "Verilerin fiili kullanımı için lütfen portfolio_optimization veya portfolio_diversification not defterlerine bakın."

#: ../../tutorials/index.rst:3
msgid "Finance Tutorials"
msgstr "Finans Öğreticileri"


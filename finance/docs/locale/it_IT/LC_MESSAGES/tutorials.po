msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-02 14:13+0000\n"
"PO-Revision-Date: 2021-07-02 14:25\n"
"Last-Translator: \n"
"Language-Team: Italian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: it\n"
"X-Crowdin-File: /master/finance/docs/locale/en/LC_MESSAGES/tutorials.po\n"
"X-Crowdin-File-ID: 9618\n"
"Language: it_IT\n"

#: ../../tutorials/01_portfolio_optimization.ipynb:13
#: ../../tutorials/02_portfolio_diversification.ipynb:13
#: ../../tutorials/03_european_call_option_pricing.ipynb:13
#: ../../tutorials/04_european_put_option_pricing.ipynb:13
#: ../../tutorials/05_bull_spread_pricing.ipynb:13
#: ../../tutorials/06_basket_option_pricing.ipynb:13
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:13
#: ../../tutorials/08_fixed_income_pricing.ipynb:13
#: ../../tutorials/09_credit_risk_analysis.ipynb:13
#: ../../tutorials/10_qgan_option_pricing.ipynb:13
#: ../../tutorials/11_time_series.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:9
msgid "*Portfolio Optimization*"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:21
#: ../../tutorials/02_portfolio_diversification.ipynb:12
#: ../../tutorials/03_european_call_option_pricing.ipynb:21
#: ../../tutorials/04_european_put_option_pricing.ipynb:21
#: ../../tutorials/05_bull_spread_pricing.ipynb:21
#: ../../tutorials/06_basket_option_pricing.ipynb:21
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:21
#: ../../tutorials/08_fixed_income_pricing.ipynb:21
#: ../../tutorials/09_credit_risk_analysis.ipynb:21
#: ../../tutorials/10_qgan_option_pricing.ipynb:12
#: ../../tutorials/11_time_series.ipynb:21
msgid "Introduction"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:23
msgid "This tutorial shows how to solve the following mean-variance portfolio optimization problem for :math:`n` assets:"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:25
msgid "\\begin{aligned}\n"
"\\min_{x \\in \\{0, 1\\}^n}  q x^T \\Sigma x - \\mu^T x\\\\\n"
"\\text{subject to: } 1^T x = B\n"
"\\end{aligned}"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:32
msgid "where we use the following notation:"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:34
msgid ":math:`x \\in \\{0, 1\\}^n` denotes the vector of binary decision variables, which indicate which assets to pick (:math:`x[i] = 1`) and which not to pick (:math:`x[i] = 0`),"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:35
msgid ":math:`\\mu \\in \\mathbb{R}^n` defines the expected returns for the assets,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:36
msgid ":math:`\\Sigma \\in \\mathbb{R}^{n \\times n}` specifies the covariances between the assets,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:37
msgid ":math:`q > 0` controls the risk appetite of the decision maker,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:38
msgid "and :math:`B` denotes the budget, i.e. the number of assets to be selected out of :math:`n`."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:40
msgid "We assume the following simplifications: - all assets have the same price (normalized to 1), - the full budget :math:`B` has to be spent, i.e. one has to select exactly :math:`B` assets."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:42
msgid "The equality constraint :math:`1^T x = B` is mapped to a penalty term :math:`(1^T x - B)^2` which is scaled by a parameter and subtracted from the objective function. The resulting problem can be mapped to a Hamiltonian whose ground state corresponds to the optimal solution. This notebook shows how to use the Variational Quantum Eigensolver (VQE) or the Quantum Approximate Optimization Algorithm (QAOA) to find the optimal solution for a given set of parameters."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:44
msgid "Experiments on real quantum hardware for this problem are reported for instance in the following paper: Improving Variational Quantum Optimization using CVaR. Barkoutsos et al. 2019."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:78
msgid "[Optional] Setup token to run the experiment on a real device"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:80
msgid "If you would like to run the experiment on a real device, you need to setup your account first."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:82
msgid "Note: If you do not store your token yet, use ``IBMQ.save_account('MY_API_TOKEN')`` to store it first."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:94
msgid "Define problem instance"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:96
msgid "Here an Operator instance is created for our Hamiltonian. In this case the paulis are from an Ising Hamiltonian translated from the portfolio problem. We use a random portfolio problem for this notebook. It is straight-forward to extend this to using real financial data as illustrated here: `Loading and Processing Stock-Market Time-Series Data <11_time_series.ipynb>`__"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:236
msgid "We define some utility methods to print the results in a nice format."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:280
msgid "NumPyMinimumEigensolver (as a classical reference)"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:282
msgid "Lets solve the problem. First classically…"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:284
msgid "We can now use the Operator we built above without regard to the specifics of how it was created. We set the algorithm for the NumPyMinimumEigensolver so we can have a classical reference. The problem is set for ‘ising’. Backend is not required since this is computed classically not using quantum computation. The result is returned as a dictionary."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:370
msgid "Solution using VQE"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:372
msgid "We can now use the Variational Quantum Eigensolver (VQE) to solve the problem. We will specify the optimizer and variational form to be used."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:374
msgid "Note: You can switch to different backends by providing the name of backend."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:468
msgid "Solution using QAOA"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:470
msgid "We also show here a result using the Quantum Approximate Optimization Algorithm (QAOA). This is another variational algorithm and it uses an internal variational form that is created based on the problem."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:9
msgid "*Portfolio Diversification*"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:14
msgid "In asset management, there are broadly two approaches: active and passive investment management. Within passive investment management, there are index-tracking funds and there are approaches based on portfolio diversification, which aim at representing a portfolio with a large number of assets by a smaller number of representative stocks. This notebook illustrates a portfolio diversification problem, which has recently become popular for two reasons: 1. it makes it possible to mimic the performance of an index (or a similarly large set of assets) with a limited budget, at limited transaction costs. That is: traditional index-tracking may purchase all assets in the index, ideally with the same weights as in the index. This may be impractical for a number of reasons: the total of even a single round lot per asset may amount to more than the assets under management, the large scale of the index-tracking problem with integrality constraints may render the optimization problem difficult, and the transaction costs of the frequent rebalancing to adjust the positions to the weights in the index may render the approach expensive. Thus, a popular approach is to select a portfolio of :math:`q` assets that represent the market with :math:`n` assets, where :math:`q` is significantly smaller than :math:`n`, but where the portfolio replicates the behavior of the underlying market. To determine how to group assets into :math:`q` clusters and how to determine which :math:`q` assets should represent the :math:`q` clusters amounts to solving a large-scale optimization problem. In the following we describe the mathematical model for the portfolio diversification problem as introduced in [Cornuejols & Tutuncu, 2006] 2. it allows for similarity measures between time-series beyond the covariance matrix. Notice that traditionally, modern portfolio theory considers the covariance matrix as a measure of similarity between the assets. As such, however, the covariance matrix is imperfect. Consider, for instance, a company listed both in London and New York. Although both listings should be very similar, only parts of the time series of the prices of the two listings will overlap, because of the partial overlap of the times the markets open. Instead of covariance, one can consider, for example, dynamic time warping of [Berndt and Clifford, 1994] as a measure of similarity between two time series, which allows for the fact that for some time periods, the data are captured by only one of the time series, while for others, both time series exhibit the similarity due to the parallel evolution of the stock price."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:21
msgid "The overall workflow we demonstrate comprises:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:23
msgid "pick the ground set of assets. In our case, this is a small number of US stocks."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:25
msgid "load the time series capturing the evolution of the prices of assets. In our case, this is a simplistic load of adjusted daily closing price data from Wikipedia or Nasdaq or LSE or EuroNext, whereas in a real asset management, a much higher frequency may be considered."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:27
msgid "compute the pair-wise similarity among the time series. In our case, we run a linear-time approximation of the dynamic time warping, still on the classical computer."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:29
msgid "compute the actual portfolio of :math:`q` representative assets, based on the similarity measure. This step is run twice, actually. First, we obtain a reference value by a run of an IBM solver (IBM ILOG CPLEX or the Exact Eigensolver) on the classical computer. Second, we run an alternative, hybrid algorithm partly on the quantum computer."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:31
msgid "visualization of the results. In our case, this is again a simplistic plot."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:33
msgid "In the following, we first explain the model used in (4) above, before we proceed with the installation of the pre-requisites and the data loading."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:36
msgid "The Model"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:38
msgid "As discussed in [Cornuejols & Tutuncu, 2006], we describe a mathematical model that clusters assets into groups of similar ones and selects one representative asset from each group to be included in the index fund portfolio. The model is based on the following data, which we will discuss in more detail later:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:40
msgid "\\rho_{ij} = \\textrm{similarity}\\, \\textrm{between}\\, \\textrm{stock}\\, i \\, \\textrm{and}\\, \\textrm{stock}\\, j."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:45
msgid "For example, :math:`\\rho_{ii} = 1`, :math:`\\rho_{ij} \\leq 1` for :math:`i \\neq j` and :math:`\\rho_{ij}` is larger for more similar stocks. An example of this is the correlation between the returns of stocks :math:`i` and :math:`j`. But one could choose other similarity indices :math:`\\rho_{ij}`."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:47
msgid "The problem that we are interested in solving is:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:49
msgid "(M) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:54
msgid "subject to the clustering constraint:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:56
msgid "\\sum_{j=1}^n y_j = q,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:61
msgid "to consistency constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:63
msgid "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n"
"\\quad x_{ij} \\leq y_j,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n"
"\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:70
msgid "and integral constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:72
msgid "\\quad  x_{ij}, y_j \\in\\{0,1\\}, \\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:77
msgid "The variables :math:`y_j` describe which stocks :math:`j` are in the index fund (:math:`y_j = 1` if :math:`j` is selected in the fund, :math:`0` otherwise). For each stock :math:`i = 1,\\dots,n`, the variable :math:`x_{ij}` indicates which stock :math:`j` in the index fund is most similar to :math:`i` (:math:`x_{ij} = 1` if :math:`j` is the most similar stock in the index fund, :math:`0` otherwise)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:79
msgid "The first constraint selects :math:`q` stocks in the fund. The second constraint imposes that each stock :math:`i` has exactly one representative stock :math:`j` in the fund. The third and fourth constraints guarantee that stock :math:`i` can be represented by stock :math:`j` only if :math:`j` is in the fund. The objective of the model maximizes the similarity between the :math:`n` stocks and their representatives in the fund. Different cost functions can also be considered."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:81
msgid "Let us concatenate the decision variables in one vector"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:83
msgid "{\\bf z} = [x_{11},x_{12},\\ldots,x_{1n}, x_{22},\\ldots,x_{nn}, y_{1},\\ldots,y_{n}],"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:88
msgid "whose dimension is :math:`{\\bf z} \\in \\{0,1\\}^N`, with :math:`N = n (n+1)` and denote the optimal solution with :math:`{\\bf z}^*`, and the optimal cost :math:`f^*`."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:91
msgid "A Hybrid Approach"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:93
msgid "Here, we demonstrate an approach that combines classical and quantum computing steps, following the quantum approximate optimization approach of Farhi, Goldstone, and Gutmann (2014)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:96
msgid "Construct a binary polynomial optimization"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:98
msgid "From :math:`(M)` one can construct a binary polynomial optimization with equality constraints only, by substituting the :math:`x_{ij} \\leq y_j` inequality constraints with the equivalent equality constraints :math:`x_{ij} (1- y_j) = 0`. Then the problem becomes:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:100
msgid "(BPO) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:105
msgid "subject to the clustering constraint, the integral constraints, and the following modified consistency constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:107
msgid "\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:109
msgid "\\quad x_{ij} (1- y_j) = 0,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = 1,\\ldots, n,\n\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:111
msgid "\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n.\n\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:114
msgid "Construct the Ising Hamiltonian"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:116
msgid "We can now construct the Ising Hamiltonian (QUBO) by penalty methods (introducing a penalty coefficient :math:`A` for each equality constraint) as"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:118
msgid "(IH) \\quad H = \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} + A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 + \\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 + \\sum_{j=1}^n A (x_{jj}-y_j)^2 +\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:124
msgid "From Hamiltonian to Quadratic Programming (QP) formulation"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:126
msgid "In the vector :math:`{\\bf z}`, the Ising Hamiltonian elements can be rewritten as follows,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:128
msgid "First term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:130
msgid "\\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} = [\\rho_{11},\\rho_{12},\\ldots,\\rho_{1n}, \\rho_{22},\\ldots,\\rho_{nn}|{\\bf 0}_n ]{\\bf z} =: {\\bf c}_0^T {\\bf z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:135
msgid "Second term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:137
msgid "A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 = A \\Big(\\sum_{j=1}^n y_j\\Big)^2 - 2 Aq \\sum_{j=1}^n y_j + A q^2 = A {\\bf z}^T \\left[\\begin{array}{c}{\\bf 0}_{n^2} \\\\ \\hline  {\\bf 1}_n  \\end{array}\\right]\\left[\\begin{array}{cc}{\\bf 0}_{n^2} | {\\bf 1}_n  \\end{array}\\right]{\\bf z} - 2 A q [{\\bf 0}_{n^2}|{\\bf 1}_n]{\\bf z} + A q^2 =: {\\bf z}^T {\\bf Q}_0 {\\bf z} + {\\bf c}_1^T {\\bf z} + r_0"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:142
msgid "Third term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:144
msgid "\\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 = A\\sum_{i=1}^n \\Big(\\sum_{j=1}^n x_{ij}\\Big)^2 - 2 A \\sum_{i=1}^n\\sum_{j=1}^n x_{ij} + n A = \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:149
msgid "which is equivalent to:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:151
msgid "\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad = A {\\bf z}^T \\left(\\sum_{i=1}^n \\left[\\begin{array}{c}{\\bf 0}_{n(i-1)}  \\\\ {\\bf 1}_n  \\\\ {\\bf 0}_{n(n-i)} \\\\ \\hline {\\bf 0}_{n} \\end{array}\\right]\\left[\\begin{array}{cccc}{\\bf 0}_{n(i-1)} & {\\bf 1}_n  & {\\bf 0}_{n(n-i)} & | {\\bf 0}_{n} \\end{array}\\right]\\right){\\bf z} - 2 A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + n A =: {\\bf z}^T {\\bf Q}_1 {\\bf z} + {\\bf c}_2^T {\\bf z} + r_1"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:156
msgid "Fourth term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:158
msgid "A \\sum_{j=1}^n  (x_{jj}-y_j)^2 = A {\\bf z}^T  \\left(\\sum_{j=0}^{n-1} \\left[\\begin{array}{c}{\\bf 0}_{nj + j}  \\\\ 1  \\\\ {\\bf 0}_{n^2-(nj+j+1)} \\\\ \\hline {\\bf 0}_{j} \\\\ -1 \\\\ {\\bf 0}_{n-j-1} \\end{array}\\right]\\left[\\begin{array}{cccccc}{\\bf 0}_{nj + j} & 1  & {\\bf 0}_{n^2-(nj+j+1)} & | {\\bf 0}_{j} & -1 & {\\bf 0}_{n-j-1}  \\end{array}\\right]\\right){\\bf z} = A {\\bf z}^T {\\bf Q}_2 {\\bf z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:163
msgid "Fifth term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:165
msgid "\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right) = A [{\\bf 1}_{n^2}|{\\bf 0}_n]{\\bf z} + A {\\bf z}^T \\left( \\sum_{i=1}^n \\sum_{j=1}^n \\left[\\begin{array}{ccc|c}  &  & & \\\\ & {\\bf 0}_{n^2\\times n^2} & & -1/2_{(ij,j)}  \\\\ & & & \\\\ \\hline & -1/2_{(j, ij)} &  & {\\bf 0}_{n} \\end{array}\\right] \\right) {\\bf z} =:  {\\bf z}^T {\\bf Q}_3 {\\bf z} + {\\bf c}_3^T {\\bf z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:170
msgid "Therefore, the formulation becomes,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:172
msgid "(IH-QP)\\quad \\max_{{\\bf z}\\in\\{0,1\\}^{n(n+1)}} \\, {\\bf z}^T ({\\bf Q}_0+{\\bf Q}_1+ {\\bf Q}_2 + {\\bf Q}_3 ){\\bf z} + ({\\bf c}_0+{\\bf c}_1+{\\bf c}_2+{\\bf c}_3)^T {\\bf z} +r_0+r_1+r_2"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:177
msgid "which can be passed to the variational quantum eigensolver."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:180
msgid "References"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:182
msgid "[1] G. Cornuejols, M. L. Fisher, and G. L. Nemhauser, *Location of bank accounts to optimize float: an analytical study of exact and approximate algorithms*, Management Science, vol. 23(8), 1997"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:184
msgid "[2] E. Farhi, J. Goldstone, S. Gutmann e-print `arXiv 1411.4028, 2014 <https://arxiv.org/abs/1411.4028>`__"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:186
msgid "[3] G. Cornuejols and R. Tutuncu, `Optimization methods in finance <http://web.math.ku.dk/~rolf/CT_FinOpt.pdf>`__, 2006"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:188
msgid "[4] DJ. Berndt and J. Clifford, *Using dynamic time warping to find patterns in time series*. In KDD workshop 1994 (Vol. 10, No. 16, pp. 359-370)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:190
msgid "[5] `Max-Cut and Traveling Salesman Problem <https://github.com/Qiskit/qiskit-optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:202
msgid "The Implementation"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:204
msgid "First, we import the requisite modules."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:246
msgid "Next, we download price data for two stocks and compute their pair-wise similarity matrix (dynamic time warping distance normalized to (0,1] by taking the reciprocal). If this fails, e.g., due to you being offline or exceeding the daily limit for accesses to the stock-market data, we consider a constant matrix instead."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:278
msgid "Now we decide on the number of clusters. This has to be smaller than the number of stocks we have loaded."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:300
msgid "Classical solution using IBM ILOG CPLEX"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:302
msgid "For a classical solution, we use IBM CPLEX. CPLEX is able to find the exact solution of this problem. We first define a ClassicalOptimizer class that encodes the problem in a way that CPLEX can solve, and then instantiate the class and solve it."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:471
msgid "Solution shows the selected stocks via the stars and in green the links (via similarities) with other stocks that are represented in the fund by the linked stock."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:483
msgid "Quantum Computing with IBM Q"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:485
msgid "For the quantum solution, we use Qiskit. We first define a class QuantumOptimizer that encodes the quantum approach to solve the problem and then we instantiate it and solve it. We define the following methods inside the class:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:487
msgid "``exact_solution`` : to make sure that the Ising Hamiltonian is correctly encoded in the :math:`Z` basis, we can compute its eigendecomposition classically, i.e., considering a symmetric matrix of dimension :math:`2^N \\times 2^N`. For the problem at hand :math:`n=3`, that is :math:`N = 12`, seems to be the limit for many laptops;"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:488
msgid "``vqe_solution`` : solves the problem :math:`(M)` via the variational quantum eigensolver (VQE);"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:489
msgid "``qaoa_solution`` : solves the problem :math:`(M)` via a Quantum Approximate Optimization Algorithm (QAOA)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:557
msgid "Step 1"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:559
msgid "Instantiate the quantum optimizer class with parameters: - the similarity matrix ``rho``; - the number of assets and clusters ``n`` and ``q``;"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:582
msgid "Step 2"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:584
msgid "Encode the problem as a binary formulation (IH-QP)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:586
msgid "Sanity check: make sure that the binary formulation in the quantum optimizer is correct (i.e., yields the same cost given the same solution)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:643
msgid "Step 3"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:645
msgid "Encode the problem as an Ising Hamiltonian in the Z basis."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:647
msgid "Sanity check: make sure that the formulation is correct (i.e., yields the same cost given the same solution)"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:698
msgid "Step 4"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:700
msgid "Solve the problem via VQE. Notice that depending on the number of qubits, this can take a while: for 6 qubits it takes 15 minutes on a 2015 Macbook Pro, for 12 qubits it takes more than 12 hours. For longer runs, logging may be useful to observe the workings; otherwise, you just have to wait until the solution is printed."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:755
msgid "Step 5"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:757
msgid "Visualize the solution"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:832
msgid "Solution shows the selected stocks via the stars and in green the links (via similarities) with other stocks that are represented in the fund by the linked stock. Keep in mind that VQE is a heuristic working on the QP formulation of the Ising Hamiltonian, though. For suitable choices of A, local optima of the QP formulation will be feasible solutions to the ILP. While for some small instances, as above, we can find optimal solutions of the QP formulation which coincide with optima of the ILP, finding optimal solutions of the ILP is harder than finding local optima of the QP formulation, in general. Even within the VQE, one may provide stronger guarantees, for specific variational forms (trial wave functions)."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:9
msgid "*Pricing European Call Options*"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:23
msgid "Suppose a European call option with strike price :math:`K` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:25
msgid "\\max\\{S_T - K, 0\\}\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:27
#: ../../tutorials/04_european_put_option_pricing.ipynb:27
#: ../../tutorials/05_bull_spread_pricing.ipynb:27
#: ../../tutorials/06_basket_option_pricing.ipynb:27
msgid "In the following, a quantum algorithm based on amplitude estimation is used to estimate the expected payoff, i.e., the fair price before discounting, for the option:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{S_T - K, 0\\} \\right]\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:31
#: ../../tutorials/04_european_put_option_pricing.ipynb:31
#: ../../tutorials/05_bull_spread_pricing.ipynb:31
msgid "as well as the corresponding :math:`\\Delta`, i.e., the derivative of the option price with respect to the spot price, defined as:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[S_T \\geq K\\right]"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:38
#: ../../tutorials/04_european_put_option_pricing.ipynb:38
#: ../../tutorials/05_bull_spread_pricing.ipynb:38
#: ../../tutorials/06_basket_option_pricing.ipynb:31
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:44
msgid "The approximation of the objective function and a general introduction to option pricing and risk analysis on quantum computers are given in the following papers:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:40
#: ../../tutorials/04_european_put_option_pricing.ipynb:40
#: ../../tutorials/05_bull_spread_pricing.ipynb:40
#: ../../tutorials/06_basket_option_pricing.ipynb:33
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:46
msgid "Quantum Risk Analysis. Woerner, Egger. 2018."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:41
#: ../../tutorials/04_european_put_option_pricing.ipynb:41
#: ../../tutorials/05_bull_spread_pricing.ipynb:41
#: ../../tutorials/06_basket_option_pricing.ipynb:34
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:47
msgid "Option Pricing using Quantum Computers. Stamatopoulos et al. 2019."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:71
#: ../../tutorials/04_european_put_option_pricing.ipynb:82
#: ../../tutorials/05_bull_spread_pricing.ipynb:71
#: ../../tutorials/06_basket_option_pricing.ipynb:66
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:79
#: ../../tutorials/08_fixed_income_pricing.ipynb:66
#: ../../tutorials/09_credit_risk_analysis.ipynb:120
#: ../../tutorials/10_qgan_option_pricing.ipynb:48
msgid "Uncertainty Model"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:73
#: ../../tutorials/04_european_put_option_pricing.ipynb:84
#: ../../tutorials/05_bull_spread_pricing.ipynb:73
msgid "We construct a circuit factory to load a log-normal random distribution into a quantum state. The distribution is truncated to a given interval :math:`[\\text{low}, \\text{high}]` and discretized using :math:`2^n` grid points, where :math:`n` denotes the number of qubits used. The unitary operator corresponding to the circuit factory implements the following:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:75
#: ../../tutorials/04_european_put_option_pricing.ipynb:86
#: ../../tutorials/05_bull_spread_pricing.ipynb:75
msgid "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i=0}^{2^n-1} \\sqrt{p_i}\\big|i\\rangle_{n},\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:77
#: ../../tutorials/04_european_put_option_pricing.ipynb:88
#: ../../tutorials/05_bull_spread_pricing.ipynb:77
msgid "where :math:`p_i` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i` is mapped to the right interval using the affine map:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:79
#: ../../tutorials/04_european_put_option_pricing.ipynb:90
#: ../../tutorials/05_bull_spread_pricing.ipynb:79
msgid "\\{0, \\ldots, 2^n-1\\} \\ni i \\mapsto \\frac{\\text{high} - \\text{low}}{2^n - 1} * i + \\text{low} \\in [\\text{low}, \\text{high}].\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:159
#: ../../tutorials/04_european_put_option_pricing.ipynb:170
#: ../../tutorials/05_bull_spread_pricing.ipynb:158
#: ../../tutorials/06_basket_option_pricing.ipynb:171
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:184
msgid "Payoff Function"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:161
msgid "The payoff function equals zero as long as the spot price at maturity :math:`S_T` is less than the strike price :math:`K` and then increases linearly. The implementation uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\geq K`, and this ancilla is used to control the linear part of the payoff function."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:163
#: ../../tutorials/05_bull_spread_pricing.ipynb:162
msgid "The linear part itself is then approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:165
#: ../../tutorials/04_european_put_option_pricing.ipynb:176
#: ../../tutorials/05_bull_spread_pricing.ipynb:164
#: ../../tutorials/06_basket_option_pricing.ipynb:178
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:195
msgid "\\sin^2( \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + \\pi/4) \\approx \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + 1/2\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:167
#: ../../tutorials/04_european_put_option_pricing.ipynb:178
#: ../../tutorials/06_basket_option_pricing.ipynb:180
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:197
msgid "\\ for small :math:`c_\\text{approx}`."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:169
#: ../../tutorials/04_european_put_option_pricing.ipynb:180
#: ../../tutorials/05_bull_spread_pricing.ipynb:168
#: ../../tutorials/06_basket_option_pricing.ipynb:182
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:199
msgid "We can easily construct an operator that acts as"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:171
#: ../../tutorials/04_european_put_option_pricing.ipynb:182
#: ../../tutorials/05_bull_spread_pricing.ipynb:170
#: ../../tutorials/06_basket_option_pricing.ipynb:184
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:201
msgid "\\big|x\\rangle \\big|0\\rangle \\mapsto \\big|x\\rangle \\left( \\cos(a*x+b) \\big|0\\rangle + \\sin(a*x+b) \\big|1\\rangle \\right),\n\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:173
#: ../../tutorials/04_european_put_option_pricing.ipynb:184
#: ../../tutorials/05_bull_spread_pricing.ipynb:172
#: ../../tutorials/06_basket_option_pricing.ipynb:186
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:203
msgid "using controlled Y-rotations."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:175
#: ../../tutorials/04_european_put_option_pricing.ipynb:186
#: ../../tutorials/05_bull_spread_pricing.ipynb:174
#: ../../tutorials/06_basket_option_pricing.ipynb:188
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:205
msgid "Eventually, we are interested in the probability of measuring :math:`\\big|1\\rangle` in the last qubit, which corresponds to :math:`\\sin^2(a*x+b)`. Together with the approximation above, this allows to approximate the values of interest. The smaller we choose :math:`c_\\text{approx}`, the better the approximation. However, since we are then estimating a property scaled by :math:`c_\\text{approx}`, the number of evaluation qubits :math:`m` needs to be adjusted accordingly."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:177
#: ../../tutorials/04_european_put_option_pricing.ipynb:188
#: ../../tutorials/05_bull_spread_pricing.ipynb:176
#: ../../tutorials/06_basket_option_pricing.ipynb:190
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:207
msgid "For more details on the approximation, we refer to: Quantum Risk Analysis. Woerner, Egger. 2018."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:376
#: ../../tutorials/04_european_put_option_pricing.ipynb:306
#: ../../tutorials/05_bull_spread_pricing.ipynb:295
#: ../../tutorials/06_basket_option_pricing.ipynb:417
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:612
#: ../../tutorials/10_qgan_option_pricing.ipynb:95
#: ../../tutorials/10_qgan_option_pricing.ipynb:191
msgid "Evaluate Expected Payoff"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:537
msgid "Instead of constructing these circuits manually, Qiskit’s finance module offers the ``EuropeanCallPricing`` circuit, which already implements this functionality as building block."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:611
#: ../../tutorials/04_european_put_option_pricing.ipynb:383
#: ../../tutorials/05_bull_spread_pricing.ipynb:372
msgid "Evaluate Delta"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:613
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use a comparator circuit and an ancilla qubit to identify the cases where :math:`S_T > K`. However, since we are only interested in the probability of this condition being true, we can directly use this ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:9
msgid "*Pricing European Put Options*"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:23
msgid "Suppose a European put option with strike price :math:`K` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:25
msgid "\\max\\{K - S_T, 0\\}\n\n"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{K - S_T, 0\\} \\right]\n\n"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:33
msgid "\\Delta = -\\mathbb{P}\\left[S_T \\leq K\\right]"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:172
msgid "The payoff function decreases linearly with an increasing spot price at maturity :math:`S_T` until it reaches zero for a spot price equal to the strike price :math:`K`, it stays constant to zero for larger spot prices. The implementation uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\leq K`, and this ancilla is used to control the linear part of the payoff function."
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:174
msgid "The linear part itself is then approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling scaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:385
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use a comparator circuit and an ancilla qubit to identify the cases where :math:`S_T \\leq K`. However, since we are only interested in the (negative) probability of this condition being true, we can directly use this ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:9
msgid "*Pricing Bull Spreads*"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:23
msgid "Suppose a bull spread with strike prices :math:`K_1 < K_2` and an underlying asset whose spot price at maturity :math:`S_T` follows a given random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:25
msgid "\\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\}\n\n"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\} \\right]\n\n"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[K_1 \\leq S \\leq K_2\\right]"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:160
msgid "The payoff function equals zero as long as the spot price at maturity :math:`S_T` is less than the strike price :math:`K_1`, then increases linearly, and is bounded by :math:`K_2`. The implementation uses two comparators, that flip an ancilla qubit each from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\geq K_1` and :math:`S_T \\leq K_2`, and these ancillas are used to control the linear part of the payoff function."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:166
msgid "for small :math:`c_\\text{approx}`."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:374
msgid "The Delta is a bit simpler to evaluate than the expected payoff. Similarly to the expected payoff, we use comparator circuits and ancilla qubits to identify the cases where :math:`K_1 \\leq S_T \\leq K_2`. However, since we are only interested in the probability of this condition being true, we can directly use an ancilla qubit as the objective qubit in amplitude estimation without any further approximation."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:9
msgid "*Pricing Basket Options*"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:23
msgid "Suppose a basket option with strike price :math:`K` and two underlying assets whose spot price at maturity :math:`S_T^1`, :math:`S_T^2` follow given random distributions. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:25
msgid "\\max\\{S_T^1 + S_T^2 - K, 0\\}\n\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:29
msgid "\\mathbb{E}\\left[ \\max\\{S_T^1 + S_T^2 - K, 0\\} \\right].\n\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:68
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:81
msgid "We construct a circuit factory to load a multivariate log-normal random distribution into a quantum state on :math:`n` qubits. For every dimension :math:`j = 1,\\ldots,d`, the distribution is truncated to a given interval :math:`[\\text{low}_j, \\text{high}_j]` and discretized using :math:`2^{n_j}` grid points, where :math:`n_j` denotes the number of qubits used to represent dimension :math:`j`, i.e., :math:`n_1+\\ldots+n_d = n`. The unitary operator corresponding to the circuit factory implements the following:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:71
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:84
msgid "\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = \\sum_{i_1,\\ldots,i_d} \\sqrt{p_{i_1\\ldots i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:73
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:86
msgid "where :math:`p_{i_1\\ldots i_d}` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i_j` is mapped to the right interval using the affine map:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:75
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:88
msgid "\\{0, \\ldots, 2^{n_j}-1\\} \\ni i_j \\mapsto \\frac{\\text{high}_j - \\text{low}_j}{2^{n_j} - 1} * i_j + \\text{low}_j \\in [\\text{low}_j, \\text{high}_j].\n\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:77
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:90
msgid "For simplicity, we assume both stock prices are independent and identically distributed. This assumption just simplifies the parametrization below and can be easily relaxed to more complex and also correlated multivariate distributions. The only important assumption for the current implementation is that the discretization grid of the different dimensions has the same step size."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:173
msgid "The payoff function equals zero as long as the sum of the spot prices at maturity :math:`(S_T^1 + S_T^2)` is less than the strike price :math:`K` and then increases linearly. The implementation first uses a weighted sum operator to compute the sum of the spot prices into an ancilla register, and then uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_T^1 + S_T^2) \\geq K`. This ancilla is used to control the linear part of the payoff function."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:176
msgid "The linear part itself is approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation rescaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:192
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:209
msgid "Since the weighted sum operator (in its current implementation) can only sum up integers, we need to map from the original ranges to the representable range to estimate the result, and reverse this mapping before interpreting the result. The mapping essentially corresponds to the affine mapping described in the context of the uncertainty model above."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:419
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:614
msgid "We first verify the quantum circuit by simulating it and analyzing the resulting probability to measure the :math:`|1\\rangle` state in the objective qubit."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:522
msgid "Next we use amplitude estimation to estimate the expected payoff."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:9
msgid "*Pricing Asian Barrier Spreads*"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:23
msgid "An Asian barrier spread is a combination of 3 different option types, and as such, combines multiple possible features that the Qiskit Finance option pricing framework supports:"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:25
msgid "Asian option: The payoff depends on the average price over the considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:26
msgid "Barrier Option: The payoff is zero if a certain threshold is exceeded at any time within the considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:27
msgid "(Bull) Spread: The payoff follows a piecewise linear function (depending on the average price) starting at zero, increasing linear, staying constant."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:29
msgid "Suppose strike prices :math:`K_1 < K_2` and time periods :math:`t=1,2`, with corresponding spot prices :math:`(S_1, S_2)` following a given multivariate distribution (e.g. generated by some stochastic process), and a barrier threshold :math:`B>0`. The corresponding payoff function is defined as"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:31
msgid "P(S_1, S_2) =\n"
"\\begin{cases}\n"
"\\min\\left\\{\\max\\left\\{\\frac{1}{2}(S_1 + S_2) - K_1, 0\\right\\}, K_2 - K_1\\right\\}, & \\text{ if } S_1, S_2 \\leq B \\\\\n"
"0, & \\text{otherwise.}\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:40
msgid "In the following, a quantum algorithm based on amplitude estimation is used to estimate the expected payoff, i.e., the fair price before discounting, for the option"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:42
msgid "\\mathbb{E}\\left[ P(S_1, S_2) \\right].\n\n"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:186
msgid "For simplicity, we consider the sum of the spot prices instead of their average. The result can be transformed to the average by just dividing it by 2."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:188
msgid "The payoff function equals zero as long as the sum of the spot prices :math:`(S_1 + S_2)` is less than the strike price :math:`K_1` and then increases linearly until the sum of the spot prices reaches :math:`K_2`. Then payoff stays constant to :math:`K_2 - K_1` unless any of the two spot prices exceeds the barrier threshold :math:`B`, then the payoff goes immediately down to zero. The implementation first uses a weighted sum operator to compute the sum of the spot prices into an ancilla register, and then uses a comparator, that flips an ancilla qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_1 + S_2) \\geq K_1` and another comparator/ancilla to capture the case that :math:`(S_1 + S_2) \\geq K_2`. These ancillas are used to control the linear part of the payoff function."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:191
msgid "In addition, we add another ancilla variable for each time step and use additional comparators to check whether :math:`S_1`, respectively :math:`S_2`, exceed the barrier threshold :math:`B`. The payoff function is only applied if :math:`S_1, S_2 \\leq B`."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:193
msgid "The linear part itself is approximated as follows. We exploit the fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. Thus, for a given approximation scaling factor :math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:720
msgid "Next we use amplitude estimation to estimate the expected payoff. Note that this can take a while since we are simulating a large number of qubits. The way we designed the operator (asian_barrier_spread) implies that the number of actual state qubits is significantly smaller, thus, helping to reduce the overall simulation time a bit."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:9
msgid "*Pricing Fixed-Income Assets*"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:23
msgid "We seek to price a fixed-income asset knowing the distributions describing the relevant interest rates. The cash flows :math:`c_t` of the asset and the dates at which they occur are known. The total value :math:`V` of the asset is thus the expectation value of:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:25
msgid "V = \\sum_{t=1}^T \\frac{c_t}{(1+r_t)^t}\n\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:27
msgid "Each cash flow is treated as a zero coupon bond with a corresponding interest rate :math:`r_t` that depends on its maturity. The user must specify the distribution modeling the uncertainty in each :math:`r_t` (possibly correlated) as well as the number of qubits he wishes to use to sample each distribution. In this example we expand the value of the asset to first order in the interest rates :math:`r_t`. This corresponds to studying the asset in terms of its duration. The approximation of the objective function follows the following paper: Quantum Risk Analysis. Woerner, Egger. 2018."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:68
msgid "We construct a circuit factory to load a multivariate normal random distribution in :math:`d` dimensions into a quantum state. The distribution is truncated to a given box :math:`\\otimes_{i=1}^d [low_i, high_i]` and discretized using :math:`2^{n_i}` grid points, where :math:`n_i` denotes the number of qubits used for dimension :math:`i = 1,\\ldots, d`. The unitary operator corresponding to the circuit factory implements the following:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:70
msgid "\\big|0\\rangle_{n_1}\\ldots\\big|0\\rangle_{n_d} \\mapsto \\big|\\psi\\rangle = \\sum_{i_1=0}^{2^n_-1}\\ldots\\sum_{i_d=0}^{2^n_-1} \\sqrt{p_{i_1,...,i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:72
msgid "where :math:`p_{i_1, ..., i_d}` denote the probabilities corresponding to the truncated and discretized distribution and where :math:`i_j` is mapped to the right interval :math:`[low_j, high_j]` using the affine map:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:74
msgid "\\{0, \\ldots, 2^{n_{j}}-1\\} \\ni i_j \\mapsto \\frac{high_j - low_j}{2^{n_j} - 1} * i_j + low_j \\in [low_j, high_j].\n\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:76
msgid "In addition to the uncertainty model, we can also apply an affine map, e.g. resulting from a principal component analysis. The interest rates used are then given by:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:78
msgid "\\vec{r} = A * \\vec{x} + b,\n\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:80
msgid "where :math:`\\vec{x} \\in \\otimes_{i=1}^d [low_i, high_i]` follows the given random distribution."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:155
msgid "Cash flow, payoff function, and exact expected value"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:157
msgid "In the following we define the cash flow per period, the resulting payoff function and evaluate the exact expected value."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:159
msgid "For the payoff function we first use a first order approximation and then apply the same approximation technique as for the linear part of the payoff function of the `European Call Option <03_european_call_option_pricing.ipynb>`__."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:9
msgid "*Credit Risk Analysis*"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:23
msgid "This tutorial shows how quantum algorithms can be used for credit risk analysis. More precisely, how Quantum Amplitude Estimation (QAE) can be used to estimate risk measures with a quadratic speed-up over classical Monte Carlo simulation. The tutorial is based on the following papers:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:25
msgid "`Quantum Risk Analysis. Stefan Woerner, Daniel J. Egger. <https://www.nature.com/articles/s41534-019-0130-6>`__ [Woerner2019]"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:26
msgid "`Credit Risk Analysis using Quantum Computers. Egger et al. (2019) <https://arxiv.org/abs/1907.03044>`__ [Egger2019]"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:28
msgid "A general introduction to QAE can be found in the following paper:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:30
msgid "`Quantum Amplitude Amplification and Estimation. Gilles Brassard et al. <http://arxiv.org/abs/quant-ph/0005055>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:32
msgid "The structure of the tutorial is as follows:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:34
msgid "`Problem Definition <#Problem-Definition>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:35
msgid "`Uncertainty Model <#Uncertainty-Model>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:36
msgid "`Expected Loss <#Expected-Loss>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:37
msgid "`Cumulative Distribution Function <#Cumulative-Distribution-Function>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:38
msgid "`Value at Risk <#Value-at-Risk>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:39
msgid "`Conditional Value at Risk <#Conditional-Value-at-Risk>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:67
msgid "Problem Definition"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:69
msgid "In this tutorial we want to analyze the credit risk of a portfolio of :math:`K` assets. The default probability of every asset :math:`k` follows a *Gaussian Conditional Independence* model, i.e., given a value :math:`z` sampled from a latent random variable :math:`Z` following a standard normal distribution, the default probability of asset :math:`k` is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:71
msgid "p_k(z) = F\\left( \\frac{F^{-1}(p_k^0) - \\sqrt{\\rho_k}z}{\\sqrt{1 - \\rho_k}} \\right)\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:73
msgid "where :math:`F` denotes the cumulative distribution function of :math:`Z`, :math:`p_k^0` is the default probability of asset :math:`k` for :math:`z=0` and :math:`\\rho_k` is the sensitivity of the default probability of asset :math:`k` with respect to :math:`Z`. Thus, given a concrete realization of :math:`Z` the individual default events are assumed to be independent from each other."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:75
msgid "We are interested in analyzing risk measures of the total loss"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:77
msgid "L = \\sum_{k=1}^K \\lambda_k X_k(Z)\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:79
msgid "where :math:`\\lambda_k` denotes the *loss given default* of asset :math:`k`, and given :math:`Z`, :math:`X_k(Z)` denotes a Bernoulli variable representing the default event of asset :math:`k`. More precisely, we are interested in the expected value :math:`\\mathbb{E}[L]`, the Value at Risk (VaR) of :math:`L` and the Conditional Value at Risk of :math:`L` (also called Expected Shortfall). Where VaR and CVaR are defined as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:81
msgid "\\text{VaR}_{\\alpha}(L) = \\inf \\{ x \\mid \\mathbb{P}[L <= x] \\geq 1 - \\alpha \\}\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:83
msgid "with confidence level :math:`\\alpha \\in [0, 1]`, and"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:85
msgid "\\text{CVaR}_{\\alpha}(L) = \\mathbb{E}[ L \\mid L \\geq \\text{VaR}_{\\alpha}(L) ].\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:87
msgid "For more details on the considered model, see, e.g., Regulatory Capital Modeling for Credit Risk. Marek Rutkowski, Silvio Tarca"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:89
msgid "The problem is defined by the following parameters: - number of qubits used to represent :math:`Z`, denoted by :math:`n_z` - truncation value for :math:`Z`, denoted by :math:`z_{\\text{max}}`, i.e., Z is assumed to take :math:`2^{n_z}` equidistant values in :math:`\\{-z_{max}, ..., +z_{max}\\}` - the base default probabilities for each asset :math:`p_0^k \\in (0, 1)`, :math:`k=1, ..., K` - sensitivities of the default probabilities with respect to :math:`Z`, denoted by :math:`\\rho_k \\in [0, 1)` - loss given default for asset :math:`k`, denoted by :math:`\\lambda_k` - confidence level for VaR / CVaR :math:`\\alpha \\in [0, 1]`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:122
msgid "We now construct a circuit that loads the uncertainty model. This can be achieved by creating a quantum state in a register of :math:`n_z` qubits that represents :math:`Z` following a standard normal distribution. This state is then used to control single qubit Y-rotations on a second qubit register of :math:`K` qubits, where a :math:`|1\\rangle` state of qubit :math:`k` represents the default event of asset :math:`k`. The resulting quantum state can be written as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:124
msgid " |\\Psi\\rangle = \\sum_{i=0}^{2^{n_z}-1} \\sqrt{p_z^i} |z_i \\rangle \\bigotimes_{k=1}^K\n"
"\\left( \\sqrt{1 - p_k(z_i)}|0\\rangle + \\sqrt{p_k(z_i)}|1\\rangle\\right),"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:129
msgid "where we denote by :math:`z_i` the :math:`i`-th value of the discretized and truncated :math:`Z` [Egger2019]."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:218
msgid "We now use the simulator to validate the circuit that constructs :math:`|\\Psi\\rangle` and compute the corresponding exact values for - expected loss :math:`\\mathbb{E}[L]` - PDF and CDF of :math:`L` - value at risk :math:`VaR(L)` and corresponding probability - conditional value at risk :math:`CVaR(L)`"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:435
msgid "Expected Loss"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:437
msgid "To estimate the expected loss, we first apply a weighted sum operator to sum up individual losses to total loss:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:439
msgid "\\mathcal{S}: |x_1, ..., x_K \\rangle_K |0\\rangle_{n_S} \\mapsto |x_1, ..., x_K \\rangle_K |\\lambda_1x_1 + ... + \\lambda_K x_K\\rangle_{n_S}.\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:441
msgid "The required number of qubits to represent the result is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:443
msgid "n_s = \\lfloor \\log_2( \\lambda_1 + ... + \\lambda_K ) \\rfloor + 1.\n\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:445
msgid "Once we have the total loss distribution in a quantum register, we can use the techniques described in [Woerner2019] to map a total loss :math:`L \\in \\{0, ..., 2^{n_s}-1\\}` to the amplitude of an objective qubit by an operator"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:447
msgid " | L \\rangle_{n_s}|0\\rangle \\mapsto\n"
"| L \\rangle_{n_s} \\left( \\sqrt{1 - L/(2^{n_s}-1)}|0\\rangle + \\sqrt{L/(2^{n_s}-1)}|1\\rangle \\right),"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:452
msgid "which allows to run amplitude estimation to evaluate the expected loss."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:504
msgid "Create the state preparation circuit:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:628
msgid "Before we use QAE to estimate the expected loss, we validate the quantum circuit representing the objective function by just simulating it directly and analyzing the probability of the objective qubit being in the :math:`|1\\rangle` state, i.e., the value QAE will eventually approximate."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:692
msgid "Next we run QAE to estimate the expected loss with a quadratic speed-up over classical Monte Carlo simulation."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:753
msgid "Cumulative Distribution Function"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:755
msgid "Instead of the expected loss (which could also be estimated efficiently using classical techniques) we now estimate the cumulative distribution function (CDF) of the loss. Classically, this either involves evaluating all the possible combinations of defaulting assets, or many classical samples in a Monte Carlo simulation. Algorithms based on QAE have the potential to significantly speed up this analysis in the future."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:757
msgid "To estimate the CDF, i.e., the probability :math:`\\mathbb{P}[L \\leq x]`, we again apply :math:`\\mathcal{S}` to compute the total loss, and then apply a comparator that for a given value :math:`x` acts as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:759
msgid " \\mathcal{C}: |L\\rangle_n|0> \\mapsto\n"
"\\begin{cases}\n"
"|L\\rangle_n|1> & \\text{if}\\quad L \\leq x \\\\\n"
"|L\\rangle_n|0> & \\text{if}\\quad L > x.\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:767
msgid "The resulting quantum state can be written as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:769
msgid " \\sum_{L = 0}^{x} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle +\n"
"\\sum_{L = x+1}^{2^{n_s}-1} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle,"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:774
msgid "where we directly assume the summed up loss values and corresponding probabilities instead of presenting the details of the uncertainty model."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:776
msgid "The CDF(\\ :math:`x`) equals the probability of measuring :math:`|1\\rangle` in the objective qubit and QAE can be directly used to estimate it."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:894
#: ../../tutorials/09_credit_risk_analysis.ipynb:1460
msgid "Again, we first use quantum simulation to validate the quantum circuit."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1045
msgid "Next we run QAE to estimate the CDF for a given :math:`x`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1105
msgid "Value at Risk"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1107
msgid "In the following we use a bisection search and QAE to efficiently evaluate the CDF to estimate the value at risk."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1296
msgid "Conditional Value at Risk"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1298
msgid "Last, we compute the CVaR, i.e. the expected value of the loss conditional to it being larger than or equal to the VaR. To do so, we evaluate a piecewise linear objective function :math:`f(L)`, dependent on the total loss :math:`L`, that is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1300
msgid "f(L) = \\begin{cases}\n"
"0 & \\text{if}\\quad L \\leq VaR \\\\\n"
"L & \\text{if}\\quad L > VaR.\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1308
msgid "To normalize, we have to divide the resulting expected value by the VaR-probability, i.e. \\ :math:`\\mathbb{P}[L \\leq VaR]`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1526
msgid "Next we run QAE to estimate the CVaR."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:9
msgid "*Option Pricing with qGANs*"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:14
msgid "In this notebook, we discuss how a Quantum Machine Learning Algorithm, namely a quantum Generative Adversarial Network (qGAN), can facilitate the pricing of a European call option. More specifically, a qGAN can be trained such that a quantum circuit models the spot price of an asset underlying a European call option. The resulting model can then be integrated into a Quantum Amplitude Estimation based algorithm to evaluate the expected payoff - see `European Call Option Pricing <03_european_call_option_pricing.ipynb>`__. For further details on learning and loading random distributions by training a qGAN please refer to Quantum Generative Adversarial Networks for Learning and Loading Random Distributions. Zoufal, Lucchi, Woerner. 2019."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:50
msgid "The Black-Scholes model assumes that the spot price at maturity :math:`S_T` for a European call option is log-normally distributed. Thus, we can train a qGAN on samples from a log-normal distribution and use the result as an uncertainty model underlying the option. In the following, we construct a quantum circuit that loads the uncertainty model. The circuit output reads"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:52
msgid "\\big| g_{\\theta}\\rangle = \\sum_{j=0}^{2^n-1}\\sqrt{p_{\\theta}^{j}} \\big| j \\rangle ,\n\n"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:54
msgid "where the probabilities :math:`p_{\\theta}^{j}`, for :math:`j\\in \\left\\{0, \\ldots, {2^n-1} \\right\\}`, represent a model of the target distribution."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:97
msgid "Now, the trained uncertainty model can be used to evaluate the expectation value of the option’s payoff function with Quantum Amplitude Estimation."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:123
msgid "Plot the probability distribution"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:125
msgid "Next, we plot the trained probability distribution and, for reasons of comparison, also the target probability distribution."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:193
msgid "Now, the trained uncertainty model can be used to evaluate the expectation value of the option’s payoff function analytically and with Quantum Amplitude Estimation."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:9
msgid "*Loading and Processing Stock-Market Time-Series Data*"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:23
msgid "Across many problems in finance, one starts with time series. Here, we showcase how to generate pseudo-random time-series, download actual stock-market time series from a number of common providers, and how to compute time-series similarity measures."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:64
msgid "Once the data are loaded, you can run a variety of algorithms on those to aggregate the data. Notably, you can compute the covariance matrix or a variant, which would consider alternative time-series similarity measures based on dynamic time warping (DTW). In DTW, changes that vary in speed, e.g., one stock’s price following another stock’s price with a small delay, can be accommodated."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:168
msgid "If you wish, you can look into the underlying pseudo-random time-series using. Please note that the private class members (starting with underscore) may change in future releases of Qiskit."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:252
msgid "Clearly, you can adapt the number and names of tickers and the range of dates:"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:291
msgid "Access to closing-price time-series"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:293
msgid "While the access to real-time data usually requires a payment, it is possible to access historical (adjusted) closing prices via Wikipedia and Quandl free of charge, following registration at: https://www.quandl.com/?modal=register In the code below, one needs to specify actual tickers of actual NASDAQ issues and the access token you obtain from Quandl; by running the code below, you agree to the Quandl terms and conditions, including a liability waiver. Notice that at least two tickers are required for the computation of covariance and time-series matrices, but hundreds of tickers may go beyond the fair usage limits of Quandl."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:328
msgid "Once the data are loaded, you can again compute the covariance matrix or its DTW variants."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:366
msgid "If you wish, you can look into the underlying time-series using:"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:401
msgid "[Optional] Setup token to access recent, fine-grained time-series"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:403
msgid "If you would like to download professional data, you will have to set-up a token with one of the major providers. Let us now illustrate the data with NASDAQ Data on Demand, which can supply bid and ask prices in arbitrary resolution, as well as aggregates such as daily adjusted closing prices, for NASDAQ and NYSE issues."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:414
msgid "If you don’t have NASDAQ Data on Demand license, you can contact NASDAQ (cf. https://business.nasdaq.com/intel/GIS/Nasdaq-Data-on-Demand.html) to obtain a trial or paid license."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:416
msgid "If and when you have access to NASDAQ Data on Demand using your own token, you should replace REPLACE-ME below with the token. To assure the security of the connection, you should also have your own means of validating NASDAQ’s certificates. The DataOnDemandProvider constructor has an optional argument ``verify``, which can be ``None`` or a string or a boolean. If it is ``None``, certify certificates will be used (default). If verify is a string, it should be pointing to a certificate for the HTTPS connection to NASDAQ (dataondemand.nasdaq.com), either in the form of a CA_BUNDLE file or a directory wherein to look."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:453
msgid "Another major vendor of stock market data is Exchange Data International (EDI), whose API can be used to query over 100 emerging and frontier markets that are Africa, Asia, Far East, Latin America and Middle East, as well as the more established ones. See: https://www.exchange-data.com/pricing-data/adjusted-prices.php#exchange-coverage for an overview of the coverage."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:455
msgid "The access again requires a valid access token to replace REPLACE-ME below. The token can be obtained on a trial or paid-for basis at: https://www.quandl.com/"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:493
msgid "One can also access Yahoo Finance Data, no token needed, from Yahoo! Finance."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:535
msgid "For the actual use of the data, please see the portfolio_optimization or portfolio_diversification notebooks."
msgstr ""

#: ../../tutorials/index.rst:3
msgid "Finance Tutorials"
msgstr ""


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, 2021, Qiskit Finance Development Team
# This file is distributed under the same license as the Qiskit Finance
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit Finance 0.2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-12 22:17+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../tutorials/01_portfolio_optimization.ipynb:13
#: ../../tutorials/02_portfolio_diversification.ipynb:13
#: ../../tutorials/03_european_call_option_pricing.ipynb:13
#: ../../tutorials/04_european_put_option_pricing.ipynb:13
#: ../../tutorials/05_bull_spread_pricing.ipynb:13
#: ../../tutorials/06_basket_option_pricing.ipynb:13
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:13
#: ../../tutorials/08_fixed_income_pricing.ipynb:13
#: ../../tutorials/09_credit_risk_analysis.ipynb:13
#: ../../tutorials/10_qgan_option_pricing.ipynb:13
#: ../../tutorials/11_time_series.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:9
msgid "Portfolio Optimization"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:21
#: ../../tutorials/02_portfolio_diversification.ipynb:12
#: ../../tutorials/03_european_call_option_pricing.ipynb:21
#: ../../tutorials/04_european_put_option_pricing.ipynb:21
#: ../../tutorials/05_bull_spread_pricing.ipynb:21
#: ../../tutorials/06_basket_option_pricing.ipynb:21
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:21
#: ../../tutorials/08_fixed_income_pricing.ipynb:21
#: ../../tutorials/09_credit_risk_analysis.ipynb:21
#: ../../tutorials/10_qgan_option_pricing.ipynb:12
#: ../../tutorials/11_time_series.ipynb:21
msgid "Introduction"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:23
msgid ""
"This tutorial shows how to solve the following mean-variance portfolio "
"optimization problem for :math:`n` assets:"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:25
msgid ""
"\\begin{aligned}\n"
"\\min_{x \\in \\{0, 1\\}^n}  q x^T \\Sigma x - \\mu^T x\\\\\n"
"\\text{subject to: } 1^T x = B\n"
"\\end{aligned}"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:32
msgid "where we use the following notation:"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:34
msgid ""
":math:`x \\in \\{0, 1\\}^n` denotes the vector of binary decision "
"variables, which indicate which assets to pick (:math:`x[i] = 1`) and "
"which not to pick (:math:`x[i] = 0`),"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:35
msgid ""
":math:`\\mu \\in \\mathbb{R}^n` defines the expected returns for the "
"assets,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:36
msgid ""
":math:`\\Sigma \\in \\mathbb{R}^{n \\times n}` specifies the covariances "
"between the assets,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:37
msgid ":math:`q > 0` controls the risk appetite of the decision maker,"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:38
msgid ""
"and :math:`B` denotes the budget, i.e. the number of assets to be "
"selected out of :math:`n`."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:40
msgid ""
"We assume the following simplifications: - all assets have the same price"
" (normalized to 1), - the full budget :math:`B` has to be spent, i.e. one"
" has to select exactly :math:`B` assets."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:42
msgid ""
"The equality constraint :math:`1^T x = B` is mapped to a penalty term "
":math:`(1^T x - B)^2` which is scaled by a parameter and subtracted from "
"the objective function. The resulting problem can be mapped to a "
"Hamiltonian whose ground state corresponds to the optimal solution. This "
"notebook shows how to use the Variational Quantum Eigensolver (VQE) or "
"the Quantum Approximate Optimization Algorithm (QAOA) to find the optimal"
" solution for a given set of parameters."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:44
msgid ""
"Experiments on real quantum hardware for this problem are reported for "
"instance in the following paper: `Improving Variational Quantum "
"Optimization using CVaR. Barkoutsos et al. 2019. "
"<https://arxiv.org/abs/1907.04769>`__"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:78
msgid "[Optional] Setup token to run the experiment on a real device"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:80
msgid ""
"If you would like to run the experiment on a real device, you need to "
"setup your account first."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:82
msgid ""
"Note: If you do not store your token yet, use "
"``IBMQ.save_account('MY_API_TOKEN')`` to store it first."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:94
msgid "Define problem instance"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:96
msgid ""
"Here an Operator instance is created for our Hamiltonian. In this case "
"the paulis are from an Ising Hamiltonian translated from the portfolio "
"problem. We use a random portfolio problem for this notebook. It is "
"straight-forward to extend this to using real financial data as "
"illustrated here: `Loading and Processing Stock-Market Time-Series Data "
"<11_time_series.ipynb>`__"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:236
msgid "We define some utility methods to print the results in a nice format."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:280
msgid "NumPyMinimumEigensolver (as a classical reference)"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:282
msgid "Lets solve the problem. First classically…"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:284
msgid ""
"We can now use the Operator we built above without regard to the "
"specifics of how it was created. We set the algorithm for the "
"NumPyMinimumEigensolver so we can have a classical reference. The problem"
" is set for ‘ising’. Backend is not required since this is computed "
"classically not using quantum computation. The result is returned as a "
"dictionary."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:370
msgid "Solution using VQE"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:372
msgid ""
"We can now use the Variational Quantum Eigensolver (VQE) to solve the "
"problem. We will specify the optimizer and variational form to be used."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:374
msgid ""
"Note: You can switch to different backends by providing the name of "
"backend."
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:468
msgid "Solution using QAOA"
msgstr ""

#: ../../tutorials/01_portfolio_optimization.ipynb:470
msgid ""
"We also show here a result using the Quantum Approximate Optimization "
"Algorithm (QAOA). This is another variational algorithm and it uses an "
"internal variational form that is created based on the problem."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:9
msgid "Portfolio Diversification"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:14
msgid ""
"In asset management, there are broadly two approaches: active and passive"
" investment management. Within passive investment management, there are "
"index-tracking funds and there are approaches based on portfolio "
"diversification, which aim at representing a portfolio with a large "
"number of assets by a smaller number of representative stocks. This "
"notebook illustrates a portfolio diversification problem, which has "
"recently become popular for two reasons: 1. it makes it possible to mimic"
" the performance of an index (or a similarly large set of assets) with a "
"limited budget, at limited transaction costs. That is: traditional index-"
"tracking may purchase all assets in the index, ideally with the same "
"weights as in the index. This may be impractical for a number of reasons:"
" the total of even a single round lot per asset may amount to more than "
"the assets under management, the large scale of the index-tracking "
"problem with integrality constraints may render the optimization problem "
"difficult, and the transaction costs of the frequent rebalancing to "
"adjust the positions to the weights in the index may render the approach "
"expensive. Thus, a popular approach is to select a portfolio of :math:`q`"
" assets that represent the market with :math:`n` assets, where :math:`q` "
"is significantly smaller than :math:`n`, but where the portfolio "
"replicates the behavior of the underlying market. To determine how to "
"group assets into :math:`q` clusters and how to determine which :math:`q`"
" assets should represent the :math:`q` clusters amounts to solving a "
"large-scale optimization problem. In the following we describe the "
"mathematical model for the portfolio diversification problem as "
"introduced in [Cornuejols & Tutuncu, 2006] 2. it allows for similarity "
"measures between time-series beyond the covariance matrix. Notice that "
"traditionally, modern portfolio theory considers the covariance matrix as"
" a measure of similarity between the assets. As such, however, the "
"covariance matrix is imperfect. Consider, for instance, a company listed "
"both in London and New York. Although both listings should be very "
"similar, only parts of the time series of the prices of the two listings "
"will overlap, because of the partial overlap of the times the markets "
"open. Instead of covariance, one can consider, for example, dynamic time "
"warping of [Berndt and Clifford, 1994] as a measure of similarity between"
" two time series, which allows for the fact that for some time periods, "
"the data are captured by only one of the time series, while for others, "
"both time series exhibit the similarity due to the parallel evolution of "
"the stock price."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:21
msgid "The overall workflow we demonstrate comprises:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:23
msgid ""
"pick the ground set of assets. In our case, this is a small number of US "
"stocks."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:25
msgid ""
"load the time series capturing the evolution of the prices of assets. In "
"our case, this is a simplistic load of adjusted daily closing price data "
"from Wikipedia or Nasdaq or LSE or EuroNext, whereas in a real asset "
"management, a much higher frequency may be considered."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:27
msgid ""
"compute the pair-wise similarity among the time series. In our case, we "
"run a linear-time approximation of the dynamic time warping, still on the"
" classical computer."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:29
msgid ""
"compute the actual portfolio of :math:`q` representative assets, based on"
" the similarity measure. This step is run twice, actually. First, we "
"obtain a reference value by a run of an IBM solver (IBM ILOG CPLEX or the"
" Exact Eigensolver) on the classical computer. Second, we run an "
"alternative, hybrid algorithm partly on the quantum computer."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:31
msgid ""
"visualization of the results. In our case, this is again a simplistic "
"plot."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:33
msgid ""
"In the following, we first explain the model used in (4) above, before we"
" proceed with the installation of the pre-requisites and the data "
"loading."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:36
msgid "The Model"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:38
msgid ""
"As discussed in [Cornuejols & Tutuncu, 2006], we describe a mathematical "
"model that clusters assets into groups of similar ones and selects one "
"representative asset from each group to be included in the index fund "
"portfolio. The model is based on the following data, which we will "
"discuss in more detail later:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:40
msgid ""
"\\rho_{ij} = \\textrm{similarity}\\, \\textrm{between}\\, "
"\\textrm{stock}\\, i \\, \\textrm{and}\\, \\textrm{stock}\\, j."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:45
msgid ""
"For example, :math:`\\rho_{ii} = 1`, :math:`\\rho_{ij} \\leq 1` for "
":math:`i \\neq j` and :math:`\\rho_{ij}` is larger for more similar "
"stocks. An example of this is the correlation between the returns of "
"stocks :math:`i` and :math:`j`. But one could choose other similarity "
"indices :math:`\\rho_{ij}`."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:47
msgid "The problem that we are interested in solving is:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:49
msgid ""
"(M) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n \\sum_{j=1}^n "
"\\rho_{ij} x_{ij}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:54
msgid "subject to the clustering constraint:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:56
msgid "\\sum_{j=1}^n y_j = q,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:61
msgid "to consistency constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:63
msgid ""
"\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n"
"\\quad x_{ij} \\leq y_j,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j = "
"1,\\ldots, n,\n"
"\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:70
msgid "and integral constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:72
msgid ""
"\\quad  x_{ij}, y_j \\in\\{0,1\\}, \\,\\textrm{ for }\\,  i = 1,\\ldots, "
"n; \\, j = 1,\\ldots, n."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:77
msgid ""
"The variables :math:`y_j` describe which stocks :math:`j` are in the "
"index fund (:math:`y_j = 1` if :math:`j` is selected in the fund, "
":math:`0` otherwise). For each stock :math:`i = 1,\\dots,n`, the variable"
" :math:`x_{ij}` indicates which stock :math:`j` in the index fund is most"
" similar to :math:`i` (:math:`x_{ij} = 1` if :math:`j` is the most "
"similar stock in the index fund, :math:`0` otherwise)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:79
msgid ""
"The first constraint selects :math:`q` stocks in the fund. The second "
"constraint imposes that each stock :math:`i` has exactly one "
"representative stock :math:`j` in the fund. The third and fourth "
"constraints guarantee that stock :math:`i` can be represented by stock "
":math:`j` only if :math:`j` is in the fund. The objective of the model "
"maximizes the similarity between the :math:`n` stocks and their "
"representatives in the fund. Different cost functions can also be "
"considered."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:81
msgid "Let us concatenate the decision variables in one vector"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:83
msgid ""
"{\\bf z} = [x_{11},x_{12},\\ldots,x_{1n}, x_{22},\\ldots,x_{nn}, "
"y_{1},\\ldots,y_{n}],"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:88
msgid ""
"whose dimension is :math:`{\\bf z} \\in \\{0,1\\}^N`, with :math:`N = n "
"(n+1)` and denote the optimal solution with :math:`{\\bf z}^*`, and the "
"optimal cost :math:`f^*`."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:91
msgid "A Hybrid Approach"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:93
msgid ""
"Here, we demonstrate an approach that combines classical and quantum "
"computing steps, following the quantum approximate optimization approach "
"of Farhi, Goldstone, and Gutmann (2014)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:96
msgid "Construct a binary polynomial optimization"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:98
msgid ""
"From :math:`(M)` one can construct a binary polynomial optimization with "
"equality constraints only, by substituting the :math:`x_{ij} \\leq y_j` "
"inequality constraints with the equivalent equality constraints "
":math:`x_{ij} (1- y_j) = 0`. Then the problem becomes:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:100
msgid ""
"(BPO) \\quad  f = \\max_{x_{ij}, y_{j}} \\,\\, \\sum_{i=1}^n "
"\\sum_{j=1}^n \\rho_{ij} x_{ij}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:105
msgid ""
"subject to the clustering constraint, the integral constraints, and the "
"following modified consistency constraints:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:107
msgid ""
"\\sum_{j=1}^n x_{ij} = 1, \\,\\textrm{ for }\\,  i = 1,\\ldots, n,\n"
"\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:109
msgid ""
"\\quad x_{ij} (1- y_j) = 0,\\,\\textrm{ for }\\,  i = 1,\\ldots, n; \\, j"
" = 1,\\ldots, n,\n"
"\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:111
msgid ""
"\\quad x_{jj} = y_j,\\,\\textrm{ for }\\,  j = 1,\\ldots, n.\n"
"\n"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:114
msgid "Construct the Ising Hamiltonian"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:116
msgid ""
"We can now construct the Ising Hamiltonian (QUBO) by penalty methods "
"(introducing a penalty coefficient :math:`A` for each equality "
"constraint) as"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:118
msgid ""
"(IH) \\quad H = \\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} + A\\Big( "
"\\sum_{j=1}^n y_j - q\\Big)^2 + \\sum_{i=1}^n A\\Big( \\sum_{j=1}^n "
"x_{ij} - 1\\Big)^2 + \\sum_{j=1}^n A (x_{jj}-y_j)^2 +\\sum_{i=1}^n "
"\\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:124
msgid "From Hamiltonian to Quadratic Programming (QP) formulation"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:126
msgid ""
"In the vector :math:`{\\bf z}`, the Ising Hamiltonian elements can be "
"rewritten as follows,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:128
msgid "First term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:130
msgid ""
"\\sum_{i=1}^n \\sum_{j=1}^n \\rho_{ij} x_{ij} = "
"[\\rho_{11},\\rho_{12},\\ldots,\\rho_{1n}, "
"\\rho_{22},\\ldots,\\rho_{nn}|{\\bf 0}_n ]{\\bf z} =: {\\bf c}_0^T {\\bf "
"z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:135
msgid "Second term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:137
msgid ""
"A\\Big( \\sum_{j=1}^n y_j - q\\Big)^2 = A \\Big(\\sum_{j=1}^n y_j\\Big)^2"
" - 2 Aq \\sum_{j=1}^n y_j + A q^2 = A {\\bf z}^T "
"\\left[\\begin{array}{c}{\\bf 0}_{n^2} \\\\ \\hline  {\\bf 1}_n  "
"\\end{array}\\right]\\left[\\begin{array}{cc}{\\bf 0}_{n^2} | {\\bf 1}_n"
"  \\end{array}\\right]{\\bf z} - 2 A q [{\\bf 0}_{n^2}|{\\bf 1}_n]{\\bf "
"z} + A q^2 =: {\\bf z}^T {\\bf Q}_0 {\\bf z} + {\\bf c}_1^T {\\bf z} + "
"r_0"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:142
msgid "Third term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:144
msgid ""
"\\sum_{i=1}^n A\\Big( \\sum_{j=1}^n x_{ij} - 1\\Big)^2 = A\\sum_{i=1}^n "
"\\Big(\\sum_{j=1}^n x_{ij}\\Big)^2 - 2 A \\sum_{i=1}^n\\sum_{j=1}^n "
"x_{ij} + n A = \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:149
msgid "which is equivalent to:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:151
msgid ""
"\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad = A {\\bf z}^T "
"\\left(\\sum_{i=1}^n \\left[\\begin{array}{c}{\\bf 0}_{n(i-1)}  \\\\ "
"{\\bf 1}_n  \\\\ {\\bf 0}_{n(n-i)} \\\\ \\hline {\\bf 0}_{n} "
"\\end{array}\\right]\\left[\\begin{array}{cccc}{\\bf 0}_{n(i-1)} & {\\bf "
"1}_n  & {\\bf 0}_{n(n-i)} & | {\\bf 0}_{n} "
"\\end{array}\\right]\\right){\\bf z} - 2 A [{\\bf 1}_{n^2}|{\\bf "
"0}_n]{\\bf z} + n A =: {\\bf z}^T {\\bf Q}_1 {\\bf z} + {\\bf c}_2^T "
"{\\bf z} + r_1"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:156
msgid "Fourth term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:158
msgid ""
"A \\sum_{j=1}^n  (x_{jj}-y_j)^2 = A {\\bf z}^T  \\left(\\sum_{j=0}^{n-1} "
"\\left[\\begin{array}{c}{\\bf 0}_{nj + j}  \\\\ 1  \\\\ {\\bf "
"0}_{n^2-(nj+j+1)} \\\\ \\hline {\\bf 0}_{j} \\\\ -1 \\\\ {\\bf 0}_{n-j-1}"
" \\end{array}\\right]\\left[\\begin{array}{cccccc}{\\bf 0}_{nj + j} & 1  "
"& {\\bf 0}_{n^2-(nj+j+1)} & | {\\bf 0}_{j} & -1 & {\\bf 0}_{n-j-1}  "
"\\end{array}\\right]\\right){\\bf z} = A {\\bf z}^T {\\bf Q}_2 {\\bf z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:163
msgid "Fifth term:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:165
msgid ""
"\\sum_{i=1}^n \\sum_{j=1}^n A \\left(x_{ij} (1- y_j)\\right) = A [{\\bf "
"1}_{n^2}|{\\bf 0}_n]{\\bf z} + A {\\bf z}^T \\left( \\sum_{i=1}^n "
"\\sum_{j=1}^n \\left[\\begin{array}{ccc|c}  &  & & \\\\ & {\\bf "
"0}_{n^2\\times n^2} & & -1/2_{(ij,j)}  \\\\ & & & \\\\ \\hline & "
"-1/2_{(j, ij)} &  & {\\bf 0}_{n} \\end{array}\\right] \\right) {\\bf z} "
"=:  {\\bf z}^T {\\bf Q}_3 {\\bf z} + {\\bf c}_3^T {\\bf z}"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:170
msgid "Therefore, the formulation becomes,"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:172
msgid ""
"(IH-QP)\\quad \\max_{{\\bf z}\\in\\{0,1\\}^{n(n+1)}} \\, {\\bf z}^T "
"({\\bf Q}_0+{\\bf Q}_1+ {\\bf Q}_2 + {\\bf Q}_3 ){\\bf z} + ({\\bf "
"c}_0+{\\bf c}_1+{\\bf c}_2+{\\bf c}_3)^T {\\bf z} +r_0+r_1+r_2"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:177
msgid "which can be passed to the variational quantum eigensolver."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:180
msgid "References"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:182
msgid ""
"[1] G. Cornuejols, M. L. Fisher, and G. L. Nemhauser, *Location of bank "
"accounts to optimize float: an analytical study of exact and approximate "
"algorithms*, Management Science, vol. 23(8), 1997"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:184
msgid ""
"[2] E. Farhi, J. Goldstone, S. Gutmann e-print `arXiv 1411.4028, 2014 "
"<https://arxiv.org/abs/1411.4028>`__"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:186
msgid ""
"[3] G. Cornuejols and R. Tutuncu, `Optimization methods in finance "
"<http://web.math.ku.dk/~rolf/CT_FinOpt.pdf>`__, 2006"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:188
msgid ""
"[4] DJ. Berndt and J. Clifford, *Using dynamic time warping to find "
"patterns in time series*. In KDD workshop 1994 (Vol. 10, No. 16, pp. "
"359-370)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:190
msgid ""
"[5] `Max-Cut and Traveling Salesman Problem <https://github.com/Qiskit"
"/qiskit-"
"optimization/blob/main/docs/tutorials/06_examples_max_cut_and_tsp.ipynb>`__"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:202
msgid "The Implementation"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:204
msgid "First, we import the requisite modules."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:246
msgid ""
"Next, we download price data for two stocks and compute their pair-wise "
"similarity matrix (`dynamic time warping "
"<https://en.wikipedia.org/wiki/Dynamic_time_warping>`__ distance "
"normalized to (0,1] by taking the reciprocal). If this fails, e.g., due "
"to you being offline or exceeding the daily limit for accesses to the "
"stock-market data, we consider a constant matrix instead."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:278
msgid ""
"Now we decide on the number of clusters. This has to be smaller than the "
"number of stocks we have loaded."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:300
msgid "Classical solution using IBM ILOG CPLEX"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:302
msgid ""
"For a classical solution, we use IBM CPLEX. CPLEX is able to find the "
"exact solution of this problem. We first define a ClassicalOptimizer "
"class that encodes the problem in a way that CPLEX can solve, and then "
"instantiate the class and solve it."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:471
msgid ""
"Solution shows the selected stocks via the stars and in green the links "
"(via similarities) with other stocks that are represented in the fund by "
"the linked stock."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:483
msgid "Quantum Computing with IBM Q"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:485
msgid ""
"For the quantum solution, we use Qiskit. We first define a class "
"QuantumOptimizer that encodes the quantum approach to solve the problem "
"and then we instantiate it and solve it. We define the following methods "
"inside the class:"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:487
msgid ""
"``exact_solution`` : to make sure that the Ising Hamiltonian is correctly"
" encoded in the :math:`Z` basis, we can compute its eigendecomposition "
"classically, i.e., considering a symmetric matrix of dimension :math:`2^N"
" \\times 2^N`. For the problem at hand :math:`n=3`, that is :math:`N = "
"12`, seems to be the limit for many laptops;"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:488
msgid ""
"``vqe_solution`` : solves the problem :math:`(M)` via the variational "
"quantum eigensolver (VQE);"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:489
msgid ""
"``qaoa_solution`` : solves the problem :math:`(M)` via a Quantum "
"Approximate Optimization Algorithm (QAOA)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:557
msgid "Step 1"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:559
msgid ""
"Instantiate the quantum optimizer class with parameters: - the similarity"
" matrix ``rho``; - the number of assets and clusters ``n`` and ``q``;"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:582
msgid "Step 2"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:584
msgid "Encode the problem as a binary formulation (IH-QP)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:586
msgid ""
"Sanity check: make sure that the binary formulation in the quantum "
"optimizer is correct (i.e., yields the same cost given the same "
"solution)."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:643
msgid "Step 3"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:645
msgid "Encode the problem as an Ising Hamiltonian in the Z basis."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:647
msgid ""
"Sanity check: make sure that the formulation is correct (i.e., yields the"
" same cost given the same solution)"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:698
msgid "Step 4"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:700
msgid ""
"Solve the problem via VQE. Notice that depending on the number of qubits,"
" this can take a while: for 6 qubits it takes 15 minutes on a 2015 "
"Macbook Pro, for 12 qubits it takes more than 12 hours. For longer runs, "
"logging may be useful to observe the workings; otherwise, you just have "
"to wait until the solution is printed."
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:755
msgid "Step 5"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:757
msgid "Visualize the solution"
msgstr ""

#: ../../tutorials/02_portfolio_diversification.ipynb:832
msgid ""
"Solution shows the selected stocks via the stars and in green the links "
"(via similarities) with other stocks that are represented in the fund by "
"the linked stock. Keep in mind that VQE is a heuristic working on the QP "
"formulation of the Ising Hamiltonian, though. For suitable choices of A, "
"local optima of the QP formulation will be feasible solutions to the ILP."
" While for some small instances, as above, we can find optimal solutions "
"of the QP formulation which coincide with optima of the ILP, finding "
"optimal solutions of the ILP is harder than finding local optima of the "
"QP formulation, in general. Even within the VQE, one may provide stronger"
" guarantees, for specific variational forms (trial wave functions)."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:9
msgid "Pricing European Call Options"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:23
msgid ""
"Suppose a European call option with strike price :math:`K` and an "
"underlying asset whose spot price at maturity :math:`S_T` follows a given"
" random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:25
msgid ""
"\\max\\{S_T - K, 0\\}\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:27
#: ../../tutorials/04_european_put_option_pricing.ipynb:27
#: ../../tutorials/05_bull_spread_pricing.ipynb:27
#: ../../tutorials/06_basket_option_pricing.ipynb:27
msgid ""
"In the following, a quantum algorithm based on amplitude estimation is "
"used to estimate the expected payoff, i.e., the fair price before "
"discounting, for the option:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:29
msgid ""
"\\mathbb{E}\\left[ \\max\\{S_T - K, 0\\} \\right]\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:31
#: ../../tutorials/04_european_put_option_pricing.ipynb:31
#: ../../tutorials/05_bull_spread_pricing.ipynb:31
msgid ""
"as well as the corresponding :math:`\\Delta`, i.e., the derivative of the"
" option price with respect to the spot price, defined as:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[S_T \\geq K\\right]"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:38
#: ../../tutorials/04_european_put_option_pricing.ipynb:38
#: ../../tutorials/05_bull_spread_pricing.ipynb:38
#: ../../tutorials/06_basket_option_pricing.ipynb:31
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:44
msgid ""
"The approximation of the objective function and a general introduction to"
" option pricing and risk analysis on quantum computers are given in the "
"following papers:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:40
msgid ""
"`Quantum Risk Analysis. Woerner, Egger. 2018. "
"<https://www.nature.com/articles/s41534-019-0130-6>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:41
msgid ""
"`Option Pricing using Quantum Computers. Stamatopoulos et al. 2019. "
"<https://quantum-journal.org/papers/q-2020-07-06-291/>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:71
#: ../../tutorials/04_european_put_option_pricing.ipynb:82
#: ../../tutorials/05_bull_spread_pricing.ipynb:71
#: ../../tutorials/06_basket_option_pricing.ipynb:66
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:79
#: ../../tutorials/08_fixed_income_pricing.ipynb:66
#: ../../tutorials/09_credit_risk_analysis.ipynb:120
#: ../../tutorials/10_qgan_option_pricing.ipynb:48
msgid "Uncertainty Model"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:73
#: ../../tutorials/04_european_put_option_pricing.ipynb:84
#: ../../tutorials/05_bull_spread_pricing.ipynb:73
msgid ""
"We construct a circuit factory to load a log-normal random distribution "
"into a quantum state. The distribution is truncated to a given interval "
":math:`[\\text{low}, \\text{high}]` and discretized using :math:`2^n` "
"grid points, where :math:`n` denotes the number of qubits used. The "
"unitary operator corresponding to the circuit factory implements the "
"following:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:75
#: ../../tutorials/04_european_put_option_pricing.ipynb:86
#: ../../tutorials/05_bull_spread_pricing.ipynb:75
msgid ""
"\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = "
"\\sum_{i=0}^{2^n-1} \\sqrt{p_i}\\big|i\\rangle_{n},\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:77
#: ../../tutorials/04_european_put_option_pricing.ipynb:88
#: ../../tutorials/05_bull_spread_pricing.ipynb:77
msgid ""
"where :math:`p_i` denote the probabilities corresponding to the truncated"
" and discretized distribution and where :math:`i` is mapped to the right "
"interval using the affine map:"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:79
#: ../../tutorials/04_european_put_option_pricing.ipynb:90
#: ../../tutorials/05_bull_spread_pricing.ipynb:79
msgid ""
"\\{0, \\ldots, 2^n-1\\} \\ni i \\mapsto \\frac{\\text{high} - "
"\\text{low}}{2^n - 1} * i + \\text{low} \\in [\\text{low}, \\text{high}]."
"\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:159
#: ../../tutorials/04_european_put_option_pricing.ipynb:170
#: ../../tutorials/05_bull_spread_pricing.ipynb:158
#: ../../tutorials/06_basket_option_pricing.ipynb:171
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:184
msgid "Payoff Function"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:161
msgid ""
"The payoff function equals zero as long as the spot price at maturity "
":math:`S_T` is less than the strike price :math:`K` and then increases "
"linearly. The implementation uses a comparator, that flips an ancilla "
"qubit from :math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if "
":math:`S_T \\geq K`, and this ancilla is used to control the linear part "
"of the payoff function."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:163
#: ../../tutorials/05_bull_spread_pricing.ipynb:162
msgid ""
"The linear part itself is then approximated as follows. We exploit the "
"fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small "
":math:`|y|`. Thus, for a given approximation rescaling factor "
":math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we "
"consider"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:165
#: ../../tutorials/04_european_put_option_pricing.ipynb:176
#: ../../tutorials/05_bull_spread_pricing.ipynb:164
#: ../../tutorials/06_basket_option_pricing.ipynb:178
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:195
msgid ""
"\\sin^2( \\pi/2 * c_\\text{approx} * ( x - 1/2 ) + \\pi/4) \\approx "
"\\pi/2 * c_\\text{approx} * ( x - 1/2 ) + 1/2\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:167
#: ../../tutorials/04_european_put_option_pricing.ipynb:178
#: ../../tutorials/06_basket_option_pricing.ipynb:180
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:197
msgid "\\ for small :math:`c_\\text{approx}`."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:169
#: ../../tutorials/04_european_put_option_pricing.ipynb:180
#: ../../tutorials/05_bull_spread_pricing.ipynb:168
#: ../../tutorials/06_basket_option_pricing.ipynb:182
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:199
msgid "We can easily construct an operator that acts as"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:171
#: ../../tutorials/04_european_put_option_pricing.ipynb:182
#: ../../tutorials/05_bull_spread_pricing.ipynb:170
#: ../../tutorials/06_basket_option_pricing.ipynb:184
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:201
msgid ""
"\\big|x\\rangle \\big|0\\rangle \\mapsto \\big|x\\rangle \\left( "
"\\cos(a*x+b) \\big|0\\rangle + \\sin(a*x+b) \\big|1\\rangle \\right),\n"
"\n"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:173
#: ../../tutorials/04_european_put_option_pricing.ipynb:184
#: ../../tutorials/05_bull_spread_pricing.ipynb:172
#: ../../tutorials/06_basket_option_pricing.ipynb:186
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:203
msgid "using controlled Y-rotations."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:175
#: ../../tutorials/04_european_put_option_pricing.ipynb:186
#: ../../tutorials/05_bull_spread_pricing.ipynb:174
#: ../../tutorials/06_basket_option_pricing.ipynb:188
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:205
msgid ""
"Eventually, we are interested in the probability of measuring "
":math:`\\big|1\\rangle` in the last qubit, which corresponds to "
":math:`\\sin^2(a*x+b)`. Together with the approximation above, this "
"allows to approximate the values of interest. The smaller we choose "
":math:`c_\\text{approx}`, the better the approximation. However, since we"
" are then estimating a property scaled by :math:`c_\\text{approx}`, the "
"number of evaluation qubits :math:`m` needs to be adjusted accordingly."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:177
msgid ""
"For more details on the approximation, we refer to: `Quantum Risk "
"Analysis. Woerner, Egger. 2018. "
"<https://www.nature.com/articles/s41534-019-0130-6>`__"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:376
#: ../../tutorials/04_european_put_option_pricing.ipynb:306
#: ../../tutorials/05_bull_spread_pricing.ipynb:295
#: ../../tutorials/06_basket_option_pricing.ipynb:417
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:612
#: ../../tutorials/10_qgan_option_pricing.ipynb:95
#: ../../tutorials/10_qgan_option_pricing.ipynb:191
msgid "Evaluate Expected Payoff"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:537
msgid ""
"Instead of constructing these circuits manually, Qiskit’s finance module "
"offers the ``EuropeanCallPricing`` circuit, which already implements this"
" functionality as building block."
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:611
#: ../../tutorials/04_european_put_option_pricing.ipynb:383
#: ../../tutorials/05_bull_spread_pricing.ipynb:372
msgid "Evaluate Delta"
msgstr ""

#: ../../tutorials/03_european_call_option_pricing.ipynb:613
msgid ""
"The Delta is a bit simpler to evaluate than the expected payoff. "
"Similarly to the expected payoff, we use a comparator circuit and an "
"ancilla qubit to identify the cases where :math:`S_T > K`. However, since"
" we are only interested in the probability of this condition being true, "
"we can directly use this ancilla qubit as the objective qubit in "
"amplitude estimation without any further approximation."
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:9
msgid "Pricing European Put Options"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:23
msgid ""
"Suppose a European put option with strike price :math:`K` and an "
"underlying asset whose spot price at maturity :math:`S_T` follows a given"
" random distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:25
msgid ""
"\\max\\{K - S_T, 0\\}\n"
"\n"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:29
msgid ""
"\\mathbb{E}\\left[ \\max\\{K - S_T, 0\\} \\right]\n"
"\n"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:33
msgid "\\Delta = -\\mathbb{P}\\left[S_T \\leq K\\right]"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:40
#: ../../tutorials/05_bull_spread_pricing.ipynb:40
#: ../../tutorials/06_basket_option_pricing.ipynb:33
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:46
msgid ""
"`Quantum Risk Analysis. Woerner, Egger. 2018. "
"<https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:41
#: ../../tutorials/05_bull_spread_pricing.ipynb:41
#: ../../tutorials/06_basket_option_pricing.ipynb:34
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:47
msgid ""
"`Option Pricing using Quantum Computers. Stamatopoulos et al. 2019. "
"<https://arxiv.org/abs/1905.02666>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:172
msgid ""
"The payoff function decreases linearly with an increasing spot price at "
"maturity :math:`S_T` until it reaches zero for a spot price equal to the "
"strike price :math:`K`, it stays constant to zero for larger spot prices."
" The implementation uses a comparator, that flips an ancilla qubit from "
":math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`S_T \\leq "
"K`, and this ancilla is used to control the linear part of the payoff "
"function."
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:174
msgid ""
"The linear part itself is then approximated as follows. We exploit the "
"fact that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small "
":math:`|y|`. Thus, for a given approximation rescaling scaling factor "
":math:`c_\\text{approx} \\in [0, 1]` and :math:`x \\in [0, 1]` we "
"consider"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:188
#: ../../tutorials/05_bull_spread_pricing.ipynb:176
#: ../../tutorials/06_basket_option_pricing.ipynb:190
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:207
msgid ""
"For more details on the approximation, we refer to: `Quantum Risk "
"Analysis. Woerner, Egger. 2018. <https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/04_european_put_option_pricing.ipynb:385
msgid ""
"The Delta is a bit simpler to evaluate than the expected payoff. "
"Similarly to the expected payoff, we use a comparator circuit and an "
"ancilla qubit to identify the cases where :math:`S_T \\leq K`. However, "
"since we are only interested in the (negative) probability of this "
"condition being true, we can directly use this ancilla qubit as the "
"objective qubit in amplitude estimation without any further "
"approximation."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:9
msgid "Pricing Bull Spreads"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:23
msgid ""
"Suppose a `bull spread <http://www.theoptionsguide.com/bull-call-"
"spread.aspx>`__ with strike prices :math:`K_1 < K_2` and an underlying "
"asset whose spot price at maturity :math:`S_T` follows a given random "
"distribution. The corresponding payoff function is defined as:"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:25
msgid ""
"\\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\}\n"
"\n"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:29
msgid ""
"\\mathbb{E}\\left[ \\min\\{\\max\\{S_T - K_1, 0\\}, K_2 - K_1\\} \\right]"
"\n"
"\n"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:33
msgid "\\Delta = \\mathbb{P}\\left[K_1 \\leq S \\leq K_2\\right]"
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:160
msgid ""
"The payoff function equals zero as long as the spot price at maturity "
":math:`S_T` is less than the strike price :math:`K_1`, then increases "
"linearly, and is bounded by :math:`K_2`. The implementation uses two "
"comparators, that flip an ancilla qubit each from :math:`\\big|0\\rangle`"
" to :math:`\\big|1\\rangle` if :math:`S_T \\geq K_1` and :math:`S_T \\leq"
" K_2`, and these ancillas are used to control the linear part of the "
"payoff function."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:166
msgid "for small :math:`c_\\text{approx}`."
msgstr ""

#: ../../tutorials/05_bull_spread_pricing.ipynb:374
msgid ""
"The Delta is a bit simpler to evaluate than the expected payoff. "
"Similarly to the expected payoff, we use comparator circuits and ancilla "
"qubits to identify the cases where :math:`K_1 \\leq S_T \\leq K_2`. "
"However, since we are only interested in the probability of this "
"condition being true, we can directly use an ancilla qubit as the "
"objective qubit in amplitude estimation without any further "
"approximation."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:9
msgid "Pricing Basket Options"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:23
msgid ""
"Suppose a basket option with strike price :math:`K` and two underlying "
"assets whose spot price at maturity :math:`S_T^1`, :math:`S_T^2` follow "
"given random distributions. The corresponding payoff function is defined "
"as:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:25
msgid ""
"\\max\\{S_T^1 + S_T^2 - K, 0\\}\n"
"\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:29
msgid ""
"\\mathbb{E}\\left[ \\max\\{S_T^1 + S_T^2 - K, 0\\} \\right].\n"
"\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:68
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:81
msgid ""
"We construct a circuit factory to load a multivariate log-normal random "
"distribution into a quantum state on :math:`n` qubits. For every "
"dimension :math:`j = 1,\\ldots,d`, the distribution is truncated to a "
"given interval :math:`[\\text{low}_j, \\text{high}_j]` and discretized "
"using :math:`2^{n_j}` grid points, where :math:`n_j` denotes the number "
"of qubits used to represent dimension :math:`j`, i.e., "
":math:`n_1+\\ldots+n_d = n`. The unitary operator corresponding to the "
"circuit factory implements the following:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:71
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:84
msgid ""
"\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = "
"\\sum_{i_1,\\ldots,i_d} \\sqrt{p_{i_1\\ldots "
"i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n"
"\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:73
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:86
msgid ""
"where :math:`p_{i_1\\ldots i_d}` denote the probabilities corresponding "
"to the truncated and discretized distribution and where :math:`i_j` is "
"mapped to the right interval using the affine map:"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:75
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:88
msgid ""
"\\{0, \\ldots, 2^{n_j}-1\\} \\ni i_j \\mapsto \\frac{\\text{high}_j - "
"\\text{low}_j}{2^{n_j} - 1} * i_j + \\text{low}_j \\in [\\text{low}_j, "
"\\text{high}_j].\n"
"\n"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:77
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:90
msgid ""
"For simplicity, we assume both stock prices are independent and "
"identically distributed. This assumption just simplifies the "
"parametrization below and can be easily relaxed to more complex and also "
"correlated multivariate distributions. The only important assumption for "
"the current implementation is that the discretization grid of the "
"different dimensions has the same step size."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:173
msgid ""
"The payoff function equals zero as long as the sum of the spot prices at "
"maturity :math:`(S_T^1 + S_T^2)` is less than the strike price :math:`K` "
"and then increases linearly. The implementation first uses a weighted sum"
" operator to compute the sum of the spot prices into an ancilla register,"
" and then uses a comparator, that flips an ancilla qubit from "
":math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_T^1 + "
"S_T^2) \\geq K`. This ancilla is used to control the linear part of the "
"payoff function."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:176
msgid ""
"The linear part itself is approximated as follows. We exploit the fact "
"that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. "
"Thus, for a given approximation rescaling factor :math:`c_\\text{approx} "
"\\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:192
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:209
msgid ""
"Since the weighted sum operator (in its current implementation) can only "
"sum up integers, we need to map from the original ranges to the "
"representable range to estimate the result, and reverse this mapping "
"before interpreting the result. The mapping essentially corresponds to "
"the affine mapping described in the context of the uncertainty model "
"above."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:419
#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:614
msgid ""
"We first verify the quantum circuit by simulating it and analyzing the "
"resulting probability to measure the :math:`|1\\rangle` state in the "
"objective qubit."
msgstr ""

#: ../../tutorials/06_basket_option_pricing.ipynb:522
msgid "Next we use amplitude estimation to estimate the expected payoff."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:9
msgid "Pricing Asian Barrier Spreads"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:23
msgid ""
"An Asian barrier spread is a combination of 3 different option types, and"
" as such, combines multiple possible features that the Qiskit Finance "
"option pricing framework supports:"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:25
msgid ""
"`Asian option <https://www.investopedia.com/terms/a/asianoption.asp>`__: "
"The payoff depends on the average price over the considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:26
msgid ""
"`Barrier Option "
"<https://www.investopedia.com/terms/b/barrieroption.asp>`__: The payoff "
"is zero if a certain threshold is exceeded at any time within the "
"considered time horizon."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:27
msgid ""
"`(Bull) Spread <https://www.investopedia.com/terms/b/bullspread.asp>`__: "
"The payoff follows a piecewise linear function (depending on the average "
"price) starting at zero, increasing linear, staying constant."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:29
msgid ""
"Suppose strike prices :math:`K_1 < K_2` and time periods :math:`t=1,2`, "
"with corresponding spot prices :math:`(S_1, S_2)` following a given "
"multivariate distribution (e.g. generated by some stochastic process), "
"and a barrier threshold :math:`B>0`. The corresponding payoff function is"
" defined as"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:31
msgid ""
"P(S_1, S_2) =\n"
"\\begin{cases}\n"
"\\min\\left\\{\\max\\left\\{\\frac{1}{2}(S_1 + S_2) - K_1, 0\\right\\}, "
"K_2 - K_1\\right\\}, & \\text{ if } S_1, S_2 \\leq B \\\\\n"
"0, & \\text{otherwise.}\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:40
msgid ""
"In the following, a quantum algorithm based on amplitude estimation is "
"used to estimate the expected payoff, i.e., the fair price before "
"discounting, for the option"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:42
msgid ""
"\\mathbb{E}\\left[ P(S_1, S_2) \\right].\n"
"\n"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:186
msgid ""
"For simplicity, we consider the sum of the spot prices instead of their "
"average. The result can be transformed to the average by just dividing it"
" by 2."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:188
msgid ""
"The payoff function equals zero as long as the sum of the spot prices "
":math:`(S_1 + S_2)` is less than the strike price :math:`K_1` and then "
"increases linearly until the sum of the spot prices reaches :math:`K_2`. "
"Then payoff stays constant to :math:`K_2 - K_1` unless any of the two "
"spot prices exceeds the barrier threshold :math:`B`, then the payoff goes"
" immediately down to zero. The implementation first uses a weighted sum "
"operator to compute the sum of the spot prices into an ancilla register, "
"and then uses a comparator, that flips an ancilla qubit from "
":math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_1 + S_2) "
"\\geq K_1` and another comparator/ancilla to capture the case that "
":math:`(S_1 + S_2) \\geq K_2`. These ancillas are used to control the "
"linear part of the payoff function."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:191
msgid ""
"In addition, we add another ancilla variable for each time step and use "
"additional comparators to check whether :math:`S_1`, respectively "
":math:`S_2`, exceed the barrier threshold :math:`B`. The payoff function "
"is only applied if :math:`S_1, S_2 \\leq B`."
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:193
msgid ""
"The linear part itself is approximated as follows. We exploit the fact "
"that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. "
"Thus, for a given approximation scaling factor :math:`c_\\text{approx} "
"\\in [0, 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/07_asian_barrier_spread_pricing.ipynb:720
msgid ""
"Next we use amplitude estimation to estimate the expected payoff. Note "
"that this can take a while since we are simulating a large number of "
"qubits. The way we designed the operator (asian_barrier_spread) implies "
"that the number of actual state qubits is significantly smaller, thus, "
"helping to reduce the overall simulation time a bit."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:9
msgid "Pricing Fixed-Income Assets"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:23
msgid ""
"We seek to price a fixed-income asset knowing the distributions "
"describing the relevant interest rates. The cash flows :math:`c_t` of the"
" asset and the dates at which they occur are known. The total value "
":math:`V` of the asset is thus the expectation value of:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:25
msgid ""
"V = \\sum_{t=1}^T \\frac{c_t}{(1+r_t)^t}\n"
"\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:27
msgid ""
"Each cash flow is treated as a zero coupon bond with a corresponding "
"interest rate :math:`r_t` that depends on its maturity. The user must "
"specify the distribution modeling the uncertainty in each :math:`r_t` "
"(possibly correlated) as well as the number of qubits he wishes to use to"
" sample each distribution. In this example we expand the value of the "
"asset to first order in the interest rates :math:`r_t`. This corresponds "
"to studying the asset in terms of its duration. The approximation of the "
"objective function follows the following paper: `Quantum Risk Analysis. "
"Woerner, Egger. 2018. <https://arxiv.org/abs/1806.06893>`__"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:68
msgid ""
"We construct a circuit factory to load a multivariate normal random "
"distribution in :math:`d` dimensions into a quantum state. The "
"distribution is truncated to a given box :math:`\\otimes_{i=1}^d [low_i, "
"high_i]` and discretized using :math:`2^{n_i}` grid points, where "
":math:`n_i` denotes the number of qubits used for dimension :math:`i = "
"1,\\ldots, d`. The unitary operator corresponding to the circuit factory "
"implements the following:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:70
msgid ""
"\\big|0\\rangle_{n_1}\\ldots\\big|0\\rangle_{n_d} \\mapsto "
"\\big|\\psi\\rangle = \\sum_{i_1=0}^{2^n_-1}\\ldots\\sum_{i_d=0}^{2^n_-1}"
" "
"\\sqrt{p_{i_1,...,i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},"
"\n"
"\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:72
msgid ""
"where :math:`p_{i_1, ..., i_d}` denote the probabilities corresponding to"
" the truncated and discretized distribution and where :math:`i_j` is "
"mapped to the right interval :math:`[low_j, high_j]` using the affine "
"map:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:74
msgid ""
"\\{0, \\ldots, 2^{n_{j}}-1\\} \\ni i_j \\mapsto \\frac{high_j - "
"low_j}{2^{n_j} - 1} * i_j + low_j \\in [low_j, high_j].\n"
"\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:76
msgid ""
"In addition to the uncertainty model, we can also apply an affine map, "
"e.g. resulting from a principal component analysis. The interest rates "
"used are then given by:"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:78
msgid ""
"\\vec{r} = A * \\vec{x} + b,\n"
"\n"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:80
msgid ""
"where :math:`\\vec{x} \\in \\otimes_{i=1}^d [low_i, high_i]` follows the "
"given random distribution."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:155
msgid "Cash flow, payoff function, and exact expected value"
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:157
msgid ""
"In the following we define the cash flow per period, the resulting payoff"
" function and evaluate the exact expected value."
msgstr ""

#: ../../tutorials/08_fixed_income_pricing.ipynb:159
msgid ""
"For the payoff function we first use a first order approximation and then"
" apply the same approximation technique as for the linear part of the "
"payoff function of the `European Call Option "
"<03_european_call_option_pricing.ipynb>`__."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:9
msgid "Credit Risk Analysis"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:23
msgid ""
"This tutorial shows how quantum algorithms can be used for credit risk "
"analysis. More precisely, how Quantum Amplitude Estimation (QAE) can be "
"used to estimate risk measures with a quadratic speed-up over classical "
"Monte Carlo simulation. The tutorial is based on the following papers:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:25
msgid ""
"`Quantum Risk Analysis. Stefan Woerner, Daniel J. Egger. "
"<https://www.nature.com/articles/s41534-019-0130-6>`__ [Woerner2019]"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:26
msgid ""
"`Credit Risk Analysis using Quantum Computers. Egger et al. (2019) "
"<https://arxiv.org/abs/1907.03044>`__ [Egger2019]"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:28
msgid "A general introduction to QAE can be found in the following paper:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:30
msgid ""
"`Quantum Amplitude Amplification and Estimation. Gilles Brassard et al. "
"<http://arxiv.org/abs/quant-ph/0005055>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:32
msgid "The structure of the tutorial is as follows:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:34
msgid "`Problem Definition <#Problem-Definition>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:35
msgid "`Uncertainty Model <#Uncertainty-Model>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:36
msgid "`Expected Loss <#Expected-Loss>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:37
msgid "`Cumulative Distribution Function <#Cumulative-Distribution-Function>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:38
msgid "`Value at Risk <#Value-at-Risk>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:39
msgid "`Conditional Value at Risk <#Conditional-Value-at-Risk>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:67
msgid "Problem Definition"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:69
msgid ""
"In this tutorial we want to analyze the credit risk of a portfolio of "
":math:`K` assets. The default probability of every asset :math:`k` "
"follows a *Gaussian Conditional Independence* model, i.e., given a value "
":math:`z` sampled from a latent random variable :math:`Z` following a "
"standard normal distribution, the default probability of asset :math:`k` "
"is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:71
msgid ""
"p_k(z) = F\\left( \\frac{F^{-1}(p_k^0) - \\sqrt{\\rho_k}z}{\\sqrt{1 - "
"\\rho_k}} \\right)\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:73
msgid ""
"where :math:`F` denotes the cumulative distribution function of "
":math:`Z`, :math:`p_k^0` is the default probability of asset :math:`k` "
"for :math:`z=0` and :math:`\\rho_k` is the sensitivity of the default "
"probability of asset :math:`k` with respect to :math:`Z`. Thus, given a "
"concrete realization of :math:`Z` the individual default events are "
"assumed to be independent from each other."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:75
msgid "We are interested in analyzing risk measures of the total loss"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:77
msgid ""
"L = \\sum_{k=1}^K \\lambda_k X_k(Z)\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:79
msgid ""
"where :math:`\\lambda_k` denotes the *loss given default* of asset "
":math:`k`, and given :math:`Z`, :math:`X_k(Z)` denotes a Bernoulli "
"variable representing the default event of asset :math:`k`. More "
"precisely, we are interested in the expected value "
":math:`\\mathbb{E}[L]`, the Value at Risk (VaR) of :math:`L` and the "
"Conditional Value at Risk of :math:`L` (also called Expected Shortfall). "
"Where VaR and CVaR are defined as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:81
msgid ""
"\\text{VaR}_{\\alpha}(L) = \\inf \\{ x \\mid \\mathbb{P}[L <= x] \\geq 1 "
"- \\alpha \\}\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:83
msgid "with confidence level :math:`\\alpha \\in [0, 1]`, and"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:85
msgid ""
"\\text{CVaR}_{\\alpha}(L) = \\mathbb{E}[ L \\mid L \\geq "
"\\text{VaR}_{\\alpha}(L) ].\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:87
msgid ""
"For more details on the considered model, see, e.g., `Regulatory Capital "
"Modeling for Credit Risk. Marek Rutkowski, Silvio Tarca "
"<https://arxiv.org/abs/1412.1183>`__"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:89
msgid ""
"The problem is defined by the following parameters: - number of qubits "
"used to represent :math:`Z`, denoted by :math:`n_z` - truncation value "
"for :math:`Z`, denoted by :math:`z_{\\text{max}}`, i.e., Z is assumed to "
"take :math:`2^{n_z}` equidistant values in :math:`\\{-z_{max}, ..., "
"+z_{max}\\}` - the base default probabilities for each asset :math:`p_0^k"
" \\in (0, 1)`, :math:`k=1, ..., K` - sensitivities of the default "
"probabilities with respect to :math:`Z`, denoted by :math:`\\rho_k \\in "
"[0, 1)` - loss given default for asset :math:`k`, denoted by "
":math:`\\lambda_k` - confidence level for VaR / CVaR :math:`\\alpha \\in "
"[0, 1]`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:122
msgid ""
"We now construct a circuit that loads the uncertainty model. This can be "
"achieved by creating a quantum state in a register of :math:`n_z` qubits "
"that represents :math:`Z` following a standard normal distribution. This "
"state is then used to control single qubit Y-rotations on a second qubit "
"register of :math:`K` qubits, where a :math:`|1\\rangle` state of qubit "
":math:`k` represents the default event of asset :math:`k`. The resulting "
"quantum state can be written as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:124
msgid ""
" |\\Psi\\rangle = \\sum_{i=0}^{2^{n_z}-1} \\sqrt{p_z^i} |z_i \\rangle "
"\\bigotimes_{k=1}^K\n"
"\\left( \\sqrt{1 - p_k(z_i)}|0\\rangle + "
"\\sqrt{p_k(z_i)}|1\\rangle\\right),"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:129
msgid ""
"where we denote by :math:`z_i` the :math:`i`-th value of the discretized "
"and truncated :math:`Z` [Egger2019]."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:218
msgid ""
"We now use the simulator to validate the circuit that constructs "
":math:`|\\Psi\\rangle` and compute the corresponding exact values for - "
"expected loss :math:`\\mathbb{E}[L]` - PDF and CDF of :math:`L` - value "
"at risk :math:`VaR(L)` and corresponding probability - conditional value "
"at risk :math:`CVaR(L)`"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:435
msgid "Expected Loss"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:437
msgid ""
"To estimate the expected loss, we first apply a weighted sum operator to "
"sum up individual losses to total loss:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:439
msgid ""
"\\mathcal{S}: |x_1, ..., x_K \\rangle_K |0\\rangle_{n_S} \\mapsto |x_1, "
"..., x_K \\rangle_K |\\lambda_1x_1 + ... + \\lambda_K x_K\\rangle_{n_S}."
"\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:441
msgid "The required number of qubits to represent the result is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:443
msgid ""
"n_s = \\lfloor \\log_2( \\lambda_1 + ... + \\lambda_K ) \\rfloor + 1.\n"
"\n"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:445
msgid ""
"Once we have the total loss distribution in a quantum register, we can "
"use the techniques described in [Woerner2019] to map a total loss "
":math:`L \\in \\{0, ..., 2^{n_s}-1\\}` to the amplitude of an objective "
"qubit by an operator"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:447
msgid ""
" | L \\rangle_{n_s}|0\\rangle \\mapsto\n"
"| L \\rangle_{n_s} \\left( \\sqrt{1 - L/(2^{n_s}-1)}|0\\rangle + "
"\\sqrt{L/(2^{n_s}-1)}|1\\rangle \\right),"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:452
msgid "which allows to run amplitude estimation to evaluate the expected loss."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:504
msgid "Create the state preparation circuit:"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:628
msgid ""
"Before we use QAE to estimate the expected loss, we validate the quantum "
"circuit representing the objective function by just simulating it "
"directly and analyzing the probability of the objective qubit being in "
"the :math:`|1\\rangle` state, i.e., the value QAE will eventually "
"approximate."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:692
msgid ""
"Next we run QAE to estimate the expected loss with a quadratic speed-up "
"over classical Monte Carlo simulation."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:753
msgid "Cumulative Distribution Function"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:755
msgid ""
"Instead of the expected loss (which could also be estimated efficiently "
"using classical techniques) we now estimate the cumulative distribution "
"function (CDF) of the loss. Classically, this either involves evaluating "
"all the possible combinations of defaulting assets, or many classical "
"samples in a Monte Carlo simulation. Algorithms based on QAE have the "
"potential to significantly speed up this analysis in the future."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:757
msgid ""
"To estimate the CDF, i.e., the probability :math:`\\mathbb{P}[L \\leq "
"x]`, we again apply :math:`\\mathcal{S}` to compute the total loss, and "
"then apply a comparator that for a given value :math:`x` acts as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:759
msgid ""
" \\mathcal{C}: |L\\rangle_n|0> \\mapsto\n"
"\\begin{cases}\n"
"|L\\rangle_n|1> & \\text{if}\\quad L \\leq x \\\\\n"
"|L\\rangle_n|0> & \\text{if}\\quad L > x.\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:767
msgid "The resulting quantum state can be written as"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:769
msgid ""
" \\sum_{L = 0}^{x} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle +\n"
"\\sum_{L = x+1}^{2^{n_s}-1} \\sqrt{p_{L}}|L\\rangle_{n_s}|1\\rangle,"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:774
msgid ""
"where we directly assume the summed up loss values and corresponding "
"probabilities instead of presenting the details of the uncertainty model."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:776
msgid ""
"The CDF(\\ :math:`x`) equals the probability of measuring "
":math:`|1\\rangle` in the objective qubit and QAE can be directly used to"
" estimate it."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:894
#: ../../tutorials/09_credit_risk_analysis.ipynb:1460
msgid "Again, we first use quantum simulation to validate the quantum circuit."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1045
msgid "Next we run QAE to estimate the CDF for a given :math:`x`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1105
msgid "Value at Risk"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1107
msgid ""
"In the following we use a bisection search and QAE to efficiently "
"evaluate the CDF to estimate the value at risk."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1296
msgid "Conditional Value at Risk"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1298
msgid ""
"Last, we compute the CVaR, i.e. the expected value of the loss "
"conditional to it being larger than or equal to the VaR. To do so, we "
"evaluate a piecewise linear objective function :math:`f(L)`, dependent on"
" the total loss :math:`L`, that is given by"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1300
msgid ""
"f(L) = \\begin{cases}\n"
"0 & \\text{if}\\quad L \\leq VaR \\\\\n"
"L & \\text{if}\\quad L > VaR.\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1308
msgid ""
"To normalize, we have to divide the resulting expected value by the VaR-"
"probability, i.e. \\ :math:`\\mathbb{P}[L \\leq VaR]`."
msgstr ""

#: ../../tutorials/09_credit_risk_analysis.ipynb:1526
msgid "Next we run QAE to estimate the CVaR."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:9
msgid "Option Pricing with qGANs"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:14
msgid ""
"In this notebook, we discuss how a Quantum Machine Learning Algorithm, "
"namely a quantum Generative Adversarial Network (qGAN), can facilitate "
"the pricing of a European call option. More specifically, a qGAN can be "
"trained such that a quantum circuit models the spot price of an asset "
"underlying a European call option. The resulting model can then be "
"integrated into a Quantum Amplitude Estimation based algorithm to "
"evaluate the expected payoff - see `European Call Option Pricing "
"<03_european_call_option_pricing.ipynb>`__. For further details on "
"learning and loading random distributions by training a qGAN please refer"
" to `Quantum Generative Adversarial Networks for Learning and Loading "
"Random Distributions. Zoufal, Lucchi, Woerner. 2019. "
"<https://www.nature.com/articles/s41534-019-0223-2>`__"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:50
msgid ""
"The Black-Scholes model assumes that the spot price at maturity "
":math:`S_T` for a European call option is log-normally distributed. Thus,"
" we can train a qGAN on samples from a log-normal distribution and use "
"the result as an uncertainty model underlying the option. In the "
"following, we construct a quantum circuit that loads the uncertainty "
"model. The circuit output reads"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:52
msgid ""
"\\big| g_{\\theta}\\rangle = \\sum_{j=0}^{2^n-1}\\sqrt{p_{\\theta}^{j}} "
"\\big| j \\rangle ,\n"
"\n"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:54
msgid ""
"where the probabilities :math:`p_{\\theta}^{j}`, for :math:`j\\in "
"\\left\\{0, \\ldots, {2^n-1} \\right\\}`, represent a model of the target"
" distribution."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:97
msgid ""
"Now, the trained uncertainty model can be used to evaluate the "
"expectation value of the option’s payoff function with Quantum Amplitude "
"Estimation."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:123
msgid "Plot the probability distribution"
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:125
msgid ""
"Next, we plot the trained probability distribution and, for reasons of "
"comparison, also the target probability distribution."
msgstr ""

#: ../../tutorials/10_qgan_option_pricing.ipynb:193
msgid ""
"Now, the trained uncertainty model can be used to evaluate the "
"expectation value of the option’s payoff function analytically and with "
"Quantum Amplitude Estimation."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:9
msgid "Loading and Processing Stock-Market Time-Series Data"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:23
msgid ""
"Across many problems in finance, one starts with time series. Here, we "
"showcase how to generate pseudo-random time-series, download actual "
"stock-market time series from a number of common providers, and how to "
"compute time-series similarity measures."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:64
msgid ""
"Once the data are loaded, you can run a variety of algorithms on those to"
" aggregate the data. Notably, you can compute the covariance matrix or a "
"variant, which would consider alternative time-series similarity measures"
" based on `dynamic time warping "
"<https://en.wikipedia.org/wiki/Dynamic_time_warping>`__ (DTW). In DTW, "
"changes that vary in speed, e.g., one stock’s price following another "
"stock’s price with a small delay, can be accommodated."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:168
msgid ""
"If you wish, you can look into the underlying pseudo-random time-series "
"using. Please note that the private class members (starting with "
"underscore) may change in future releases of Qiskit."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:252
msgid ""
"Clearly, you can adapt the number and names of tickers and the range of "
"dates:"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:291
msgid "Access to closing-price time-series"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:293
msgid ""
"While the access to real-time data usually requires a payment, it is "
"possible to access historical (adjusted) closing prices via Wikipedia and"
" Quandl free of charge, following registration at: "
"https://www.quandl.com/?modal=register In the code below, one needs to "
"specify actual tickers of actual NASDAQ issues and the access token you "
"obtain from Quandl; by running the code below, you agree to the Quandl "
"terms and conditions, including a liability waiver. Notice that at least "
"two tickers are required for the computation of covariance and time-"
"series matrices, but hundreds of tickers may go beyond the fair usage "
"limits of Quandl."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:328
msgid ""
"Once the data are loaded, you can again compute the covariance matrix or "
"its DTW variants."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:366
msgid "If you wish, you can look into the underlying time-series using:"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:401
msgid "[Optional] Setup token to access recent, fine-grained time-series"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:403
msgid ""
"If you would like to download professional data, you will have to set-up "
"a token with one of the major providers. Let us now illustrate the data "
"with NASDAQ Data on Demand, which can supply bid and ask prices in "
"arbitrary resolution, as well as aggregates such as daily adjusted "
"closing prices, for NASDAQ and NYSE issues."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:414
msgid ""
"If you don’t have NASDAQ Data on Demand license, you can contact NASDAQ "
"(cf. https://business.nasdaq.com/intel/GIS/Nasdaq-Data-on-Demand.html) to"
" obtain a trial or paid license."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:416
msgid ""
"If and when you have access to NASDAQ Data on Demand using your own "
"token, you should replace REPLACE-ME below with the token. To assure the "
"security of the connection, you should also have your own means of "
"validating NASDAQ’s certificates. The DataOnDemandProvider constructor "
"has an optional argument ``verify``, which can be ``None`` or a string or"
" a boolean. If it is ``None``, certify certificates will be used "
"(default). If verify is a string, it should be pointing to a certificate "
"for the HTTPS connection to NASDAQ (dataondemand.nasdaq.com), either in "
"the form of a CA_BUNDLE file or a directory wherein to look."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:453
msgid ""
"Another major vendor of stock market data is Exchange Data International "
"(EDI), whose API can be used to query over 100 emerging and frontier "
"markets that are Africa, Asia, Far East, Latin America and Middle East, "
"as well as the more established ones. See: https://www.exchange-data.com"
"/pricing-data/adjusted-prices.php#exchange-coverage for an overview of "
"the coverage."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:455
msgid ""
"The access again requires a valid access token to replace REPLACE-ME "
"below. The token can be obtained on a trial or paid-for basis at: "
"https://www.quandl.com/"
msgstr ""

#: ../../tutorials/11_time_series.ipynb:493
msgid ""
"One can also access Yahoo Finance Data, no token needed, from Yahoo! "
"Finance."
msgstr ""

#: ../../tutorials/11_time_series.ipynb:535
msgid ""
"For the actual use of the data, please see the portfolio_optimization or "
"portfolio_diversification notebooks."
msgstr ""

#: ../../tutorials/index.rst:3
msgid "Finance Tutorials"
msgstr ""


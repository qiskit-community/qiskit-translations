msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-16 11:25+0000\n"
"PO-Revision-Date: 2023-03-20 15:15\n"
"Last-Translator: \n"
"Language: es_UN\n"
"Language-Team: Spanish (United)\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: es-un\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "Esta página fue generada a partir de `tutorials/operators/01_operator_flow.ipynb`__."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "Flujo del Operador"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "Introducción"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit proporciona clases que representan estados, operadores, sumas, productos tensoriales y composiciones de los mismos. Estas construcciones algebraicas nos permiten construir expresiones que representan operadores."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Introducimos expresiones creándolas a partir de operadores de Pauli. En secciones posteriores exploraremos operadores y estados con mayor detalle, cómo están representados, y qué podemos hacer con ellos. En la última sección construiremos un estado, lo desarrollaremos con un Hamiltoniano, y calcularemos los valores esperados de un observable."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Operadores de Pauli, sumas, composiciones y productos tensoriales"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "Los operadores base más importantes son los operadores de Pauli, los cuales son representados de esta manera."

#: ../../tutorials/operators/01_operator_flow.ipynb:76
msgid "These operators may also carry a coefficient."
msgstr "Estos operadores también pueden llevar un coeficiente."

#: ../../tutorials/operators/01_operator_flow.ipynb:125
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "Estos coeficientes permiten que los operadores se utilicen como términos en una suma."

#: ../../tutorials/operators/01_operator_flow.ipynb:173
msgid "Tensor products are denoted with a caret, like this."
msgstr "Los productos tensoriales se denotan con un caret (acento circunflejo), como este."

#: ../../tutorials/operators/01_operator_flow.ipynb:218
msgid "Composition is denoted by the ``@`` symbol."
msgstr "La composición es denotada por el símbolo ``@``."

#: ../../tutorials/operators/01_operator_flow.ipynb:263
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "En los dos ejemplos anteriores, el producto tensorial y la composición de los operadores de Pauli se redujeron inmediatamente al operador de Pauli equivalente (posiblemente de múltiples qubits). Si aplicamos el producto tensorial o componemos objetos más complicados, el resultado son objetos que representan las operaciones no evaluadas. Es decir, expresiones algebraicas."

#: ../../tutorials/operators/01_operator_flow.ipynb:274
msgid "For example, composing two sums gives"
msgstr "Por ejemplo, la composición de dos sumas"

#: ../../tutorials/operators/01_operator_flow.ipynb:328
msgid "And tensoring two sums gives"
msgstr "Y el producto tensorial de dos sumas da"

#: ../../tutorials/operators/01_operator_flow.ipynb:382
msgid "Let's take a closer look at the types introduced above. First the Pauli operators."
msgstr "Echemos un vistazo a los tipos introducidos anteriormente. Primero a los operadores de Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:428
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "Cada operador Pauli es una instancia de ``PauliOp``, que envuelve a una instancia de ``qiskit.quantum_info.Pauli``, y añade un coeficiente ``coeff``. En general, un ``PauliOp`` representa un producto tensorial ponderado de operadores Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:474
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Para la codificación de los operadores de Pauli como pares de valores booleanos, ve la documentación de ``qiskit.quantum_info.Pauli``."

#: ../../tutorials/operators/01_operator_flow.ipynb:476
msgid "All of the objects representing operators, whether as \"primitive\"s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr "Todos los objetos que representan operadores, ya sea una \"primitiva\" como ``PauliOp``, o expresiones algebraicas llevan un coeficiente"

#: ../../tutorials/operators/01_operator_flow.ipynb:530
msgid "In the following we take a broader and deeper look at Qiskit's operators, states, and the building blocks of quantum algorithms."
msgstr "A continuación, echamos un vistazo más amplio y profundo a los operadores, estados y los componentes básicos de los algoritmos cuánticos de Qiskit."

#: ../../tutorials/operators/01_operator_flow.ipynb:542
msgid "Part I: State Functions and Measurements"
msgstr "Parte I: Funciones de Estado y Mediciones"

#: ../../tutorials/operators/01_operator_flow.ipynb:544
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "Los estados cuánticos están representados por subclases de la clase ``StateFn``. Hay cuatro representaciones de estados cuánticos: ``DictStateFn`` es una representación escasa en la base computacional, respaldada por un ``dict``. ``VectorStateFn`` es una representación densa en la base computacional respaldada por un arreglo numpy. ``CircuitStateFn`` está respaldado por un circuito y representa el estado obtenido al ejecutar el circuito en el estado con todos sus qubits en cero en la base computacional. ``OperatorStateFn`` representa estados mixtos a través de una matriz de densidad. (Como veremos más adelante, ``OperatorStateFn`` también se usa para representar observables)"

#: ../../tutorials/operators/01_operator_flow.ipynb:547
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "Se proporcionan varias instancias de ``StateFn`` para mayor comodidad. Por ejemplo ``Zero, One, Plus, Minus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:569
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "``Zero`` y ``One`` representan los estados cuánticos :math:`|0\\rangle` y :math:`|1\\rangle`. Están representados a través de ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:614
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr "``Plus`` y ``Minus``, representan los estados :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` y :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}`, son representados a través de circuitos. ``H`` es un sinónimo para ``Plus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:683
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "La indexación en estados cuánticos se realiza con el método ``eval``. Estos ejemplos devuelven los coeficientes de los estados base ``0`` y ``1``. (Abajo, podemos ver que el método ``eval`` también se utiliza para realizar otros cálculos.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:744
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "El vector dual de un estado cuántico, que es el *bra* correspondiente de un *ket* se obtiene mediante el método ``adjoint``. El ``StateFn`` lleva una bandera ``is_measurement``, que es ``False`` si el objeto es un ket y ``True`` si es un bra."

#: ../../tutorials/operators/01_operator_flow.ipynb:755
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "Aquí, construimos :math:`\\langle 1 |`."

#: ../../tutorials/operators/01_operator_flow.ipynb:801
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "Por comodidad, se puede obtener el vector dual con una tilde, de la siguiente manera"

#: ../../tutorials/operators/01_operator_flow.ipynb:848
msgid "Algebraic operations and predicates"
msgstr "Operaciones algebraicas y predicados"

#: ../../tutorials/operators/01_operator_flow.ipynb:850
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including:"
msgstr "Se admiten muchas operaciones algebraicas y predicados entre ``StateFn``\\ s, que incluyen:"

#: ../../tutorials/operators/01_operator_flow.ipynb:852
msgid "``+`` - addition"
msgstr "``+`` - adición"

#: ../../tutorials/operators/01_operator_flow.ipynb:853
msgid "``-`` - subtraction, negation (scalar multiplication by -1)"
msgstr "``-`` - resta, negación (multiplicación escalar por -1)"

#: ../../tutorials/operators/01_operator_flow.ipynb:854
msgid "``*`` - scalar multiplication"
msgstr "``*`` - multiplicación escalar"

#: ../../tutorials/operators/01_operator_flow.ipynb:855
msgid "``/`` - scalar division"
msgstr "``/`` - división escalar"

#: ../../tutorials/operators/01_operator_flow.ipynb:856
msgid "``@`` - composition"
msgstr "``@`` - composición"

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "``^`` - tensor product or tensor power (tensor with self n times)"
msgstr "``^`` - producto tensorial o potencia tensorial (producto tensorial consigo mismo n veces)"

#: ../../tutorials/operators/01_operator_flow.ipynb:858
msgid "``**`` - composition power (compose with self n times)"
msgstr "``**`` - potencia de composición (componer consigo mismo n veces)"

#: ../../tutorials/operators/01_operator_flow.ipynb:859
msgid "``==`` - equality"
msgstr "``==`` - igualdad"

#: ../../tutorials/operators/01_operator_flow.ipynb:860
msgid "``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "``~`` - adjunto, alternando entre una Función de Estado y Medición"

#: ../../tutorials/operators/01_operator_flow.ipynb:862
msgid "Be very aware that these operators obey the `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, which might not be what you expect mathematically. For example, ``I^X + X^I`` will actually be parsed as ``I ^ (X + X) ^ I == 2 * (I^X^I)`` because Python evaluates ``+`` before ``^``. In these cases, you can use the methods (``.tensor()``, etc) or parentheses."
msgstr "Ten en cuenta que estos operadores obedecen las `reglas de Python de precedencia de operadores <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, que puede que no sea lo que esperas matemáticamente. Por ejemplo, ``I^X + X^I`` en realidad se analizará como ``I ^ (X + X) ^ I == 2 * (I^X^I)`` porque Python evalúa ``+`` antes de ``^``. En estos casos, puedes utilizar los métodos (``.tensor()``, etc) o paréntesis."

#: ../../tutorials/operators/01_operator_flow.ipynb:873
msgid "``StateFn``\\ s carry a coefficient. This allows us to multiply states by a scalar, and so to construct sums."
msgstr "``StateFn`` lleva un coeficiente. Esto nos permite multiplicar estados por un escalar, y de esta forma la posibilidad de construir sumas."

#: ../../tutorials/operators/01_operator_flow.ipynb:884
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "Aquí construimos :math:`(2 + 3i)|0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:930
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "Aquí vemos que al añadir dos ``DictStateFn`` se devuelve un objeto del mismo tipo. Construimos :math:`|0\\rangle + |1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:975
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "Ten en cuenta que debes normalizar los estados a mano. Por ejemplo, para construir :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` escribimos"

#: ../../tutorials/operators/01_operator_flow.ipynb:1023
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "En otros casos, el resultado es una representación simbólica de una suma. Por ejemplo, aquí hay una representación de :math:`|+\\rangle + |-\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1101
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "El operador de composición se utiliza para realizar un producto interno, que de forma predeterminada se mantiene en una forma sin evaluar. Aquí hay una representación de :math:`\\langle 1 | 1 \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1155
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "Ten en cuenta que la bandera ``is_measurement`` causa que el estado (bra) ``~One`` sea impreso ``DictMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1166
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "Las expresiones simbólicas pueden ser evaluadas con el método ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1247
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "Aquí se muestra :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1293
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "El operador de composición ``@`` es equivalente a llamar al método ``compose``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1347
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "Los productos internos también pueden ser evaluados usando el método ``eval`` directamente, sin necesidad de construir un ``ComposedOp``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1393
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "Los productos tensoriales simbólicos se construyen de la siguiente manera. Aquí se muestra :math:`|0\\rangle \\otimes |+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1459
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "Esto puede ser representado como un ``CircuitStateFn`` simple (no compuesto)."

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "Las potencias tensoriales se construyen utilizando el caret (acento circunflejo) ``^`` de la siguiente manera. Aquí se muestran :math:`600 (|11111\\rangle + |00000\\rangle)`, y :math:`|10\\rangle^{\\otimes 3}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1571
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "El método ``to_matrix_op`` convierte a ``VectorStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1672
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "Construir un StateFn es sencillo. La clase ``StateFn`` también sirve como una fábrica, y puede tomar cualquier primitiva aplicable en su constructor y devolver la subclase StateFn correcta. Actualmente, se pueden pasar las siguientes primitivas al constructor, listadas junto a la subclase ``StateFn`` producen:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1674
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (igual a alguna base de cadena de bits) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1675
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1676
msgid "Qiskit Result object -> DictStateFn"
msgstr "Objeto de resultado de Qiskit -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1677
msgid "list -> VectorStateFn"
msgstr "list-> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1678
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1679
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1680
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit-> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1681
msgid "Instruction -> CircuitStateFn"
msgstr "Instruction -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1682
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase -> OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1764
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "Parte II: ``PrimitiveOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:1766
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "Los operadores básicos son subclases de ``PrimitiveOp``. Al igual que ``StateFn``, ``PrimitiveOp`` también es una fábrica para crear el tipo correcto de ``PrimitiveOp`` para una primitiva dada. Actualmente, las siguientes primitivas pueden pasarse al constructor, listadas junto a la subclase ``PrimitiveOp`` producen:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1768
msgid "Terra's Pauli -> PauliOp"
msgstr "Pauli de Terra -> PauliOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1769
msgid "Instruction -> CircuitOp"
msgstr "Instruction -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1770
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1771
msgid "2d List -> MatrixOp"
msgstr "Lista 2d -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1772
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1773
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1774
msgid "Terra's quantum_info.Operator -> MatrixOp"
msgstr "quantum_info.Operator de Terra -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1796
msgid "Matrix elements"
msgstr "Elementos de matriz"

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "El método ``eval`` devuelve una columna de un operador. Por ejemplo, el operador Pauli :math:`X` está representado por un ``PauliOp``. Al solicitar una columna, se devuelve una instancia de la representación recortada, un ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1887
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "De ello se deduce que la indexación en un operador, es decir, la obtención de un elemento de matriz, se realiza con dos llamadas al método ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1898
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "Tenemos :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. Y el elemento de matriz :math:`\\left\\{X \\right\\}_{0,1}` es"

#: ../../tutorials/operators/01_operator_flow.ipynb:1944
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "Aquí se muestra un ejemplo usando el operador de dos qubits ``CX``, que es el operador ``X`` controlado, y su representación en un circuito."

#: ../../tutorials/operators/01_operator_flow.ipynb:2088
msgid "Applying an operator to a state vector"
msgstr "Aplicar un operador a un vector de estado"

#: ../../tutorials/operators/01_operator_flow.ipynb:2099
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "La aplicación de un operador a un vector de estado puede hacerse con el método ``compose`` (o equivalentemente, el operador ``@``). Aquí está una representación de :math:`X | 1 \\rangle = |0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2153
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "Una representación más simple, la representación ``DictStateFn`` de :math:`|0\\rangle`, se obtiene con ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2199
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "El paso intermedio ``ComposedOp`` puede evitarse si se utiliza ``eval`` directamente."

#: ../../tutorials/operators/01_operator_flow.ipynb:2245
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "Los productos tensoriales y de composición de los operadores se aplican con ``@`` y ``^``. Aquí se muestran algunos ejemplos."

#: ../../tutorials/operators/01_operator_flow.ipynb:2449
msgid "Part III: ``ListOp`` and subclasses"
msgstr "Parte III: ``ListOp`` y subclases"

#: ../../tutorials/operators/01_operator_flow.ipynb:2461
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2463
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp`` es un contenedor para vectorizar operaciones de manera efectiva sobre una lista de operadores y estados."

#: ../../tutorials/operators/01_operator_flow.ipynb:2537
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "Por ejemplo, la composición anterior se distribuye sobre las listas (``ListOp``) utilizando el método de simplificación ``reduce``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2646
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2648
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you've already played around with the above, you'll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven't implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you'll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr "``ListOp``, presentado anteriormente, es útil para operaciones de vectorización. Pero también sirve como la superclase para clases compuestas tipo lista. Si ya has jugado con lo anterior, notarás que puedes ejecutar operaciones fácilmente entre ``OperatorBase``\\ s, que puede que no sepamos como ejecutarlo de manera óptima en general (o simplemente no se haya implementado un procedimiento eficiente por el momento), tales como la adición entre ``CircuitOp``\\ s. En esos casos, puedes recibir un resultado ``ListOp`` (o una subclase) de tu operación que representa la ejecución diferida de la operación. Por ejemplo, si intentas agregar un ``DictStateFn`` y un ``CircuitStateFn``, recibirás un ``SummedOp`` que representa la suma de los dos. Esta función de estado compuesto todavía tiene un ``eval`` que funciona (pero es posible que deba realizar un cálculo no escalable tras bambalinas, como convertir ambos en vectores)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2651
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "Estos ``OperatorBase``\\ s compuestos son la forma en que construimos computación cada vez más compleja y rica a partir de los bloques de construcción ``PrimitiveOp`` y ``StateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2653
msgid "Every ``ListOp`` has four properties:"
msgstr "Cada ``ListOp`` tiene cuatro propiedades:"

#: ../../tutorials/operators/01_operator_flow.ipynb:2655
msgid "``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc."
msgstr "``oplist`` - La lista de ``OperatorBase``\\ s que pueden representar términos, factores, etc."

#: ../../tutorials/operators/01_operator_flow.ipynb:2656
msgid "``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays."
msgstr "``combo_fn`` - La función toma una lista de números complejos a un valor de salida que define cómo combinar las salidas de los elementos ``oplist``. Para simplificar la transmisión, esta función se define sobre arreglos NumPy."

#: ../../tutorials/operators/01_operator_flow.ipynb:2657
msgid "``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``."
msgstr "``coeff`` - Un coeficiente que multiplica la primitiva. Ten en cuenta que ``coeff`` puede ser int, float, complex o un objeto ``Parameter`` libre (de ``qiskit.circuit`` en Terra) para ser vinculado más tarde usando ``my_op.bind_parameters``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2658
msgid "``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "``abelian`` - Indica si se sabe que los operadores en ``oplist`` conmutan mutuamente (generalmente se establece después de ser transformado por el convertidor ``AbelianGrouper``)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2660
msgid "Note that ``ListOp`` supports typical sequence overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "Ten en cuenta que ``ListOp`` soporta sobrecargas de secuencia típicas, así que puedes usar indexación como ``my_op[4]`` para acceder a la ``OperatorBase`` en ``oplist``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2672
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2674
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "Se ha mencionado anteriormente que ``OperatorStateFn`` representa un operador de densidad. Pero, si la bandera ``is_measurement`` es ``True``, entonces ``OperatorStateFn`` representa un observable. El valor esperado de este observable puede construirse a través de ``ComposedOp``. O, directamente, utilizando ``eval``. Recuerda que la bandera (propiedad) ``is_measurement`` se establece mediante el método ``adjoint``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2685
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "Aquí construimos el observable correspondiente al operador de Pauli :math:`Z`. Ten en cuenta que al imprimirlo, se le llama ``OperatorMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2757
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "Aquí calculamos :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, y :math:`\\langle + | Z | + \\rangle`, donde :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2811
msgid "Part IV: Converters"
msgstr "Parte IV: Conversores"

#: ../../tutorials/operators/01_operator_flow.ipynb:2813
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter's ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr "Los conversores son clases que manipulan operadores y estados y ejecutan bloques de construcción de algoritmos. Algunos ejemplos incluyen cambiar la base de operadores y Trotterización. Los conversores recorren una expresión y realizan una manipulación o sustitución particular, definida por el método ``convert()`` del conversor, de los operadores internos. Normalmente, si un conversor encuentra un ``OperatorBase`` en la recursión que es irrelevante para su propósito de conversión, ese ``OperatorBase`` se deja sin cambios."

#: ../../tutorials/operators/01_operator_flow.ipynb:2838
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "Evoluciones, ``exp_i()``, y ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2840
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can't perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr "Cada ``PrimitiveOp`` y ``ListOp`` tiene una función ``.exp_i()`` tal que ``H.exp_i()`` corresponde a :math:`e^{-iH}`. En la práctica, sólo unos pocos de estos operadores tienen una exponenciación computable eficiente (como por ejemplo MatrixOp y los PauliOps con solo un qubit que no sea identidad de Pauli), así que necesitamos devolver un marcador de posición o una representación simbólica, (similar a cómo ``SummedOp`` es un marcador de posición cuando no podemos realizar una suma). Este marcador de posición se llama ``EvolvedOp``, y contiene la ``OperatorBase`` para ser exponenciada en su propiedad ``.primitive``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2843
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there's no \"evolution time\" argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr "Los operadores de Qiskit soportan completamente la parametrización, así que podemos usar un ``Parameter`` para nuestro tiempo de evolución aquí. Ten en cuenta que no hay ningún argumento de \"tiempo de evolución\" en ninguna función. El flujo del Operator exponencia cualquier operador que se le indique, y si optamos por multiplicar el operador por un tiempo de evolución, :math:`e^{-iHt}`, se reflejará en nuestros parámetros de exponenciación."

#: ../../tutorials/operators/01_operator_flow.ipynb:2855
msgid "Weighted sum of Pauli operators"
msgstr "Suma ponderada de los operadores de Pauli"

#: ../../tutorials/operators/01_operator_flow.ipynb:2857
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "Un Hamiltoniano expresado como una combinación lineal de operadores de Pauli multi-qubit puede ser construido de este modo."

#: ../../tutorials/operators/01_operator_flow.ipynb:2882
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "Nota que ``two_qubit_H2`` está representado como un ``SummedOp`` cuyos términos son ``PauliOp``\\ s."

#: ../../tutorials/operators/01_operator_flow.ipynb:2939
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "A continuación, multiplicamos al Hamiltoniano por un ``Parameter``. Este ``Parameter`` se almacena en la propiedad ``coeff`` de ``SummedOp``. Llamando a ``exp_i()``, en el resultado; lo envuelve en ``EvolvedOp``, representando la exponenciación."

#: ../../tutorials/operators/01_operator_flow.ipynb:3014
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "Construimos ``h2_measurement``, que representa ``two_qubit_H2`` como un observable."

#: ../../tutorials/operators/01_operator_flow.ipynb:3072
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr "Construimos un estado de Bell :math:`|\\Phi_+\\rangle` vía :math:`\\text{CX} (H\\otimes I) |00\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3136
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "Esta es la expresión :math:`H e^{-iHt} |\\Phi_+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3242
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "Normalmente, queremos aproximar :math:`e^{-iHt}` usando compuertas de dos qubits. Esto se logra con el método ``convert`` de ``PauliTrotterEvolution``, que recorre expresiones aplicando la trotterización a todos los ``EvolvedOp``\\ s encontrados. Aunque utilizamos ``PauliTrotterEvolution`` aquí, hay otras posibilidades, como ``MatrixEvolution``, que realiza la exponenciación exactamente."

#: ../../tutorials/operators/01_operator_flow.ipynb:3361
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` contiene un ``Parameter``. El método ``bind_parameters`` recorre los valores de enlace de la expresión a los nombres de los parámetros mediante un ``dict``. En este caso, sólo hay un parámetro."

#: ../../tutorials/operators/01_operator_flow.ipynb:3382
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let's draw it to verify that the binding has taken place."
msgstr "``bound`` es un ``ComposedOp``. El segundo factor es el circuito. Dibujémoslo para verificar que se genera el enlace."

#: ../../tutorials/operators/01_operator_flow.ipynb:3502
msgid "Expectations"
msgstr "Valor Esperado"

#: ../../tutorials/operators/01_operator_flow.ipynb:3504
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "``Expectation``\\ s son conversores que permiten el cálculo de los valores esperados de observables. Recorren un árbol de operadores, reemplazando ``OperatorStateFn``\\ s (observables) con instrucciones equivalentes que son más susceptibles a la computación en hardware cuántico o clásico. Por ejemplo, si queremos medir el valor esperado de un Operador ``o`` expresado como una suma de Paulis con respecto a alguna función de estado, pero solo puede acceder a mediciones diagonales en hardware cuántico, podemos crear un observable ``~StateFn(o)`` y usar una ``PauliExpectation`` para convertirlo en una medición diagonal y pre-rotaciones de circuito para añadirlo al estado."

#: ../../tutorials/operators/01_operator_flow.ipynb:3507
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "Otra ``Expectation`` interesante es la ``AerPauliExpectation``, que convierte el observable en un ``CircuitStateFn`` que contiene una instrucción especial de una instantánea de un valor esperado que ``Aer`` puede ejecutar nativamente con alto rendimiento."

#: ../../tutorials/operators/01_operator_flow.ipynb:3628
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "De forma predeterminada ``group_paulis=True``, que utilizará el ``AbelianGrouper`` para convertir el ``SummedOp`` en grupos de Paulis que conmutan mutuamente a nivel de qubits. Esto reduce la sobrecarga de ejecución del circuito, ya que cada grupo puede compartir la misma ejecución del circuito."

#: ../../tutorials/operators/01_operator_flow.ipynb:3721
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "Ten en cuenta que los conversores actúan recursivamente, es decir, atraviesan una expresión aplicando su acción sólo cuando sea posible. Así que sólo podemos convertir nuestra evolución y expresión de medición. Podríamos equivalentemente haber compuesto el ``h2_measurement`` convertido con nuestra evolución ``CircuitStateFn``. Procedemos aplicando la conversión en toda la expresión."

#: ../../tutorials/operators/01_operator_flow.ipynb:3905
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "Ahora vinculamos múltiples valores de parámetro en un ``ListOp``, seguido por ``eval`` para evaluar toda la expresión. Podríamos haber usado ``eval`` antes si hubiéramos vinculado previamente, pero no sería eficiente. Aquí, ``eval`` convertirá nuestro ``CircuitStateFn``\\ s a ``VectorStateFn``\\ s a través de la simulación internamente."

#: ../../tutorials/operators/01_operator_flow.ipynb:3927
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "Estos son los valores esperados :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` correspondientes a los diferentes valores del parámetro."

#: ../../tutorials/operators/01_operator_flow.ipynb:3980
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "Ejecutar ``CircuitStateFn``\\ s con el ``CircuitSampler``"

#: ../../tutorials/operators/01_operator_flow.ipynb:3982
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFn``\\ s into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule)."
msgstr "El ``CircuitSampler`` recorre un Operador y convierte cualquier ``CircuitStateFn``\\ s en aproximaciones de la función de estado resultante por un ``DictStateFn`` o ``VectorStateFn`` usando un backend cuántico. Ten en cuenta que para aproximar el valor del ``CircuitStateFn``, se debe 1) enviar la función de estado a través de un canal despolarizante, que destruirá toda la información de la fase y 2) reemplazar las frecuencias muestreadas con **raíces cuadradas** de la frecuencia, en lugar de la probabilidad cruda de muestreo (que sería el equivalente a muestrear el **cuadrado** de la función de estado, por la regla de Born)."

#: ../../tutorials/operators/01_operator_flow.ipynb:4038
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "Ten en cuenta, de nuevo; que los circuitos son reemplazados por dicts con **raíces cuadradas** de las probabilidades de muestreo del circuito. Echa un vistazo a una subexpresión antes y después de la conversión:"


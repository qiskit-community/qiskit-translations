msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-13 18:47+0000\n"
"PO-Revision-Date: 2021-07-13 19:44\n"
"Last-Translator: \n"
"Language-Team: Spanish (United)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: es-un\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/circuits/3_summary_of_quantum_operations.po\n"
"X-Crowdin-File-ID: 9118\n"
"Language: es_UN\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:10
msgid "This page was generated from `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."
msgstr "Esta página fue generada a partir de `tutorials/circuits_advanced/1_advanced_circuits.ipynb`__."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr "Resumen de Operaciones Cuánticas"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:20
msgid "In this section we will go into the different operations that are available in Qiskit Terra. These are:"
msgstr "En esta sección presentaremos las diferentes operaciones que están disponibles en Qiskit Terra. Estas son:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:22
msgid "Single-qubit quantum gates"
msgstr "Compuertas cuánticas de un solo qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:23
msgid "Multi-qubit quantum gates"
msgstr "Compuertas cuánticas para varios qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:24
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3282
msgid "Measurements"
msgstr "Mediciones"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:25
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3496
msgid "Reset"
msgstr "Reiniciar"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:26
msgid "Conditionals"
msgstr "Condicionales"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:27
msgid "State initialization"
msgstr "Inicialización del estado"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:29
msgid "We will also show you how to use the three different simulators:"
msgstr "También te mostraremos como usar los tres diferentes simuladores:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:31
msgid "unitary_simulator"
msgstr "unitary_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:32
msgid "qasm_simulator"
msgstr "qasm_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:33
msgid "statevector_simulator"
msgstr "statevector_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:73
msgid "Single Qubit Quantum states"
msgstr "Estados cuánticos de un qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:75
msgid "A single qubit quantum state can be written as"
msgstr "Un estado cuántico de un qubit se puede escribir como"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:77
msgid "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:79
msgid "where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a measurement the probability of the bit being in :math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and :math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this is"
msgstr "donde :math:`\\alpha` y :math:`\\beta` son números complejos. En una medición, la probabilidad de que el bit esté en :math:`\\left|0\\right\\rangle` es :math:`|\\alpha|^2` y :math:`\\left|1\\right\\rangle` es :math:`|\\beta|^2`. Como vector esto es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:81
msgid "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:90
msgid "Note, due to the conservation of probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` and since global phase is undetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` we only require two real numbers to describe a single qubit quantum state."
msgstr "Note que debido a la conservación de la probabilidad :math:`|\\alpha|^2+ |\\beta|^2 = 1` y dado que la fase global es indetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` sólo requerimos dos números reales para describir el estado cuántico de un solo qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:92
msgid "A convenient representation is"
msgstr "Una representación conveniente es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:94
msgid "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:96
msgid "where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq \\pi`. From this, it is clear that there is a one-to-one correspondence between qubit states (:math:`\\mathbb{C}^2`) and the points on the surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the Bloch sphere representation of a qubit state."
msgstr "donde :math:`0\\leq \\phi < 2\\pi`, y :math:`0\\leq \\theta \\leq \\pi`. A partir de esto, es claro que existe una correspondencia de uno a uno entre los estados de los qubits (:math:`\\mathbb{C}^2`) y los puntos sobre la superficie de una esfera unitaria (:math:`\\mathbb{R}^3`). Esta se denomina la representación de la esfera de Bloch del estado de un qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:98
msgid "Quantum gates/operations are usually represented as matrices. A gate which acts on a qubit is represented by a :math:`2\\times 2` unitary matrix :math:`U`. The action of the quantum gate is found by multiplying the matrix representing the gate with the vector which represents the quantum state."
msgstr "Las compuertas u operaciones cuánticas son usualmente representadas como matrices. Una compuerta que actúa sobre un qubit se representa como una :math:`2\\times 2` matriz unitaria :math:`U`. La acción de la compuerta cuántica se halla multiplicando la matriz que representa la compuesta con el vector que representa el estado cuántico."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:100
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:102
msgid "A general unitary must be able to take the :math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr "Un unitario general debe ser capaz de tomar el :math:` \\left | 0\\right\\rangle ` al estado anterior. Esto es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:104
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:112
msgid "where :math:`a` and :math:`b` are complex numbers constrained such that :math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and :math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where :math:`0\\leq \\lambda<2\\pi` giving"
msgstr "donde :math:`a` y :math:`b` son números complejos restringidos, tales que :math:`U^\\dagger U = I` para todo :math:`0\\leq\\theta\\leq\\pi` y :math:`0\\leq \\phi<2\\pi`. Esto da tres restricciones y como tal :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` y :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` donde :math:`0\\leq \\lambda<2\\pi` dando por resultado"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:114
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & -e^{i\\lambda}\\sin(\\theta/2) \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & e^{i\\lambda+i\\phi}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:122
msgid "This is the most general form of a single qubit unitary."
msgstr "Esta es la forma más general de una compuerta unitaria para un solo qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:134
msgid "Single-Qubit Gates"
msgstr "Compuertas de un solo qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:136
msgid "The single-qubit gates available are: - u gates - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr "Las compuertas de un solo qubit disponibles son: - Compuertas u - Compuerta Identidad - Compuertas de Pauli - Compuertas de Clifford - Compuertas :math:`C3` - Compuertas de Rotación Estándar"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:138
msgid "We have provided a backend: ``unitary_simulator`` to allow you to calculate the unitary matrices."
msgstr "Hemos provisto un backend: ``unitary_simulator`` que te permite calcular las matrices unitarias."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:160
msgid "u gates"
msgstr "Compuertas u"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:162
msgid "In Qiskit we give you access to the general unitary using the :math:`u3` gate"
msgstr "En Qiskit te damos acceso a la compuerta unitaria general usando la compuerta :math:`u3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:164
msgid "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"
msgstr "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:262
msgid "The :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` gate has the matrix form"
msgstr "La compuerta :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` tiene la forma matricial"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:264
msgid "u2(\\phi, \\lambda) =\n"
"\\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n"
"1 & -e^{i\\lambda} \\\\\n"
"e^{i\\phi} & e^{i(\\phi + \\lambda)}\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:273
msgid "This is a useful gate as it allows us to create superpositions."
msgstr "Esta es una compuerta útil ya que nos permite crear superposiciones."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:368
msgid "The :math:`u1(\\lambda)= u3(0, 0, \\lambda)` gate has the matrix form"
msgstr "La compuerta :math:`u1(\\lambda)= u3(0, 0, \\lambda)` tiene la forma matricial"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:370
msgid "u1(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:379
msgid "which is useful as it allows us to apply a quantum phase."
msgstr "la cuál es útil ya que nos permite aplicar una fase cuántica."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:475
msgid "Identity gate"
msgstr "Compuerta Identidad"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:477
msgid "The identity gate is :math:`Id = u0(1)`."
msgstr "La compuerta identidad es :math:`Id = u0(1)`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:573
msgid "Pauli gates"
msgstr "Compuertas de Pauli"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:576
msgid ":math:`X`: bit-flip gate"
msgstr ":math:`X`: compuerta de cambio de bit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:578
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr "La compuerta de cambio de bit :math:`X` está definida como:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:580
msgid "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u3(\\pi,0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:683
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ":math:`Y`: compuerta de cambio de fase"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:685
msgid "The :math:`Y` gate is defined as:"
msgstr "La compuerta :math:`Y` se define como:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:687
msgid "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u3(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:790
msgid ":math:`Z`: phase-flip gate"
msgstr ":math:`X`: compuerta cambio de fase"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:792
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr "La compuerta de cambio de fase :math:`Z` está definida como:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:794
msgid "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=u1(\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:897
msgid "Clifford gates"
msgstr "Compuertas de Clifford"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:900
msgid "Hadamard gate"
msgstr "Compuerta de Hadamard"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:902
msgid "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u2(0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1006
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr "Compuerta :math:`S` (o fase :math:`\\sqrt{Z}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1008
msgid "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= u1(\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1111
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr "Compuerta :math:`S^{\\dagger}` (o compleja conjugada de fase :math:`\\sqrt{Z}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1113
msgid "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= u1(-\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1216
msgid ":math:`C3` gates"
msgstr "Compuertas :math:`C3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1219
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr "Compuerta :math:`T` (o fase :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1221
msgid "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= u1(\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1324
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr "Compuerta :math:`T^{\\dagger}` (o compleja conjugada de fase :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1326
msgid "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= u1(-\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1429
msgid "Standard Rotations"
msgstr "Rotaciones estándar"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1431
msgid "The standard rotation gates are those that define rotations around the Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr "Las compuertas de rotaciones estándar son aquellas que definen rotaciones alrededor de las matrices de Pauli :math:`P=\\{X,Y,Z\\}`. Se definen como"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1433
msgid "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1436
msgid "Rotation around X-axis"
msgstr "Rotación alrededor del eje X"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1438
msgid "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u3(\\theta, -\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1541
msgid "Rotation around Y-axis"
msgstr "Rotación alrededor del eje Y"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1543
msgid "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u3(\\theta,0,0)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1646
msgid "Rotation around Z-axis"
msgstr "Rotación alrededor del eje Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1648
msgid "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv u1(\\phi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1657
msgid "Note that here we have used an equivalent as it is different to u1 by a global phase :math:`e^{-i \\phi/2}`."
msgstr "Nota que aquí hemos usado una equivalente ya que es diferente a u1 debido a una fase global :math:`e^{-i \\phi/2}`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1752
msgid "Note this is different due only to a global phase."
msgstr "Nota que esto es diferente debido sólo a una fase global."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1764
msgid "Multi-Qubit Gates"
msgstr "Compuertas de múltiples qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1767
msgid "Mathematical Preliminaries"
msgstr "Preliminares Matemáticos"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1769
msgid "The space of a quantum computer grows exponentially with the number of qubits. For :math:`n` qubits the complex vector space has dimension :math:`d=2^n`. To describe states of a multi-qubit system, the tensor product is used to “glue together” operators and basis vectors."
msgstr "El espacio de una computadora cuántica crece exponencialmente con el número de qubits. Para :math:`n` qubits el espacio vectorial complejo tiene dimensión :math:`d=2^n`. Para describir los estados de un sistema de varios qubits, se utiliza el producto tensorial para “unir” a los operadores y a los vectores base."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1771
msgid "Let’s start by considering a 2-qubit system. Given two operators :math:`A` and :math:`B` that each act on one qubit, the joint operator :math:`A \\otimes B` acting on two qubits is"
msgstr "Empecemos por considerar un sistema de 2 qubits. Dados dos operadores :math:`A` y :math:`B` donde cada uno actúa en un qubit, el operador conjunto :math:`A \\otimes B` que actúa en dos qubits es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1773
msgid "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1795
msgid "where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of :math:`A` and :math:`B`, respectively."
msgstr "donde :math:` A_{jk}` y :math:` B_{lm}` son los elementos de la matriz de :math:` A ` y :math:` B `, respectivamente."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1797
msgid "Analogously, the basis vectors for the 2-qubit system are formed using the tensor product of basis vectors for a single qubit:"
msgstr "Análogamente, los vectores base para el sistema de 2 qubits son formados utilizando el producto tensorial de vectores base para un solo qubit:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1799
msgid "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1823
msgid "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1846
msgid "Note we’ve introduced a shorthand for the tensor product of basis vectors, wherein :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. The state of an :math:`n`-qubit system can be described using the :math:`n`-fold tensor product of single-qubit basis vectors. Notice that the basis vectors for a 2-qubit system are 4-dimensional; in general, the basis vectors of an :math:`n`-qubit system are :math:`2^{n}`-dimensional, as noted earlier."
msgstr "Ten en cuenta que hemos introducido una abreviación para el producto tensorial de los vectores base, donde :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` se escribe como :math:`\\left|00\\right\\rangle`. El estado de un sistema de :math:`n` qubits se puede describir usando el producto tensorial :math:`n`-múltiple de vectores base de un solo qubit. Observa que los vectores base para un sistema de 2 qubits son de 4 dimensiones; en general, los vectores base de un sistema de :math:`n` qubits son de dimensión :math:`2^{n}`, como se señaló anteriormente."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1849
msgid "Basis vector ordering in Qiskit"
msgstr "Orden de los vectores base en Qiskit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1851
msgid "Within the physics community, the qubits of a multi-qubit systems are typically ordered with the first qubit on the left-most side of the tensor product and the last qubit on the right-most side. For instance, if the first qubit is in state :math:`\\left|0\\right\\rangle` and second is in state :math:`\\left|1\\right\\rangle`, their joint state would be :math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different ordering of the qubits, in which the qubits are represented from the most significant bit (MSB) on the left to the least significant bit (LSB) on the right (big-endian). This is similar to bitstring representation on classical computers, and enables easy conversion from bitstrings to integers after measurements are performed. For the example just given, the joint state would be represented as :math:`\\left|10\\right\\rangle`. Importantly, *this change in the representation of multi-qubit states affects the way multi-qubit gates are represented in Qiskit*, as discussed below."
msgstr "Dentro de la comunidad de física, los qubits de un sistema de múltiples qubits son ordenados típicamente con el primer qubit en el lado izquierdo del producto tensorial y el último qubit en el lado derecho. Por ejemplo, si el primer qubit está en el estado :math:`\\left|0\\right\\rangle` y el segundo está en estado :math:`\\left|1\\right\\rangle`, su estado conjunto sería :math:`\\left|01\\rángulo de ight\\r`. Qiskit utiliza un orden de los qubits ligeramente diferente, en el que los qubits están representados del bit más significativo (MSB) de la izquierda al bit menos significativo (LSB) de la derecha (big-endian). Esto es similar a la representación de cadenas de bits en computadoras clásicas, y permite una fácil conversión de cadenas de bits a enteros después de realizar las mediciones. Para el ejemplo que se acaba de dar, el estado en conjunto se representa como :math:`\\left|10\\right\\rangle`. Es importante recordar que, *este cambio en la representación de estados múltiples qubit afecta la forma en que las compuertas de múltiples qubit son representadas en Qiskit*, como se explica a continuación."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1854
msgid "The representation used in Qiskit enumerates the basis vectors in increasing order of the integers they represent. For instance, the basis vectors for a 2-qubit system would be ordered as :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. Thinking of the basis vectors as bit strings, they encode the integers 0,1,2 and 3, respectively."
msgstr "La representación utilizada en Qiskit enumera los vectores base en orden creciente a los enteros que representan. Por ejemplo, los vectores base para un sistema de dos qubits serán ordenados como :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, y :math:`\\left|11\\right\\rangle`. Imaginando los vectores base como cadenas de bits, estos codifican los enteros 0, 1, 2 y 3, respectivamente."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1857
msgid "Controlled operations on qubits"
msgstr "Operaciones controladas en qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1859
msgid "A common multi-qubit gate involves the application of a gate to one qubit, conditioned on the state of another qubit. For instance, we might want to flip the state of the second qubit when the first qubit is in :math:`\\left|0\\right\\rangle`. Such gates are known as *controlled gates*. The standard multi-qubit gates consist of two-qubit gates and three-qubit gates. The two-qubit gates are: - controlled Pauli gates - controlled Hadamard gate - controlled rotation gates - controlled phase gate - controlled u3 gate - swap gate"
msgstr "Una compuerta común de múltiples qubits implica la aplicación de una compuerta a un qubit condicionado al estado de otro qubit. Por ejemplo, podríamos querer cambiar el estado del segundo qubit cuando el primer qubit está en :math:`\\left|0\\right\\rangle`. Estas compuertas son conocidas como *compuertas controladas*. Las compuertas estándar de múltiples qubits consisten en compuertas de dos qubits y de tres qubits. Las compuertas de dos qubits son: - compuertas de Pauli controladas - compuerta Hadamard controlada - compuertas de rotación controladas - compuerta de fase controlada - compuerta u3 controlada - compuerta de intercambio"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1862
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr "Las puertas de tres qubits son:- Compuerta de Toffoli - Compuerta de Fredkin"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1874
msgid "Two-qubit gates"
msgstr "Compuertas de dos qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1876
msgid "Most of the two-qubit gates are of the controlled type (the SWAP gate being the exception). In general, a controlled two-qubit gate :math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the second qubit when the state of the first qubit is in :math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix representation"
msgstr "La mayoría de las compuertas de dos qubits son del tipo controlado (la compuerta SWAP es la excepción). En general una compuerta controlada de dos qubits :math:`C_{U}` actúa para aplicar una transformación unitaria :math:`U` de un qubit al segundo qubit cuando el estado del primer qubit está en :math:`\\left|1\\rángulo\\rde luz`. Supongamos que :math:`U` tiene una representación matricial"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1878
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1880
msgid "We can work out the action of :math:`C_{U}` as follows. Recall that the basis vectors for a two-qubit system are ordered as :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the **control qubit** is **qubit 0** (which, according to Qiskit’s convention, is one the *right-hand* side of the tensor product). If the control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be applied to the **target** (qubit 1, on the *left-hand* side of the tensor product). Therefore, under the action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr "Podemos determinar la acción de :math:`C_{U}` de la siguiente manera. Recuerda que los vectores base de un sistema de dos qubits son ordenados como :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Supón que el **qubit control** es **qubit 0** (que de acuerdo con las convenciones de Qiskit, es el que está del lado *derecho* del producto tensorial). Si el qubit control esta en :math:`\\left|1\\right\\rangle`, se debe aplicar :math:`U` al **objetivo**(el qubit 1, del lado *izquierdo* del producto tensorial). Por lo tanto, bajo la acción de :math:`C_{U}`, los vectores base son transformados acorde a"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1883
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1892
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr "En forma de matriz, la acción de :math:` C_{U}` es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1894
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1905
msgid "To work out these matrix elements, let"
msgstr "Para elaborar estos elementos de la matriz, digamos que"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1907
msgid "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| k \\right\\rangle}\\right),\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1909
msgid "compute the action of :math:`C_{U}` (given above), and compute the inner products."
msgstr "calcula la acción de :math:` C_{U}` (dada anteriormente), y calcular los productos internos."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1911
msgid "As shown in the examples below, this operation is implemented in Qiskit as ``cU(q[0],q[1])``."
msgstr "Como se muestra en los ejemplos siguientes, esta operación es implementada en Qiskit como ``cU (q[0], q[1])``."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1913
msgid "If **qubit 1 is the control and qubit 0 is the target**, then the basis vectors are transformed according to"
msgstr "Si **qubit 1 es el de control y qubit 0 es el objetivo**, entonces los vectores base se transforman de acuerdo con"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1915
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1924
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr "que implica la forma de la matriz de :math:` C_{U}` es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1926
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1957
msgid "Controlled Pauli Gates"
msgstr "Compuertas de Pauli Controladas"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1960
msgid "Controlled-X (or, controlled-NOT) gate"
msgstr "Compuerta X controlada (o controlada-NOT)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1962
msgid "The controlled-not gate flips the ``target`` qubit when the control qubit is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr "La compuerta control-NOT cambia el qubit ``target`` cuando el qubit control está en el estado :math:`\\left|1\\right\\rangle`. Si tomamos el MSB como el qubit control (por ejemplo, ``cx(q[1],q[0])``), entonces la matriz sería"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1964
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1975
msgid "However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), this gate is equivalent to the following matrix:"
msgstr "Sin embargo, cuando el LSB es el qubit control, (por ejemplo, ``cx(q[0],q[1])``), esta compuerta es equivalente a la siguiente matriz:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1977
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2092
msgid "Controlled :math:`Y` gate"
msgstr "Compuerta :math:`Y` controlada"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2094
msgid "Apply the :math:`Y` gate to the target qubit if the control qubit is the MSB"
msgstr "Aplicamos la compuerta :math:`Y` al qubit de objetivo si el qubit de control es el MSB"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2096
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2107
msgid "or when the LSB is the control"
msgstr "o cuando el LSB es el control"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2109
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2224
msgid "Controlled :math:`Z` (or, controlled Phase) gate"
msgstr "Compuerta controlada :math:`Z` (o, fase controlada)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2226
msgid "Similarly, the controlled Z gate flips the phase of the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks the same regardless of whether the MSB or LSB is the control qubit:"
msgstr "Del mismo modo, la compuerta Z controlada invierte la fase del qubit objetivo si el qubit de control es :math:`\\left|1\\rángulo\\rluz`. La matriz se ve igual independientemente de si el MSB o LSB es el qubit de control:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2228
msgid "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2343
msgid "Controlled Hadamard gate"
msgstr "Compuerta de Hadamard controlada"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2345
msgid "Apply :math:`H` gate to the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. Below is the case where the control is the LSB qubit."
msgstr "Aplique la compuerta :math:`H` al qubit de objetivo si el qubit de control es :math:`\\left | 1\\right\\rangle`. A continuación se muestra el caso en el que el control es el qubit LSB."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2347
msgid "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2462
msgid "Controlled rotation gates"
msgstr "Compuertas de rotación controladas"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2465
msgid "Controlled rotation around Z-axis"
msgstr "Rotación controlada alrededor del eje Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2467
msgid "Perform rotation around Z-axis on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Realice la rotación alrededor del eje Z en el qubit de destino si el qubit de control (aquí LSB) es :math:`\\left | 1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2469
msgid "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2584
msgid "Controlled phase rotation"
msgstr "Rotación de fase controlada"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2586
msgid "Perform a phase rotation if both qubits are in the :math:`\\left|11\\right\\rangle` state. The matrix looks the same regardless of whether the MSB or LSB is the control qubit."
msgstr "Realiza una rotación de fase si ambos qubits están en el estado :math:`\\left|11\\right\\rangle`. La matriz tiene el mismo aspecto independientemente de si el MSB o LSB es el qubit de control."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2588
msgid "C_{u1}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2703
msgid "Controlled :math:`u3` rotation"
msgstr "Rotación :math:`u3` controlada"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2705
msgid "Perform controlled-\\ :math:`u3` rotation on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Realiza la rotación controlada-\\ :math:`u3` en el qubit objetivo si el qubit de control (aquí LSB) es :math:`\\left|1\\right\\range`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2707
msgid "C_{u3}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2822
msgid "SWAP gate"
msgstr "Compuerta SWAP"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2824
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr "La compuerta SWAP intercambia los dos qubits. Transforma los vectores bases como"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2826
msgid "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2828
msgid "which gives a matrix representation of the form"
msgstr "que da una representación matricial de la forma"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2830
msgid "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2945
msgid "Three-qubit gates"
msgstr "Compuertas de tres qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2947
msgid "There are two commonly-used three-qubit gates. For three qubits, the basis vectors are ordered as"
msgstr "Hay dos compuertas de tres qubit comúnmente usadas. Para tres qubits, los vectores base se ordenan como"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2949
msgid "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2951
msgid "which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. Again, Qiskit uses a representation in which the first qubit is on the right-most side of the tensor product and the third qubit is on the left-most side:"
msgstr "que, como cadenas de bits, representan los enteros :math:`0,1,2,\\cdots, 7`. Nuevamente, Qiskit utiliza una representación en la que el primer qubit está en el lado más derecho del producto tensorial y el tercer qubit está en el lado izquierdo:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2953
msgid "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2965
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr "Compuerta de Toffoli (compuerta :math:`ccx`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2967
msgid "The `Toffoli gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ flips the third qubit if the first two qubits (LSB) are both :math:`\\left|1\\right\\rangle`:"
msgstr "La `compuerta de Toffoli <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ invierte el tercer qubit si los dos primeros qubits (LSB) son ambos :math:`\\left|1\\right\\rangle`:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2969
msgid "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2971
msgid "In matrix form, the Toffoli gate is"
msgstr "En forma matricial, la compuerta de Toffoli es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2973
msgid "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3116
msgid "Controlled swap gate (Fredkin Gate)"
msgstr "Compuerta de intercambio controlada (Compuerta Fredkin)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3118
msgid "The `Fredkin gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, or the *controlled swap gate*, exchanges the second and third qubits if the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr "La `compuerta de Fredkin <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, o la *compuerta de intercambio controlada*, intercambia el segundo y tercer qubits si el primer qubit (LSB) es :math:`\\left|1\\right\\rangle`:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3120
msgid "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3122
msgid "In matrix form, the Fredkin gate is"
msgstr "En forma matricial, la compuerta de Fredkin es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3124
msgid "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3257
msgid "Non-unitary operations"
msgstr "Operaciones no unitarias"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3259
msgid "Now that we have gone through all the unitary operations in quantum circuits, we also have access to non-unitary operations. These include measurements, reset of qubits, and classical conditional operations."
msgstr "Ahora que hemos pasado por todas las operaciones unitarias en circuitos cuánticos, también tenemos acceso a operaciones no unitarias. Estas incluyen mediciones, reinicio de qubits, y operaciones condicionales clásicas."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3284
msgid "We don’t have access to all the information when we make a measurement in a quantum computer. The quantum state is projected onto the standard basis. Below are two examples showing a circuit that is prepared in a basis state and the quantum computer prepared in a superposition state."
msgstr "No tenemos acceso a toda la información cuando hacemos una medición en una computadora cuántica. El estado cuántico es proyectado a una de las bases estándar. A continuación hay dos ejemplos que muestran un circuito preparado en un estado base y la computadora cuántica preparada en un estado de superposición."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3384
msgid "The simulator predicts that 100 percent of the time the classical register returns 0."
msgstr "El simulador predice que el 100% de las veces el registro clásico devuelve 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3484
msgid "The simulator predicts that 50 percent of the time the classical register returns 0 or 1."
msgstr "El simulador predice que el 50% de las veces, el registro clásico devuelve 0 o 1."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3498
msgid "It is also possible to ``reset`` qubits to the :math:`\\left|0\\right\\rangle` state in the middle of computation. Note that ``reset`` is not a Gate operation, since it is irreversible."
msgstr "También es posible ``reset``  (reiniciar) qubits al estado :math:`\\left|0\\right\\rangle` en medio del cálculo. Tenga en cuenta que ``reset`` no es una operación de compuerta, ya que es irreversible."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3688
msgid "Here we see that for both of these circuits the simulator always predicts that the output is 100 percent in the 0 state."
msgstr "Aquí vemos que para ambos de estos circuitos el simulador siempre predice que la salida es del 100 porciento en el estado 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3700
msgid "Conditional operations"
msgstr "Operaciones condicionales"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3702
msgid "It is also possible to do operations conditioned on the state of the classical register"
msgstr "También es posible realizar operaciones condicionadas al estado del registro clásico"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3774
msgid "Here the classical bit always takes the value 0 so the qubit state is always flipped."
msgstr "Aquí el bit clásico siempre toma el valor 0 para que el estado del qubit sea siempre volteado."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3910
msgid "Here the classical bit by the first measurement is random but the conditional operation results in the qubit being deterministically put into :math:`\\left|1\\right\\rangle`."
msgstr "Aquí el bit clásico por la primera medición es aleatorio, pero la operación condicional da como resultado que el qubit sea determinísticamente puesto en :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3922
msgid "Arbitrary initialization"
msgstr "Inicialización arbitraria"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3924
msgid "What if we want to initialize a qubit register to an arbitrary state? An arbitrary state for :math:`n` qubits may be specified by a vector of :math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals 1. For example, the following three-qubit state can be prepared:"
msgstr "¿Qué pasa si queremos inicializar un registro del qubit a un estado arbitrario? Un estado arbitrario para :math:`n` qubits puede ser especificado por un vector de :math:`2^n` amplitudes, donde la suma de amplitud-normas al cuadrado es igual a 1. Por ejemplo, el siguiente estrado de 3 qubits puede ser preparado:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3926
msgid "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4055
msgid "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ is useful to check whether two states are the same or not. For quantum (pure) states :math:`\\left|\\psi_1\\right\\rangle` and :math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr "`Fidelidad <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>` __ es útil para comprobar si dos estados son iguales o no. Para estados cuánticos (puros) :math:` \\left | \\psi_1\\right\\rangle ` y :math:` \\left | \\psi_2\\right\\rangle `, la fidelidad es"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4057
msgid "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4062
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr "La fidelidad es igual a :math:`1` si y sólo si dos estados son iguales."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4104
msgid "Further details:"
msgstr "Más detalles:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4106
msgid "How does the desired state get generated behind the scenes? There are multiple methods for doing this. Qiskit uses a `method proposed by Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to assume the quantum register to have started from our desired state, and construct a circuit that takes it to the :math:`\\left|00..0\\right\\rangle` state. The initialization circuit is then the reverse of such circuit."
msgstr "¿Cómo se genera el estado deseado detrás de las escenas? Hay varios métodos para hacer esto. Qiskit usa un `método propuesto por Shende et al <https://arxiv.org/abs/quant-ph/0406176>` __. Aquí, la idea es asumir que el registro cuántico ha comenzado desde nuestro estado deseado, y construir un circuito que lo lleve al estado :math:`\\left|00..0\\right\\rangle`. El circuito de inicialización es entonces el reverso de tal circuito."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4108
msgid "To take an arbitrary quantum state to the zero state in the computational basis, we perform an iterative procedure that disentangles qubits from the register one-by-one. We know that any arbitrary single-qubit state :math:`\\left|\\rho\\right\\rangle` can be taken to the :math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree rotation about the Z axis followed by a :math:`\\theta`-degree rotation about the Y axis:"
msgstr "Para llevar un estado cuántico arbitrario al estado cero en la base computacional, realizamos un procedimiento iterativo que desentrelaza los qubits del registro uno por uno. Sabemos que cualquier estado arbitrario de un solo qubit :math:`\\left|\\rho\\right\\rangle` puede ser llevado al estado de ángulo :math:`\\left|0\\right\\rangle` utilizando una rotación de :math:`\\phi`-grados sobre el eje Z seguido de una rotación de :math:`\\theta`-grados sobre el eje Y:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4110
msgid "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4112
msgid "Since now we are dealing with :math:`n` qubits instead of just 1, we must factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr "Puesto que ahora estamos tratando con :math:`n` qubits en lugar de sólo 1, debemos factorizar el vector del estado para separar el bit menos significativo (LSB):"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4114
msgid "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4122
msgid "Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to :math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and :math:`\\theta` angles per the equation above. Doing this simultaneously on all states amounts to the following unitary, which disentangles the LSB:"
msgstr "Ahora, cada uno de los estados de un solo qubit :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` se puede llevar al ángulo :math:`\\left|0\\right\\rangle` mediante la búsqueda de los ángulos :math:`\\phi` and :math:`\\theta` apropiados por la ecuación anterior. Hacer esto simultáneamente en todos los estados equivale a la siguiente unitario, que desentrelaza el LSB:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4124
msgid "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4134
msgid "Hence,"
msgstr "Por lo tanto,"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4136
msgid "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4138
msgid "U can be implemented as a “quantum multiplexor” gate, since it is a block diagonal matrix. In the quantum multiplexor formalism, a block diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select qubits and :math:`n-s` data qubits. Depending on the state of the select qubits, the corresponding blocks are applied to the data qubits. A multiplexor of this kind can be implemented after recursive decomposition to primitive gates of cx, rz and ry."
msgstr "U se puede implementar como una compuerta de \"multiplexor cuántico\", ya que es una matriz diagonal de bloque. En el formalismo del multiplexor cuántico, una matriz diagonal de bloque de tamaño :math:`2^n \\times 2^n`, y que consiste de :math:`2^s` bloques, es equivalente a un multiplexor con :math:`s` qubits seleccionados y :math:`n-s` qubits de datos. Dependiendo del estado de los qubits seleccionados, los bloques correspondientes se aplican a los qubits de datos. Un multiplexor de este tipo puede ser implementado después de una descomposición recursiva a las compuertas primitivas de cx, rz y ry."


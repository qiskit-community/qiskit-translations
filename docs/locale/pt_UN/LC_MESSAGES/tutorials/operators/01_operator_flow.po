msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-02 21:04+0000\n"
"PO-Revision-Date: 2023-03-02 21:47\n"
"Last-Translator: \n"
"Language: pt_UN\n"
"Language-Team: Portuguese (United)\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: pr\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "Esta página foi gerada, a partir do `tutorials/operators/01_operator_flow.ipynb`__."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "Fluxo do operador"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "Introdução"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit fornece classes representando estados, operadores e somas, produtos de tensores e composições. Estas construções algébricas nos permitem construir expressões representando os operadores."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Introduzimos expressões construindo-as a partir de operadores Pauli. Nas seções subsequentes, exploramos com mais detalhes os operadores e os estados, como estão representados e o que podemos fazer com eles. Na última seção nós construímos um estado, evoluindo-o com um operador Hamiltoniano e calculando os valores de expectativa desse observável."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Operadores Pauli, somas, composições e produtos de tensor"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "Os operadores de base mais importantes são os operadores Pauli. Os operadores Pauli estão representados assim."

#: ../../tutorials/operators/01_operator_flow.ipynb:76
msgid "These operators may also carry a coefficient."
msgstr "Estes operadores também podem transportar um coeficiente."

#: ../../tutorials/operators/01_operator_flow.ipynb:125
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "Estes coeficientes permitem que os operadores sejam utilizados como termos em uma soma."

#: ../../tutorials/operators/01_operator_flow.ipynb:173
msgid "Tensor products are denoted with a caret, like this."
msgstr "Os produtos de tensor são denotados com um identificador, como este."

#: ../../tutorials/operators/01_operator_flow.ipynb:218
msgid "Composition is denoted by the ``@`` symbol."
msgstr "A composição é indicada pelo símbolo ``@``."

#: ../../tutorials/operators/01_operator_flow.ipynb:263
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "Nos dois exemplos anteriores, o produto de tensor e a composição dos operadores Pauli foram imediatamente reduzidos ao equivalente (possivelmente multi-qubit) operador Pauli. Se usar o tensor ou se compormos objetos mais complicados, o resultado são objetos que representam as operações não avaliadas, ou seja, expressões algébricas."

#: ../../tutorials/operators/01_operator_flow.ipynb:274
msgid "For example, composing two sums gives"
msgstr "Por exemplo, compondo duas somas temos"

#: ../../tutorials/operators/01_operator_flow.ipynb:328
msgid "And tensoring two sums gives"
msgstr "E usando o tensor, duas somas retornam"

#: ../../tutorials/operators/01_operator_flow.ipynb:382
msgid "Let’s take a closer look at the types introduced above. First the Pauli operators."
msgstr "Vamos dar uma olhada nos tipos introduzidos acima. Primeiro nos operadores Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:428
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "Cada operador Pauli é uma instância de ``PauliOp``, que envolve uma instância de ``qiskit.quantum_info.Pauli`` e adiciona um coeficiente ``coeff``. Em geral, um ``PauliOp`` representa um produto de tensor ponderado dos operadores Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:474
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Para a codificação dos operadores Pauli como pares de valores booleanos, consulte a documentação ``qiskit.quantum_info.Pauli``."

#: ../../tutorials/operators/01_operator_flow.ipynb:476
msgid "All of the objects representing operators, whether as “primitive”s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr "Todos os objetos representando os operadores, sejam como “primitivas” tais como o ``PauliOp`` ou expressões algébricas, carregam um coeficiente"

#: ../../tutorials/operators/01_operator_flow.ipynb:530
msgid "In the following we take a broader and deeper look at Qiskit’s operators, states, and the building blocks of quantum algorithms."
msgstr "No que se segue, analisamos mais ampla e profundamente os operadores do Qiskit, os estados e os blocos de construção de algoritmos quânticos."

#: ../../tutorials/operators/01_operator_flow.ipynb:542
msgid "Part I: State Functions and Measurements"
msgstr "Parte I: Funções e Medidas do Estado"

#: ../../tutorials/operators/01_operator_flow.ipynb:544
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "Os estados quânticos são representados por subclasses da classe ``StateFn``. Existem quatro representações de estados quânticos: ``DictStateFn`` é uma representação esparsa na base computacional, apoiada por um ``dict``. ``VectorStateFn`` é uma representação densa na base computacional apoiada por um array numpy. ``CircuitStateFn`` é apoiado por um circuito e representa o estado obtido executando o circuito sobre o estado de base computacional all-zero. ``OperatorStateFn`` representa estados mistos através de uma matriz de densidade. (Como veremos mais adiante, ``OperatorStateFn`` também é usado para representar observáveis.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:547
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "Várias instâncias ``StateFn`` são fornecidas por conveniência. Por exemplo ``Zero, One, Plus, Minus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:569
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "``Zero`` e ``One`` representam os estados quânticos :math:`|0\\rangle` e :math:`|1\\rangle`. Eles são representados via ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:614
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr "``Plus`` e ``Minus``, representando estados :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` e :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` são representados via circuitos. ``H`` é um sinônimo de ``Plus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:683
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "Indexar em estados quânticos é feito com o método ``eval``. Estes exemplos retornam os coeficientes dos estados base ``0`` e ``1``. (Abaixo, veremos que o método ``eval`` é usado também para outras computações.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:744
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "O vetor duplo de um estado quântico, que é o *bra* correspondente a um *ket* é obtido através do método ``adjoint``. O ``StateFn`` transporta uma medição ``is_measurement`` que é ``False`` se o objeto é um ket e ``True`` se é um bra."

#: ../../tutorials/operators/01_operator_flow.ipynb:755
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "Aqui, nós construímos :math:`\\langle 1 |`."

#: ../../tutorials/operators/01_operator_flow.ipynb:801
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "Por conveniência, pode-se obter o duplo vetor com um til, da seguinte forma"

#: ../../tutorials/operators/01_operator_flow.ipynb:848
msgid "Algebraic operations and predicates"
msgstr "Operações algébricas e predicados"

#: ../../tutorials/operators/01_operator_flow.ipynb:850
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including:"
msgstr "Muitas operações algébricas e predicados entre ``StateFn``\\ s são suportados, incluindo:"

#: ../../tutorials/operators/01_operator_flow.ipynb:852
msgid "``+`` - addition"
msgstr "``+`` - adição"

#: ../../tutorials/operators/01_operator_flow.ipynb:853
msgid "``-`` - subtraction, negation (scalar multiplication by -1)"
msgstr "``-`` - subtração, negação (multiplicação escalar por -1)"

#: ../../tutorials/operators/01_operator_flow.ipynb:854
msgid "``*`` - scalar multiplication"
msgstr "``*`` - multiplicação escalar"

#: ../../tutorials/operators/01_operator_flow.ipynb:855
msgid "``/`` - scalar division"
msgstr "``/`` - divisão escalar"

#: ../../tutorials/operators/01_operator_flow.ipynb:856
msgid "``@`` - composition"
msgstr "``@`` - composição"

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "``^`` - tensor product or tensor power (tensor with self n times)"
msgstr "``^`` - produto tensorial ou potência tensorial (tensor com si mesmo n vezes)"

#: ../../tutorials/operators/01_operator_flow.ipynb:858
msgid "``**`` - composition power (compose with self n times)"
msgstr "``**`` - potência de composição (composição com si mesmo n vezes)"

#: ../../tutorials/operators/01_operator_flow.ipynb:859
msgid "``==`` - equality"
msgstr "``==`` - igualdade"

#: ../../tutorials/operators/01_operator_flow.ipynb:860
msgid "``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "``~`` - adjunto, alternando entre uma função de estado e medição"

#: ../../tutorials/operators/01_operator_flow.ipynb:862
msgid "Be very aware that these operators obey the `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, which might not be what you expect mathematically. For example, ``I^X + X^I`` will actually be parsed as ``I ^ (X + X) ^ I == 2 * (I^X^I)`` because Python evaluates ``+`` before ``^``. In these cases, you can use the methods (``.tensor()``, etc) or parentheses."
msgstr "Esteja bastante ciente de que esses operadores obedecem às `regras do Python para precedência de operador <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, o que pode não ser aquilo que você espera matematicamente. Por exemplo, ``I^X + X^I`` será realmente analisado como ``I ^ (X + X) ^ I == 2 * (I^X^I)`` porque o Python avalia ``+`` antes de ``^``. Nestes casos, você pode usar os métodos (``.tensor()``, etc) ou parênteses."

#: ../../tutorials/operators/01_operator_flow.ipynb:873
msgid "``StateFn``\\ s carry a coefficient. This allows us to multiply states by a scalar, and so to construct sums."
msgstr "``StateFn``\\ s carregam um coeficiente. Isso nos permite multiplicar estados por um escalar e, assim, construir somas."

#: ../../tutorials/operators/01_operator_flow.ipynb:884
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "Aqui, construímos :math:`(2 + 3i)|0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:930
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "Aqui, vemos que adicionando dois ``DictStateFn``\\ s retorna um objeto do mesmo tipo. Construímos :math:`|0\\rangle + |1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:975
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "Observe que você deve normalizar os estados manualmente. Por exemplo, para construir :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, nós escrevemos"

#: ../../tutorials/operators/01_operator_flow.ipynb:1023
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "Em outros casos, o resultado é uma representação simbólica de uma soma. Aqui, por exemplo, está uma representação de :math:`|+\\rangle + |-\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1101
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "O operador composição é usado para realizar um produto interno, que por padrão é mantido em uma forma não calculada. Aqui está uma representação de :math:`\\langle 1 | 1 \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1155
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "Note que a flag ``is_measurement`` faz com que o estado (bra) ``~One`` seja impresso como ``DictMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1166
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "Expressões simbólicas podem ser calculadas com o método ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1247
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "Aqui está :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1293
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "O operador composição ``@`` é equivalente a chamar o método ``compose``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1347
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "Produtos internos também podem ser calculados usando o método ``eval`` diretamente, sem construir um ``ComposedOp``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1393
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "Produtos de tensor simbólicos são construídos da seguinte forma. Aqui está :math:`|0\\rangle \\otimes |+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1459
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "Isto pode ser representado como um simples (não composto) ``CircuitStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "Potências de tensor são construídos usando o acento circunflexo ``^`` da seguinte forma. Aqui está o :math:`600 (|11111\\rangle + |00000\\rangle)` e :math:`|10\\rangle^{\\otimes 3}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1571
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "O método ``to_matrix_op`` converte para ``VectorStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1672
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "Construir um StateFn é fácil. A classe ``StateFn`` também serve como uma fábrica e pode receber qualquer primitivo aplicável em seu construtor e retornar a subclasse StateFn correta. Atualmente, os seguintes primitivos podem ser passados para o construtor, listados junto com a subclasse ``StateFn`` que eles produzem:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1674
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (igual a alguma bitstring de base) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1675
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1676
msgid "Qiskit Result object -> DictStateFn"
msgstr "Objeto Result do Qiskit -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1677
msgid "list -> VectorStateFn"
msgstr "lista -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1678
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1679
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1680
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1681
msgid "Instruction -> CircuitStateFn"
msgstr "Instrução -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1682
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase -> OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1764
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "Parte II: ``PrimitiveOp``\\ s"

#: ../../tutorials/operators/01_operator_flow.ipynb:1766
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "Os operadores básicos são subclasses de ``PrimitiveOp``. Assim como ``StateFn``, ``PrimitiveOp`` é também uma fábrica para criar o tipo correto de ``PrimitiveOp`` para um dado primitivo. Atualmente, os seguintes primitivos podem ser passados para o construtor, listados junto com a subclasse ``PrimitiveOp`` que eles produzem:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1768
msgid "Terra’s Pauli -> PauliOp"
msgstr "Terra’s Pauli -> PauliOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1769
msgid "Instruction -> CircuitOp"
msgstr "Instrução -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1770
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1771
msgid "2d List -> MatrixOp"
msgstr "Lista 2d -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1772
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1773
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1774
msgid "Terra’s quantum_info.Operator -> MatrixOp"
msgstr "quantum_info.Operator Terra -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1796
msgid "Matrix elements"
msgstr "Elementos da Matriz"

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "O método ``eval`` retorna uma coluna de um operador. Por exemplo, o operador Pauli :math:`X` é representado por um ``PauliOp``. Pedir uma coluna retorna uma instância da representação esparsa, uma ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1887
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "Daqui decorre que indexação em um operador, que está obtendo um elemento matrix é realizada com duas chamadas para o método ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1898
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "Temos :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. E o elemento da matriz :math:`\\left\\{X \\right\\}_{0,1}` é"

#: ../../tutorials/operators/01_operator_flow.ipynb:1944
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "Aqui está um exemplo usando o operador de dois qubit ``CX``, o ``X`` controlado, que é representado por um circuito."

#: ../../tutorials/operators/01_operator_flow.ipynb:2088
msgid "Applying an operator to a state vector"
msgstr "Aplicando um operador a um vetor de estado"

#: ../../tutorials/operators/01_operator_flow.ipynb:2099
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "Aplicar um operador a um vetor de estado pode ser feito com o método ``compose`` (equivalentemente o operador ``@``). Aqui está uma representação de :math:`X | 1 \\rangle = |0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2153
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "Uma representação mais simples, a representação ` ` DictStateFn ` ` ` de :math:`|0\\rangle`, é obtida com ` ` eval ` `."

#: ../../tutorials/operators/01_operator_flow.ipynb:2199
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "A etapa intermediária ``ComposedOp`` pode ser evitada com o uso ``eval`` diretamente."

#: ../../tutorials/operators/01_operator_flow.ipynb:2245
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "Composições e produtos de tensor de operadores são feitos com ``@`` e ``^``. Aqui estão alguns exemplos."

#: ../../tutorials/operators/01_operator_flow.ipynb:2449
msgid "Part III: ``ListOp`` and subclasses"
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2461
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2463
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp`` é um contêiner para vetorização efetiva de operações sobre uma lista de operadores e estados."

#: ../../tutorials/operators/01_operator_flow.ipynb:2537
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "Por exemplo, a composição acima é distribuída através das listas (``ListOp``) usando o método de simplificação ``reduce``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2646
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2648
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you’ve already played around with the above, you’ll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven’t implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you’ll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr "``ListOp``, introduzido acima é útil para operações de vetorização. Mas, ele também serve como uma superclasse para classes compostas por listas. Se você já usou o que foi exposto acima, notará que você pode facilmente realizar operações entre ``OperatorBase``\\ s que em geral podemos não saber como executar eficientemente (ou simplesmente por que não implementamos um procedimento eficiente ainda), como a adição entre ``CircuitOp``\\ s. Nesses casos, você pode receber um resultado ``ListOp`` (ou uma subclasse destes) da sua operação, representando uma execução lenta da operação. Por exemplo, se você tentar adicionar em conjunto um ``DictStateFn`` and a ``CircuitStateFn``, você receberá um ``SummedOp`` representando a soma dos dois. Esta função Estado composta ainda tem um ``eval`` funcional (mas pode precisar realizar um cálculo não escalável por baixo dos panos, como por exemplo, converter ambos para vetores)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2651
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "Estes ``OperatorBase``\\ s compostos são como construímos uma computação rica e cada vez mais complexa a partir dos blocos de construção ``PrimitiveOp`` e ``StateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2653
msgid "Every ``ListOp`` has four properties:"
msgstr "Cada ``ListOp`` tem quatro propriedades:"

#: ../../tutorials/operators/01_operator_flow.ipynb:2655
msgid "``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc."
msgstr "``oplist`` - A lista de ``OperatorBase``\\ s, que podem representar termos, fatores, etc."

#: ../../tutorials/operators/01_operator_flow.ipynb:2656
msgid "``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays."
msgstr "``combo_fn`` - A função leva uma lista de números complexos para um valor de saída que define como combinar as saídas dos itens do ``oplist``. Para simplificar a transmissão, essa função é definida em arrays NumPy."

#: ../../tutorials/operators/01_operator_flow.ipynb:2657
msgid "``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``."
msgstr "``coeff`` - Um coeficiente que multiplica o primitivo. Note que ``coeff`` pode ser int, float, complex ou um objeto ``Parameter`` livre (do ``qiskit.circuit`` no Terra) para ser vinculado posteriormente usando ``my_op.bind_parameters``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2658
msgid "``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "``abelian`` - Indica se os Operadores em ``oplist`` são conhecidos por comutarem mutuamente (geralmente definidos após serem convertidos pelo conversor ``AbelianGrouper``)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2660
msgid "Note that ``ListOp`` supports typical sequence overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "Observe que ``ListOp`` suporta sobrecargas de sequência típicas, então você pode usar indexação como ``my_op[4]`` para acessar o ``OperatorBase``\\ s em ``oplist``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2672
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2674
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "Nós mencionamos acima que ``OperatorStateFn`` representa um operador de densidade. Mas, se a medição ``is_measurement`` é ``True``, então ``OperatorStateFn`` representa um observável. O valor esperado deste observável pode então ser construído através de ``ComposedOp``. Ou, diretamente, usando ``eval``. Lembre que a medição ``is_measurement`` (propriedade) é definida através do método ``adjoint``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2685
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "Aqui construímos o observável correspondente ao operador Pauli :math:`Z`. Observe que, ao imprimir, ele é chamado de ``OperatorMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2757
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "Aqui, calculamos :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, e :math:`\\langle + | Z | + \\rangle`, onde :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2811
msgid "Part IV: Converters"
msgstr "Parte IV: Conversores"

#: ../../tutorials/operators/01_operator_flow.ipynb:2813
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter’s ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr "Conversores são classes que manipulam operadores e estados e executam blocos de construção de algoritmos. Exemplos incluem mudar a base dos operadores e Trotterização. Conversores examinam uma expressão e executam uma determinada manipulação ou substituição, definida pelo método ``convert()`` do conversor, dos Operadores internos. Normalmente, se um conversor encontra um ``OperatorBase`` na recursão que é irrelevante para o seu propósito de conversão, o ``OperatorBase`` é deixado inalterado."

#: ../../tutorials/operators/01_operator_flow.ipynb:2838
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "Evoluções, ``exp_i()``, e o ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2840
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can’t perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr "Todo ``PrimitiveOp`` e ``ListOp`` tem uma função ``.exp_i()`` tal que ``H.exp_i()`` corresponde a :math:`e^{-iH}`. Na prática, apenas alguns desses Operadores têm uma exponenciação computável eficientemente (como a MatrixOp e os PauliOps com apenas um único single-qubit Pauli não-identidade), por isso precisamos retornar um parâmetro provisório, ou representação simbólica, (semelhante a como ``SummedOp`` é um resultado representativo para quando não podemos realizar adição). Este marcador é chamado ``EvolvedOp`` e contém a ``OperatorBase`` a ser exponenciada em sua propriedade ``.primitive``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2843
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there’s no “evolution time” argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr "Operadores Qiskit suportam parametrização integralmente, então podemos usar um ``Parameter`` para o nosso tempo de evolução aqui. Observe que não há nenhum argumento de \"tempo de evolução\" em qualquer função. O Operador flui exponencialmente seja qual for o operador informado a ele, e se escolhermos multiplicar o operador por um tempo de evolução, :math:`e^{-iHt}`, isso será refletido em nossos parâmetros de exponenciação."

#: ../../tutorials/operators/01_operator_flow.ipynb:2855
msgid "Weighted sum of Pauli operators"
msgstr "Soma ponderada dos operadores Pauli"

#: ../../tutorials/operators/01_operator_flow.ipynb:2857
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "Um Hamiltoniano expresso como uma combinação linear de operadores Pauli multi-qubit podem ser construídos assim."

#: ../../tutorials/operators/01_operator_flow.ipynb:2882
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "Observe que ``two_qubit_H2`` é representado como um ``SummedOp`` cujos termos são ``PauliOp``\\ s."

#: ../../tutorials/operators/01_operator_flow.ipynb:2939
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "Em seguida, multiplicamos o Hamiltoniano por um ``Parameter``. Este ``Parameter`` é armazenado na propriedade ``coeff`` do ``SummedOp``. Chamando ``exp_i()`` no resultado, envolve-o em ``EvolvedOp``, representando uma exponenciação."

#: ../../tutorials/operators/01_operator_flow.ipynb:3014
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "Nós construímos ``h2_measurement``, que representa ``two_qubit_H2`` como um observável."

#: ../../tutorials/operators/01_operator_flow.ipynb:3072
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr "Nós construímos o estado de Bell :math:`|\\Phi_+\\rangle` através de :math:`\\text{CX} (H\\otimes I) |00\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3136
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "Aqui está a expressão :math:`H e^{-iHt} |\\Phi_+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3242
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "Normalmente, queremos aproximar :math:`e^{-iHt}` usando portões two-qubit. Conseguimos isso com o método ``convert`` do ``PauliTrotterEvolution``, que analisa expressões aplicando trotterização para todos ``EvolvedOp``\\ s encontrados. Embora utilizemos ``PauliTrotterEvolution`` aqui, existem outras possibilidades, como ``MatrixEvolution``, que executa a exponenciação de forma exata."

#: ../../tutorials/operators/01_operator_flow.ipynb:3361
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` contém um ``Parameter``. O método ``bind_parameters`` percorre a expressão ligando valores para nomes de parâmetro como especificado através da ``dict``. Neste caso, há apenas um parâmetro."

#: ../../tutorials/operators/01_operator_flow.ipynb:3382
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let’s draw it to verify that the binding has taken place."
msgstr "``bound`` é um ``ComposedOp``. O segundo fator é o circuito. Vamos desenhá-lo para confirmar que a ligação ocorreu."

#: ../../tutorials/operators/01_operator_flow.ipynb:3502
msgid "Expectations"
msgstr "Expectativas"

#: ../../tutorials/operators/01_operator_flow.ipynb:3504
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "``Expectation``\\ s são conversores que permitem o cálculo dos valores probabilísticos esperados de observáveis. Eles percorrem uma árvore do Operador, substituindo ``OperatorStateFn``\\ s (observáveis) por instruções equivalentes que são mais fáceis de calcular em hardware quântico ou clássico. Por exemplo, se quisermos medir o valor esperado de um Operador ``o`` expresso como uma soma de Paulis em relação a alguma função de estado, mas só podemos acessar medições diagonais em hardware quântico, nós podemos criar um ``~StateFn(o)`` e usar um ``PauliExpectation`` para convertê-lo em medições diagonais e pré-rotações de circuito para anexar ao estado."

#: ../../tutorials/operators/01_operator_flow.ipynb:3507
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "Outra ``Expectation`` interessante é a ``AerPauliExpectation``, que converte o observável em um ``CircuitStateFn`` contendo um instantâneo da instrução especial que ``Aer`` pode executar nativamente com alto desempenho."

#: ../../tutorials/operators/01_operator_flow.ipynb:3628
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "Por padrão o ``group_paulis=True``, que irá utilizar o ``AbelianGrouper`` para converter o ``SummedOp`` em grupos de Paulis mutuamente comutativos qubit-wise. Isto reduz a sobrecarga na execução do circuito, pois cada grupo pode compartilhar a execução do mesmo circuito."

#: ../../tutorials/operators/01_operator_flow.ipynb:3721
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "Observe que os conversores agem recursivamente, ou seja, eles percorrem uma expressão aplicando sua ação apenas quando possível. Assim, podemos apenas converter a nossa expressão de evolução completa e a expressão de medição. Nós poderíamos ter composto de forma equivalente ``h2_measurement`` com nossa evolução ``CircuitStateFn``. Procedemos aplicando a conversão na expressão toda."

#: ../../tutorials/operators/01_operator_flow.ipynb:3905
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "Agora vamos vincular vários valores de parâmetros em uma ``ListOp``, seguida de ``eval`` para avaliar a expressão inteira. Poderíamos ter usado ``eval`` anteriormente se nós vinculássemos mais cedo, mas não seria eficiente. Aqui, ``eval`` irá converter nosso ``CircuitStateFn``\\ s para ``VectorStateFn``\\ s internamente através de simulação."

#: ../../tutorials/operators/01_operator_flow.ipynb:3927
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "Aqui estão os valores esperados :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` correspondentes aos diferentes valores do parâmetro."

#: ../../tutorials/operators/01_operator_flow.ipynb:3980
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "Executando ``CircuitStateFn``\\ s com o ``CircuitSampler``"

#: ../../tutorials/operators/01_operator_flow.ipynb:3982
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFn``\\ s into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule)."
msgstr "O ``CircuitSampler`` percorre um Operador e converte qualquer ``CircuitStateFn``\\ s em aproximações da função de estado resultante por um ``DictStateFn`` ou ``VectorStateFn`` usando um backend quântico. Observe que para aproximar o valor do ``CircuitStateFn``, ele deve 1) enviar a função de estado através de um canal despolarizante, que destruirá todas as informações de fase e 2) substituir as frequências amostradas por **raízes quadradas** da frequência, em vez da probabilidade bruta de amostragem (que seria o equivalente a amostrar o **quadrado** da função de estado, de acordo com a regra de Born)."

#: ../../tutorials/operators/01_operator_flow.ipynb:4038
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "Note novamente que os circuitos são substituídos por *dicts* com **raízes quadradas** das probabilidades de amostragem do circuito. Dê uma olhada em uma sub-expressão antes e depois da conversão:"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-28 17:09+0000\n"
"PO-Revision-Date: 2021-06-28 18:34\n"
"Last-Translator: \n"
"Language-Team: Italian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: it\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/circuits/3_summary_of_quantum_operations.po\n"
"X-Crowdin-File-ID: 9118\n"
"Language: it_IT\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:10
msgid "This page was generated from `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."
msgstr "Questa pagina è stata generata a partire da `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr "Riepilogo delle Operazioni Quantistiche"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:20
msgid "In this section we will go into the different operations that are available in Qiskit Terra. These are:"
msgstr "In questa sezione vedremo le diverse operazioni disponibili su Qiskit Terra. Queste sono:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:22
msgid "Single-qubit quantum gates"
msgstr "Gate quantistici a singolo qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:23
msgid "Multi-qubit quantum gates"
msgstr "Gate quantistici a più qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:24
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3283
msgid "Measurements"
msgstr "Misurazioni"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:25
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3497
msgid "Reset"
msgstr "Reset"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:26
msgid "Conditionals"
msgstr "Istruzioni condizionali"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:27
msgid "State initialization"
msgstr "Inizializzazione arbitraria"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:29
msgid "We will also show you how to use the three different simulators:"
msgstr "Vi mostreremo anche come utilizzare i tre diversi simulatori:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:31
msgid "unitary_simulator"
msgstr "unitary_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:32
msgid "qasm_simulator"
msgstr "qasm_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:33
msgid "statevector_simulator"
msgstr "statevector_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:74
msgid "Single Qubit Quantum states"
msgstr "Stati quantistici di un singolo qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:76
msgid "A single qubit quantum state can be written as"
msgstr "Lo stato quantistico di un singolo qubit può essere descritto così"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:78
msgid "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:80
msgid "where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a measurement the probability of the bit being in :math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and :math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this is"
msgstr "dove :math:`\\alpha` e :math:`\\beta` sono numeri complessi. La probabilità che il qubit dia come risultato della misura :math:`\\left|0\\right\\rangle` è data da :math:`|\\alpha|^2`, mentre quella che dia come risultato :math:`\\left|1\\right\\rangle` è data da :math:`|\\beta|^2`. Sotto forma di vettore, lo stato si indica"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:82
msgid "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:91
msgid "Note, due to the conservation of probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` and since global phase is undetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` we only require two real numbers to describe a single qubit quantum state."
msgstr "E' da notare che, dal momento che la conservazione della probabilità impone che :math:`|\\alpha|^2+ |\\beta|^2 = 1`, e poichè la fase globale non è misurabile :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle`, bastano solo due numeri reali per descrivere lo stato di un singolo qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:93
msgid "A convenient representation is"
msgstr "Una rappresentazione utile è data da"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:95
msgid "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:97
msgid "where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq \\pi`. From this, it is clear that there is a one-to-one correspondence between qubit states (:math:`\\mathbb{C}^2`) and the points on the surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the Bloch sphere representation of a qubit state."
msgstr "dove :math:`0\\leq \\phi < 2\\pi`, e :math:`0\\leq \\theta \\leq \\pi`. Da questa formula si evince chiaramente l'esistenza di una corrispondenza uno a uno tra i possibili stati di un qubit (:math:`\\mathbb{C}^2`) ed i punti sulla superficie di una sfera unitaria (:math:`\\mathbb{R}^3`). Questa viene chiamata la rappresentazione sulla sfera di Bloch dello stato di un qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:99
msgid "Quantum gates/operations are usually represented as matrices. A gate which acts on a qubit is represented by a :math:`2\\times 2` unitary matrix :math:`U`. The action of the quantum gate is found by multiplying the matrix representing the gate with the vector which represents the quantum state."
msgstr "I gate/operatori quantistici sono generalmente rappresentati come matrici. Un gate che agisce su un qubit è rappresentato da una matrice unitaria :math:`2\\times 2`, :math:`U`. L'azione del gate quantistico sul qubit si ottiene moltiplicando la matrice che rappresenta l'operatore per il vettore che rappresenta lo stato quantistico."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:101
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:103
msgid "A general unitary must be able to take the :math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr "Una matrice unitaria generica deve essere in grado di portare lo stato :math:`\\left|0\\right\\rangle` allo stato sopra riportato. Questo si traduce in"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:105
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:113
msgid "where :math:`a` and :math:`b` are complex numbers constrained such that :math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and :math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where :math:`0\\leq \\lambda<2\\pi` giving"
msgstr "dove :math:`a` e :math:`b` sono numeri complessi che verificano :math:`U^\\dagger U = I` per ogni :math:`0\\leq\\theta\\leq\\pi` e :math:`0\\leq \\phi<2\\pi`. Questo introduce 3 vincoli, e tali che :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` e :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` con :math:`0\\leq \\lambda<2\\pi` arrivando a"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:115
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & -e^{i\\lambda}\\sin(\\theta/2) \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & e^{i\\lambda+i\\phi}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:123
msgid "This is the most general form of a single qubit unitary."
msgstr "Questa è la forma più generale di un operatore unitario che agisce su un singolo qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:135
msgid "Single-Qubit Gates"
msgstr "Gate a singolo qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:137
msgid "The single-qubit gates available are: - u gates - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr "I gate a singolo qubit disponibili possono essere divisi in: - gate u - gate identità - gate di Pauli - gate di Clifford - gate :math:`C3` - gate standard di rotazione"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:139
msgid "We have provided a backend: ``unitary_simulator`` to allow you to calculate the unitary matrices."
msgstr "Il backend ``unitary_simulator`` è a disposizione per calcolare le matrici unitarie."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:161
msgid "u gates"
msgstr "Gate u"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:163
msgid "In Qiskit we give you access to the general unitary using the :math:`u3` gate"
msgstr "All'interno del Qiskit si può usare il gate unitario generico tramite il gate :math:`u3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:165
msgid "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"
msgstr "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:263
msgid "The :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` gate has the matrix form"
msgstr "Il gate :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` ha la seguente forma matriciale"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:265
msgid "u2(\\phi, \\lambda) =\n"
"\\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n"
"1 & -e^{i\\lambda} \\\\\n"
"e^{i\\phi} & e^{i(\\phi + \\lambda)}\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:274
msgid "This is a useful gate as it allows us to create superpositions."
msgstr "Questo gate è molto utile perché permette di creare sovrapposizioni."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:369
msgid "The :math:`u1(\\lambda)= u3(0, 0, \\lambda)` gate has the matrix form"
msgstr "Il gate :math:`u1(\\lambda)= u3(0, 0, \\lambda)` ha la seguente forma matriciale"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:371
msgid "u1(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:380
msgid "which is useful as it allows us to apply a quantum phase."
msgstr "che è utile in quanto permette di applicare una fase quantistica."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:476
msgid "Identity gate"
msgstr "Gate identità"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:478
msgid "The identity gate is :math:`Id = u0(1)`."
msgstr "Il gate identità è :math:`Id = u0(1)`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:574
msgid "Pauli gates"
msgstr "Gate di Pauli"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:577
msgid ":math:`X`: bit-flip gate"
msgstr ":math:`X`: gate bit-flip"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:579
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr "Il gate bit-flip :math:`X` è definito come:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:581
msgid "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u3(\\pi,0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:684
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ":math:`Y`: gate bit- e phase-flip"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:686
msgid "The :math:`Y` gate is defined as:"
msgstr "Il gate :math:`Y` è definito come:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:688
msgid "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u3(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:791
msgid ":math:`Z`: phase-flip gate"
msgstr ":math:`Z`: gate phase-flip"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:793
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr "Il gate phase-flip :math:`Z` è definito come:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:795
msgid "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=u1(\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:898
msgid "Clifford gates"
msgstr "Gate di Clifford"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:901
msgid "Hadamard gate"
msgstr "Gate Hadamard"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:903
msgid "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u2(0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1007
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr "Gate :math:`S` (o, :math:`\\sqrt{Z}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1009
msgid "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= u1(\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1112
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr "Gate :math:`S^{\\dagger}` (o, coniugato di :math:`\\sqrt{Z}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1114
msgid "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= u1(-\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1217
msgid ":math:`C3` gates"
msgstr "Gate :math:`C3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1220
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr "Gate :math:`T` (o, :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1222
msgid "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= u1(\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1325
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr "Gate :math:`T^{\\dagger}` (o, coniugato di :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1327
msgid "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= u1(-\\pi/4)"
msgstr "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= u1(-\\pi/4)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1430
msgid "Standard Rotations"
msgstr "Rotazioni standard"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1432
msgid "The standard rotation gates are those that define rotations around the Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr "I gate di rotazione standard sono quelli che definiscono le rotazioni attorno ai gate di Pauli :math:`P=\\{X,Y,Z\\}`. Sono definiti come"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1434
msgid "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1437
msgid "Rotation around X-axis"
msgstr "Rotazione attorno all'asse X"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1439
msgid "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u3(\\theta, -\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1542
msgid "Rotation around Y-axis"
msgstr "Rotazione attorno all'asse Y"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1544
msgid "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u3(\\theta,0,0)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1647
msgid "Rotation around Z-axis"
msgstr "Rotazione attorno all'asse Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1649
msgid "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv u1(\\phi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1658
msgid "Note that here we have used an equivalent as it is different to u1 by a global phase :math:`e^{-i \\phi/2}`."
msgstr "È da notare che qui abbiamo usato un equivalente in quanto differisce da u1 per una fase globale :math:`e^{-i \\phi/2}`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1753
msgid "Note this is different due only to a global phase."
msgstr "Da notare che l'unica differenza è una fase globale."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1765
msgid "Multi-Qubit Gates"
msgstr "Gate multi-qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1768
msgid "Mathematical Preliminaries"
msgstr "Introduzione matematica"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1770
msgid "The space of a quantum computer grows exponentially with the number of qubits. For :math:`n` qubits the complex vector space has dimension :math:`d=2^n`. To describe states of a multi-qubit system, the tensor product is used to “glue together” operators and basis vectors."
msgstr "Lo spazio a disposizione di un computer quantistico cresce esponenzialmente con il numero di qubit. Per :math:`n` qubit lo spazio vettoriale complesso ha dimensione :math:`d=2^n`. Per descrivere gli stati di sistemi a più qubit, il prodotto tensoriale è lo strumento che unisce insieme operatori e vettori di base."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1772
msgid "Let’s start by considering a 2-qubit system. Given two operators :math:`A` and :math:`B` that each act on one qubit, the joint operator :math:`A \\otimes B` acting on two qubits is"
msgstr "Iniziamo considerando un sistema a due qubit. Dati due operatori :math:`A` e :math:`B` che agiscono ciascuno su un solo qubit, l'operatore unico :math:`A \\otimes B` che agisce sui due qubit è"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1774
msgid "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1796
msgid "where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of :math:`A` and :math:`B`, respectively."
msgstr "dove :math:`A_{jk}` e :math:`B_{lm}` sono gli elementi della matrice di :math:`A` e :math:`B`, rispettivamente."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1798
msgid "Analogously, the basis vectors for the 2-qubit system are formed using the tensor product of basis vectors for a single qubit:"
msgstr "Analogamente, i vettori di base del sistema a due qubit vengono formati usando il prodotto tensoriale dei vettori di base del singolo qubit:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1800
msgid "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1824
msgid "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1847
msgid "Note we’ve introduced a shorthand for the tensor product of basis vectors, wherein :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. The state of an :math:`n`-qubit system can be described using the :math:`n`-fold tensor product of single-qubit basis vectors. Notice that the basis vectors for a 2-qubit system are 4-dimensional; in general, the basis vectors of an :math:`n`-qubit system are :math:`2^{n}`-dimensional, as noted earlier."
msgstr "Da notare che abbiamo introdotto un'abbreviazione per il prodotto tensoriale dei vettori di base, per cui :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` è scritto come :math:`\\left|00\\right\\rangle`. Lo stato di un sistema a :math:`n`-qubit può essere descritto usando il prodotto tensoriale :math:`n`-fold dei vettori di base di singolo qubit. Da notare anche che i vettori di base per un sistema a due qubit sono quadri-dimensionali; in generale i vettori di base di un sistema a :math:`n`-qubit sono :math:`2^{n}`-dimensionali, come mostrato prima."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1850
msgid "Basis vector ordering in Qiskit"
msgstr "Ordinamento dei vettori di base in Qiskit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1852
msgid "Within the physics community, the qubits of a multi-qubit systems are typically ordered with the first qubit on the left-most side of the tensor product and the last qubit on the right-most side. For instance, if the first qubit is in state :math:`\\left|0\\right\\rangle` and second is in state :math:`\\left|1\\right\\rangle`, their joint state would be :math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different ordering of the qubits, in which the qubits are represented from the most significant bit (MSB) on the left to the least significant bit (LSB) on the right (big-endian). This is similar to bitstring representation on classical computers, and enables easy conversion from bitstrings to integers after measurements are performed. For the example just given, the joint state would be represented as :math:`\\left|10\\right\\rangle`. Importantly, *this change in the representation of multi-qubit states affects the way multi-qubit gates are represented in Qiskit*, as discussed below."
msgstr "All'interno della comunità della Fisica, i qubit di un sistema a più qubit sono tipicamente ordinati con il primo qubit all'estremo sinistro del prodotto tensoriale, e l'ultimo qubit all'estremo destro. Per esempio, se il primo qubit è nello stato :math:`\\left|0\\right\\rangle` e il secondo è nello stato :math:`\\left|1\\right\\rangle`, il loro stato combinato sarà :math:`\\left|01\\right\\rangle`. Qiskit usa un ordine dei qubit leggermente diverso, nel quale i qubit sono rappresentati a partire dal bit più significativo (MSB) a sinistra fino al bit meno significativo (LSB) a destra (big-endian). Questa convenzione è simile alla rappresentazione di stringhe di bit nei computer classici, e permette la facile conversione da stringhe di bit a interi dopo aver eseguito le misurazioni. Nell'esempio appena sopra, lo stato combinato sarà rappresentato come :math:`\\left|10\\right\\rangle`. È importante notare che *questo cambio nella rappresentazione di stati a più qubit influenza il modo in cui stati a più qubit sono rappresentati in Qiskit*, come discusso di seguito."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1855
msgid "The representation used in Qiskit enumerates the basis vectors in increasing order of the integers they represent. For instance, the basis vectors for a 2-qubit system would be ordered as :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. Thinking of the basis vectors as bit strings, they encode the integers 0,1,2 and 3, respectively."
msgstr "La rappresentazione usata in Qiskit elenca i vettori della base in ordine crescente in base agli interi che rappresentano. Per esempio, i vettori di base per un sistema a 2 qubit saranno ordinati come :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, e :math:`\\left|11\\right\\rangle`. Pensando ai vettori di base come a stringhe di bit, essi rappresentano gli interi 0, 1, 2 e 3, rispettivamente."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1858
msgid "Controlled operations on qubits"
msgstr "Operazioni controllate sui qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1860
msgid "A common multi-qubit gate involves the application of a gate to one qubit, conditioned on the state of another qubit. For instance, we might want to flip the state of the second qubit when the first qubit is in :math:`\\left|0\\right\\rangle`. Such gates are known as *controlled gates*. The standard multi-qubit gates consist of two-qubit gates and three-qubit gates. The two-qubit gates are: - controlled Pauli gates - controlled Hadamard gate - controlled rotation gates - controlled phase gate - controlled u3 gate - swap gate"
msgstr "Un tipico gate a più qubit comprende l'applicazione di un gate ad un qubit, condizionata dallo stato di un altro qubit. Ad esempio, si potrebbe voler invertire lo stato del secondo qubit quando il primo qubit è nello stato :math:`\\left|0\\right\\rangle`. Tali gate sono conosciuti come *gate controllati*. Il tipico gate a più qubit consiste di gate a due e tre qubit. I gate a due qubit sono: - gate di Pauli controllati - gate di Hadamard controllati - gate di rotazione controllati - gate di fase controllati - gate u3 controllati - swap gate"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1863
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr "I gate a tre qubit sono: - gate di Toffoli - gate di Fredkin"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1875
msgid "Two-qubit gates"
msgstr "Gate a due qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1877
msgid "Most of the two-qubit gates are of the controlled type (the SWAP gate being the exception). In general, a controlled two-qubit gate :math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the second qubit when the state of the first qubit is in :math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix representation"
msgstr "La maggior parte dei gate a due qubit sono di tipo controllato (con l'eccezione del gate SWAP). In generale, un gate a due qubit controllato :math:`C_{U}` agisce applicando il gate untario a singolo qubit :math:`U` al secondo qubit quando il primo qubit è nello stato :math:`\\left|1\\right\\rangle`. Si supponga che :math:`U` abbia una rappresentazione matriciale"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1879
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1881
msgid "We can work out the action of :math:`C_{U}` as follows. Recall that the basis vectors for a two-qubit system are ordered as :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the **control qubit** is **qubit 0** (which, according to Qiskit’s convention, is one the *right-hand* side of the tensor product). If the control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be applied to the **target** (qubit 1, on the *left-hand* side of the tensor product). Therefore, under the action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr "Si può comprendere l'azione di :math:`C_{U}` come segue. Si ricordi che i vettori di base per un sistema a due qubit sono ordinati come :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Si supponga che il **qubit di controllo** sia **qubit 0** (che, secondo la convenzione usata in Qiskit, è quello all' *estremo destro* del prodotto tensoriale). Se il qubit di controllo è nello stato :math:`\\left|1\\right\\rangle`, :math:`U` dovrebbe essere applicato al qubit di **target** (qubit 1, all' *estremo sinistro* del prodotto tensoriale). Quindi, per effetto di :math:`C_{U}`, i vettori di base sono trasformati secondo"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1884
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1893
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr "In forma matriciale, l'azione di :math:`C_{U}` è"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1895
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1906
msgid "To work out these matrix elements, let"
msgstr "Per arrivare a questi elementi di matrice, si consideri"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1908
msgid "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| k \\right\\rangle}\\right),\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1910
msgid "compute the action of :math:`C_{U}` (given above), and compute the inner products."
msgstr "si calcoli l'azione di :math:`C_{U}` (data sopra), e si calcolino i prodotti interni."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1912
msgid "As shown in the examples below, this operation is implemented in Qiskit as ``cU(q[0],q[1])``."
msgstr "Come mostrato negli esempi di seguito, questa operazione è implementata in Qiskit come ``cU(q[0],q[1])``."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1914
msgid "If **qubit 1 is the control and qubit 0 is the target**, then the basis vectors are transformed according to"
msgstr "Se **il qubit 1 è il qubit di controllo e il qubit 0 è quello target**, allora i vettori di base vengono trasformati secondo"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1916
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1925
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr "che implica che la forma matriciale di :math:`C_{U}` sia"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1927
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1958
msgid "Controlled Pauli Gates"
msgstr "Gate di Pauli controllati"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1961
msgid "Controlled-X (or, controlled-NOT) gate"
msgstr "Gate X controllato (o controlled-NOT)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1963
msgid "The controlled-not gate flips the ``target`` qubit when the control qubit is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr "Il gate controlled-not inverte il qubit ``target`` quando il qubit di controllo è nello stato :math:`\\left|1\\right\\rangle`. Se si considera il MSB come qubit di controllo (ad esempio ``cx(q[1],q[0])``), allora la matrice avrà la forma seguente"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1965
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1976
msgid "However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), this gate is equivalent to the following matrix:"
msgstr "Quando invece il qubit di controllo è il LSB (ad esempio ``cx(q[0],q[1])``), questo gate è equivalente alla seguente matrice:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1978
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2093
msgid "Controlled :math:`Y` gate"
msgstr "Gate :math:`Y` controllato"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2095
msgid "Apply the :math:`Y` gate to the target qubit if the control qubit is the MSB"
msgstr "Applica il gate :math:`Y` al qubit target, se il qubit di controllo è il MSB"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2097
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2108
msgid "or when the LSB is the control"
msgstr "o quando invece il LSB è il qubit di controllo"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2110
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2225
msgid "Controlled :math:`Z` (or, controlled Phase) gate"
msgstr "Gate :math:`Z` controllato (o fase controllata)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2227
msgid "Similarly, the controlled Z gate flips the phase of the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks the same regardless of whether the MSB or LSB is the control qubit:"
msgstr "In maniera simile, il gate Z controllato inverte la fase del qubit target se il qubit di controllo è :math:`\\left|1\\right\\rangle`. La matrice è la stessa indipendentemente dal fatto che il qubit di controllo sia il MSB o il LSB:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2229
msgid "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2344
msgid "Controlled Hadamard gate"
msgstr "Gate Hadamard Controllato"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2346
msgid "Apply :math:`H` gate to the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. Below is the case where the control is the LSB qubit."
msgstr "Applica il gate :math:`H` al qubit target se il qubit di controllo è nello stato :math:`\\left|1\\right\\rangle`. Di seguito è mostrato il caso in cui il qubit di controllo è il LSB."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2348
msgid "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2463
msgid "Controlled rotation gates"
msgstr "Gate di rotazione controllati"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2466
msgid "Controlled rotation around Z-axis"
msgstr "Rotazione controllata attorno all'asse Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2468
msgid "Perform rotation around Z-axis on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Esegue una rotazione attorno all'asse Z sul qubit target se il qubit di controllo (qui il LSB) è nello stato :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2470
msgid "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2585
msgid "Controlled phase rotation"
msgstr "Rotazione di fase controllata"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2587
msgid "Perform a phase rotation if both qubits are in the :math:`\\left|11\\right\\rangle` state. The matrix looks the same regardless of whether the MSB or LSB is the control qubit."
msgstr "Esegue una rotazione di fase se entrambi i qubit sono nello stato :math:`\\left|11\\right\\rangle`. La matrice è la stessa indipendentemente dal fatto che il qubit di controllo sia il MSB o il LSB."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2589
msgid "C_{u1}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2704
msgid "Controlled :math:`u3` rotation"
msgstr "Rotazione :math:`u3` controllata"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2706
msgid "Perform controlled-\\ :math:`u3` rotation on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Esegue una rotazione :math:`u3` controllata sul qubit target se il qubit di controllo (qui il LSB) è nello stato :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2708
msgid "C_{u3}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2823
msgid "SWAP gate"
msgstr "Gate SWAP"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2825
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr "Il gate SWAP scambia i due qubit. Trasforma i vettori di base secondo"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2827
msgid "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2829
msgid "which gives a matrix representation of the form"
msgstr "che produce la seguente rappresentazione matriciale"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2831
msgid "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2946
msgid "Three-qubit gates"
msgstr "Gate a tre qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2948
msgid "There are two commonly-used three-qubit gates. For three qubits, the basis vectors are ordered as"
msgstr "Ci sono due gate a tre qubit comunemente utilizzati. Per tre qubit, i vettori di base sono ordinati come segue"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2950
msgid "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2952
msgid "which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. Again, Qiskit uses a representation in which the first qubit is on the right-most side of the tensor product and the third qubit is on the left-most side:"
msgstr "che, come stringhe di bit, rappresentano gli interi :math:`0,1,2,\\cdots, 7`. Di nuovo, Qiskit usa una rappresentazione in cui il primo qubit è quello tutta a destra nel prodotto tensoriale, ed il terzo quello tutto a sinistra:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2954
msgid "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2966
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr "Gate Toffoli (:math:`ccx` gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2968
msgid "The `Toffoli gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ flips the third qubit if the first two qubits (LSB) are both :math:`\\left|1\\right\\rangle`:"
msgstr "Il `gate Toffoli <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ cambia il terzo qubit se i primi due qubit (LSB) sono entrambi :math:`\\left|1\\right\\rangle`:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2970
msgid "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2972
msgid "In matrix form, the Toffoli gate is"
msgstr "In forma matriciale, il gate Toffoli è"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2974
msgid "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3117
msgid "Controlled swap gate (Fredkin Gate)"
msgstr "Gate di scambio controllato (gate Fredkin)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3119
msgid "The `Fredkin gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, or the *controlled swap gate*, exchanges the second and third qubits if the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr "Il `gate Fredkin <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, o il *gate di scambio controllato*, scambia il secondo ed il terzo qubit se il primo qubit (LSB) è :math:`\\left|1\\right\\rangle`:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3121
msgid "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3123
msgid "In matrix form, the Fredkin gate is"
msgstr "In forma matriciale, il gate Fredkin è"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3125
msgid "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3258
msgid "Non-unitary operations"
msgstr "Operazioni non unitarie"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3260
msgid "Now that we have gone through all the unitary operations in quantum circuits, we also have access to non-unitary operations. These include measurements, reset of qubits, and classical conditional operations."
msgstr "Dopo aver visto tutte le operazioni unitarie disponibili nei circuiti quantistici, andiamo a osservare anche le operazioni non unitarie. Queste includono le misure, il reset dei qubit e le operazioni condizionali classiche."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3285
msgid "We don’t have access to all the information when we make a measurement in a quantum computer. The quantum state is projected onto the standard basis. Below are two examples showing a circuit that is prepared in a basis state and the quantum computer prepared in a superposition state."
msgstr "Non abbiamo accesso a tutte le informazioni quanto facciamo una misura in un computer quantistico. Lo stato quantistico viene proiettato nella base standard. Di seguito ci sono due esempi che mostrano un circuito preparato in uno stato di base ed il quantum computer preparato in uno stato di sovrapposizione."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3385
msgid "The simulator predicts that 100 percent of the time the classical register returns 0."
msgstr "Il simulatore prevede che al 100% di probabilità il registro classico restituirà 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3485
msgid "The simulator predicts that 50 percent of the time the classical register returns 0 or 1."
msgstr "Il simulatore prevede che al 50% di probabilità il registro classico restituirà 0 o 1."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3499
msgid "It is also possible to ``reset`` qubits to the :math:`\\left|0\\right\\rangle` state in the middle of computation. Note that ``reset`` is not a Gate operation, since it is irreversible."
msgstr "E' anche possibile ``effettuare il reset`` di qubit allo stato :math:`\\left|0\\right\\rangle` durante l'esecuzione. Da notare che il ``reset`` non è un gate di operazione, poichè non è reversibile."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3689
msgid "Here we see that for both of these circuits the simulator always predicts that the output is 100 percent in the 0 state."
msgstr "Qui vediamo che per entrambi questi circuiti il simulatore prevede sempre che l'output è al 100% di probabilità nello stato 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3701
msgid "Conditional operations"
msgstr "Operazioni condizionali"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3703
msgid "It is also possible to do operations conditioned on the state of the classical register"
msgstr "E' anche possibile fare delle operazioni condizionate dallo stato del registro classico"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3775
msgid "Here the classical bit always takes the value 0 so the qubit state is always flipped."
msgstr "Qui il bit classico prende sempre il valore 0 quindi lo stato del qubit viene sempre capovolto."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3911
msgid "Here the classical bit by the first measurement is random but the conditional operation results in the qubit being deterministically put into :math:`\\left|1\\right\\rangle`."
msgstr "Qui il bit classico che dipende dalla prima misura è casuale, ma l'operazione condizionale mette il qubit deterministicamente in :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3923
msgid "Arbitrary initialization"
msgstr "Inizializzazione arbitraria"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3925
msgid "What if we want to initialize a qubit register to an arbitrary state? An arbitrary state for :math:`n` qubits may be specified by a vector of :math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals 1. For example, the following three-qubit state can be prepared:"
msgstr "Cosa fare se si vuole inizializzare il registro di qubit in uno stato arbitrario? Uno stato arbitrario per :math:`n` qubit può essere specificato da un vettore di :math:`2^n` ampiezze, dove la somma dei quadrati delle norme delle ampiezze è uguale ad 1. Per esempio, è possibile preparare il seguente stato a 3 qubit:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3927
msgid "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4056
msgid "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ is useful to check whether two states are the same or not. For quantum (pure) states :math:`\\left|\\psi_1\\right\\rangle` and :math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr "La `fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ è utile per verificare se due stati sono uguali o meno. Per due stati quantistici (puri) :math:`\\left|\\psi_1\\right\\rangle` e :math:`\\left|\\psi_2\\right\\rangle`, la fidelity è"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4058
msgid "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4063
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr "La fidelity è uguale a :math:`1` se e solo se i due stati sono uguali."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4105
msgid "Further details:"
msgstr "Ulteriori dettagli:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4107
msgid "How does the desired state get generated behind the scenes? There are multiple methods for doing this. Qiskit uses a `method proposed by Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to assume the quantum register to have started from our desired state, and construct a circuit that takes it to the :math:`\\left|00..0\\right\\rangle` state. The initialization circuit is then the reverse of such circuit."
msgstr "Come viene generato lo stato desiderato dietro le quinte? Ci sono diversi metodi per farlo. Qiskit usa un `metodo proposto da Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Qui l'idea è di assumere che il registro quantistico parta dallo stato desiderato, e di costruire quindi un circuito che lo porti nello stato :math:`\\left|00..0\\right\\rangle`. Il circuito di inizializzazione è quindi l'inverso di questo circuito così costruito."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4109
msgid "To take an arbitrary quantum state to the zero state in the computational basis, we perform an iterative procedure that disentangles qubits from the register one-by-one. We know that any arbitrary single-qubit state :math:`\\left|\\rho\\right\\rangle` can be taken to the :math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree rotation about the Z axis followed by a :math:`\\theta`-degree rotation about the Y axis:"
msgstr "Per portare uno stato quantistico arbitrario allo stato zero nella base computazionale, viene fatta una procedura iterativa che distrugge l'entanglement dei qubit nel registro uno ad uno. Sappiamo che uno stato arbitrario a singolo qubit :math:`\\left|\\rho\\right\\rangle` può essere portato nello stato :math:`\\left|0\\right\\rangle` usando una rotazione di :math:`\\phi`-gradi attorno all'asse Z, seguita da una rotazione di :math:`\\theta`-gradi attorno all'asse Y:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4111
msgid "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4113
msgid "Since now we are dealing with :math:`n` qubits instead of just 1, we must factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr "Poichè ora si sta lavorando con :math:`n` qubit invece che con uno solo, serve rifattorizzare il vettore di stato per separare il bit meno significativo (LSB):"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4115
msgid "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4123
msgid "Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to :math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and :math:`\\theta` angles per the equation above. Doing this simultaneously on all states amounts to the following unitary, which disentangles the LSB:"
msgstr "Ora, ciascuno degli stati a singolo qubit :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` può essere portato in :math:`\\left|0\\right\\rangle` trovando gli angoli :math:`\\phi` e :math:`\\theta` appropriati per l'equazione di cui sopra. Fare questo simultaneamente su tutti gli stati corrisponde al seguente unitario, che rompe l'entanglement del LSB:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4125
msgid "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4135
msgid "Hence,"
msgstr "Quindi,"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4137
msgid "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4139
msgid "U can be implemented as a “quantum multiplexor” gate, since it is a block diagonal matrix. In the quantum multiplexor formalism, a block diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select qubits and :math:`n-s` data qubits. Depending on the state of the select qubits, the corresponding blocks are applied to the data qubits. A multiplexor of this kind can be implemented after recursive decomposition to primitive gates of cx, rz and ry."
msgstr "U può essere implementato come un gate \"quantum multiplexor\", dal momento che è una matrice diagonale a blocchi. Nel formalismo quantum multiplexor, una matrice diagonale a blocchi di dimensioni :math:`2^n \\times 2^n`, e formata da :math:`2^s` blocchi, è equivalente ad un multiplexor con :math:`s` qubit di selezione e :math:`n-s` qubit di dati. A seconda dello stato dei qubit di selezione, i blocchi corrispondenti sono applicati ai qubit dati. Un multiplexor di questo tipo può essere implementato dopo la scomposizione ricorsiva nei gate primitivi cx, rz e ry."


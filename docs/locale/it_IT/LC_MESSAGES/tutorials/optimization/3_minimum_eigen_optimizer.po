msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 18:58+0000\n"
"PO-Revision-Date: 2021-06-10 07:16\n"
"Last-Translator: \n"
"Language-Team: Italian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: it\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/optimization/3_minimum_eigen_optimizer.po\n"
"X-Crowdin-File-ID: 9152\n"
"Language: it_IT\n"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:10
msgid "This page was generated from `tutorials/optimization/3_minimum_eigen_optimizer.ipynb`__."
msgstr "Questa pagina è stata generata da `tutorials/optimization/3_minimum_eigen_optimizer.ipynb`__."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:12
msgid "Run interactively in the `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/optimization/3_minimum_eigen_optimizer.ipynb>`_."
msgstr "Esegui interattivamente in `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/optimization/3_minimum_eigen_optimizer.ipynb>`_."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:9
msgid "Minimum Eigen Optimizer"
msgstr "Minimum Eigen Optimizer"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:21
msgid "Introduction"
msgstr "Introduzione"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:32
msgid "An interesting class of optimization problems to be addressed by quantum computing are Quadratic Unconstrained Binary Optimization (QUBO) problems. Finding the solution to a QUBO is equivalent to finding the ground state of a corresponding Ising Hamiltonian, which is an important problem not only in optimization, but also in quantum chemistry and physics. For this translation, the binary variables taking values in :math:`\\{0, 1\\}` are replaced by spin variables taking values in :math:`\\{-1, +1\\}`, which allows to replace the resulting spin variables by Pauli Z matrices, and thus, an Ising Hamiltonian. For more details on this mapping we refer to [1]."
msgstr "Una classe interessante di problemi di ottimizzazione da affrontare per quanto riguarda il quantum computing sono i problemi di Quadratic Unvincolained Binary Optimization (QUBO). Trovare la soluzione a un QUBO equivale a trovare lo stato fondamentale di una corrispondente Hamiltoniana di Ising, un problema importante non solo nell'ottimizzazione, ma anche nella chimica quantistica e nella fisica. Per questa traduzione, le variabili binarie che assumono valori in :math:` \\ {0, 1 \\} ` sono sostituite da variabili di spin che assumono valori in :math:` \\ {-1, + 1\\} `, che consente di sostituire le variabili di spin risultante da quelle di Pauli Z, e quindi, un Hamiltoniano di Ising. Per maggiori dettagli su questa mappatura si può far riferimento a [1]."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:35
msgid "Qiskit provides automatic conversion from a suitable ``QuadraticProgram`` to an Ising Hamiltonian, which then allows to leverage all the ``MinimumEigenSolver`` such as - ``VQE``, - ``QAOA``, or - ``NumpyMinimumEigensolver`` (classical exact method)."
msgstr "Qiskit fornisce la conversione automatica da un idoneo ` ` Problema Quadratico ` ` ad una Hamiltoniana di Ising, che permette di far leva su tutti i ` ` MinimumEigenSolver ` ` quali - ` ` VQE ` `, - ` ` QAOA ` `, oppure - ` ` NumpyMinimumEigensolver ` ` (metodo esatto classico)."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:37
msgid "Qiskit wraps the translation to an Ising Hamiltonian (in Qiskit Aqua also called ``Operator``), the call to an ``MinimumEigensolver`` as well as the translation of the results back to ``OptimizationResult`` in the ``MinimumEigenOptimizer``."
msgstr "Qiskit include la traslazione ad una Hamiltoniana di Ising (in Qiskit Aqua anche denominato ``Operator``), la chiamata a un ``MinimumEigensolver`` nonché la traduzione dei risultati a ``OptimizationResult`` in ``MinimumEigenOptimizer``."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:39
msgid "In the following we first illustrate the conversion from a ``QuadraticProgram`` to an ``Operator`` and then show how to use the ``MinimumEigenOptimizer`` with different ``MinimumEigensolver`` to solve a given ``QuadraticProgram``. The algorithms in Qiskit automatically try to convert a given problem to the supported problem class if possible, for instance, the ``MinimumEigenOptimizer`` will automatically translate integer variables to binary variables or add a linear equality constraints as a quadratic penalty term to the objective. It should be mentioned that Aqua will through a ``QiskitOptimizationError`` if conversion of a quadratic program with integer variable is attempted."
msgstr "In quanto segue illustriamo per la prima volta la conversione da un ` ` QuadraticProgram ` ` ad un ` Operatore ` ` e poi mostrare come usare il ` ` MinimumEigenOptimizer ` ` con ` diverso ` ` MinimumEigensolver ` ` per risolvere un dato ` ` QuadraticProgram ` `. Gli algoritmi in Qiskit tentano automaticamente di convertire un determinato problema nella classe dei problemi supportati se possibile, ad esempio, il ` ` MinimumEigenOptimizer ` ` tradurrà automaticamente variabili intere a variabili binarie o aggiungerà un vincolo di uguaglianza lineare come termine di penalità quadratica all'obiettivo. Va ricordato che Aqua attraverserà un ` ` QiskitOptimizationError ` ` se si tenta la conversione di un programma quadratico con variabile intera."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:42
msgid "The circuit depth of ``QAOA`` potentially has to be increased with the problem size, which might be prohibitive for near-term quantum devices. A possible workaround is Recursive QAOA, as introduced in [2]. Qiskit generalizes this concept to the ``RecursiveMinimumEigenOptimizer``, which is introduced at the end of this tutorial."
msgstr "La profondità di circuito di ` ` QAOA ` ` potenzialmente deve essere aumentata con la dimensione del problema, che potrebbe essere proibitiva per i dispositivi quantistici a breve termine. Un possibile workaround è Recursive QAOA, come introdotto nel [2]. Qiskit generalizza questo concetto a ` ` RecursiveMinimumEigenOptimizer ` `, introdotto alla fine di questo tutorial."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:45
msgid "References"
msgstr "Riferimenti"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:47
msgid "[1] `A. Lucas, Ising formulations of many NP problems, Front. Phys., 12 (2014). <https://arxiv.org/abs/1302.5843>`__"
msgstr "[1] ` A. Lucas, Le formulazioni Ising di molti problemi NP, Fronte. Phys., 12 (2014). <https://arxiv.org/abs/1302.5843>` __"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:49
msgid "[2] `S. Bravyi, A. Kliesch, R. Koenig, E. Tang, Obstacles to State Preparation and Variational Optimization from Symmetry Protection, arXiv preprint arXiv:1910.08980 (2019). <https://arxiv.org/abs/1910.08980>`__"
msgstr "[2] `S. Bravyi, A. Kliesch, R. Koenig, E. Tang, Obstacles to State Preparation and Variational Optimization from Symmetry Protection, arXiv preprint arXiv:1910.08980 (2019). <https://arxiv.org/abs/1910.08980>`__"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:61
msgid "Converting a QUBO to an Operator"
msgstr "Conversione di un QUBO ad un Operatore"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:153
msgid "Next we translate this QUBO into an Ising operator. This results not only in an ``Operator`` but also in a constant offset to be taking into account to shift the resulting value."
msgstr "Successivamente traduciamo questo QUBO in un operatore di Ising. Questo risultato non solo in un ``Operator`` ma anche in un offset costante da prendere in considerazione per spostare il valore risultante."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:214
msgid "Sometimes an ``QuadraticProgram`` might also directly be given in the form of an ``Operator``. For such cases, Qiskit also provides a converter from an ``Operator`` back to a ``QuadraticProgram``, which we illustrate in the following."
msgstr "A volte un ``QuadraticProgram`` potrebbe anche essere dato direttamente sotto forma di ``Operatore``. In questi casi, Qiskit fornisce anche un convertitore da un ``Operator`` a un ``QuadraticProgram``, che illustriamo nel seguito."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:288
msgid "This converter allows, for instance, to translate an ``Operator`` to a ``QuadraticProgram`` and then solve the problem with other algorithms that are not based on the Ising Hamiltonian representation, such as the ``GroverOptimizer``."
msgstr "Questo convertitore consente, ad esempio, per tradurre un ``Operator`` in ``QuadraticProgram`` e quindi risolvere il problema con altri algoritmi che non sono basati sulla rappresentazione di Ising Hamiltonian, come ``GroverOptimizer``."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:300
msgid "Solving a QUBO with the MinimumEigenOptimizer"
msgstr "Risolvere un QUBO con MinimumEigenOptimizer"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:311
msgid "We start by initializing the ``MinimumEigensolver`` we want to use."
msgstr "Iniziamo inizializzando il ``MinimumEigensolver`` che vogliamo usare."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:337
msgid "Then, we use the ``MinimumEigensolver`` to create ``MinimumEigenOptimizer``."
msgstr "Quindi, usiamo il ``MinimumEigensolver`` per creare ``MinimumEigenOptimizer``."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:359
msgid "We first use the ``MinimumEigenOptimizer`` based on the classical exact ``NumPyMinimumEigensolver`` to get the optimal benchmark solution for this small example."
msgstr "Per prima cosa usiamo il ``MinimumEigenOptimizer`` basato sul classico esatto ``NumPyMinimumEigensolver`` per ottenere la soluzione di riferimento ottimale per questo piccolo esempio."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:404
msgid "Next we apply the ``MinimumEigenOptimizer`` based on ``QAOA`` to the same problem."
msgstr "Successivamente applichiamo lo ``MinimumEigenOptimizer`` basato su ``QAOA`` allo stesso problema."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:450
msgid "RecursiveMinimumEigenOptimizer"
msgstr "RecursiveMinimumEigenOptimizer"

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:461
msgid "The ``RecursiveMinimumEigenOptimizer`` takes a ``MinimumEigenOptimizer`` as input and applies the recursive optimization scheme to reduce the size of the problem one variable at a time. Once the size of the generated intermediate problem is below a given threshold (``min_num_vars``), the ``RecursiveMinimumEigenOptimizer`` uses another solver (``min_num_vars_optimizer``), e.g., an exact classical solver such as CPLEX or the ``MinimumEigenOptimizer`` based on the ``NumPyMinimumEigensolver``."
msgstr "La ` ` RecursiveMinimumEigenOptimizer ` ` assume un ` ` MinimumEigenOptimizer ` ` come input e applica lo schema di ottimizzazione ricorsiva per ridurre la dimensione del problema una variabile alla volta. Una volta che la dimensione del problema intermedio generato è al di sotto di una determinata soglia (` ` min_num_vars ` `), la ` ` RecursiveMinimumEigenOptimizer ` ` utilizza un altro solutore (` ` min_num_vars_optimizer ` `), ad esempio, un solutore classico esatto come CPLEX o il ` ` MinimumEigenOptimizer ` ` basato sul ` ` NumPyMinimumEigensolver ` `."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:463
msgid "In the following, we show how to use the ``RecursiveMinimumEigenOptimizer`` using the two ``MinimumEigenOptimizer`` introduced before."
msgstr "Qui di seguito mostriamo come usare il ``RecursiveMinimumEigenOptimizer`` usando i due ``MinimumEigenOptimizer`` introdotti prima."

#: ../../tutorials/optimization/3_minimum_eigen_optimizer.ipynb:474
msgid "First, we construct the ``RecursiveMinimumEigenOptimizer`` such that it reduces the problem size from 3 variables to 1 variable and then uses the exact solver for the last variable. Then we call ``solve`` to optimize the considered problem."
msgstr "In primo luogo, costruiamo il ` ` RecursiveMinimumEigenOptimizer ` ` tale che riduce la dimensione del problema da 3 variabili a 1 variabile e quindi utilizza il solutore esatto per l'ultima variabile. Poi chiamiamo ` ` risolto ` ` per ottimizzare il problema considerato."


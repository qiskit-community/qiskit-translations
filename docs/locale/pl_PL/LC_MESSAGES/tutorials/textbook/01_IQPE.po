msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-26 21:24+0000\n"
"PO-Revision-Date: 2023-08-14 19:15\n"
"Last-Translator: \n"
"Language: pl\n"
"Language-Team: Polish\n"
"Plural-Forms: nplurals=4; plural=(n==1 ? 0 : (n%10>=2 && n%10<=4) && (n%100<12 || n%100>14) ? 1 : n!=1 && (n%10>=0 && n%10<=1) || (n%10>=5 && n%10<=9) || (n%100>=12 && n%100<=14) ? 2 : 3);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: pl\n"
"X-Crowdin-File: /main/docs/locale/en/LC_MESSAGES/tutorials/textbook/01_IQPE.po\n"
"X-Crowdin-File-ID: 9622\n"

#: ../../tutorials/textbook/01_IQPE.ipynb:10
msgid "This page was generated from `tutorials/textbook/01_IQPE.ipynb`__."
msgstr "Ta strona została wygenerowana z `tutorials/textbook/01_IQPE.ipynb`__."

#: ../../tutorials/textbook/01_IQPE.ipynb:9
msgid "Iterative Quantum Phase Estimation Algorithm"
msgstr "Algorytm IQPE (Iterative Quantum Phase Estimation, pol. Iteracyjnej Estymacji Fazy Kwantowej)"

#: ../../tutorials/textbook/01_IQPE.ipynb:11
msgid "The goal of this tutorial is to understand how the Iterative Phase Estimation (IPE) algorithm works, why would we use the IPE algorithm instead of the QPE (Quantum Phase Estimation) algorithm and how to build it with Qiskit using the same circuit exploiting reset gate and the ``c_if`` method that allows to apply gates conditioned by the values stored in a classical register, resulting from previous measurements."
msgstr "Celem tego poradnika jest zrozumienie, jak algorytm IPE (Iterative Phase Estimation, pol. Iteracyjnej Estymacji Fazy) działa, dlaczego używalibyśmy algorytmu IPE zamiast algorytmu QPE (Quantum Phase Estimation, pol. Estymacji Fazy Kwantowej) oraz jak zbudować go z Qiskit przy użyciu tego samego obwodu wykorzystującego bramkę resetu i metodę ``c_if``, która pozwala stosować bramki uwarunkowane wartościami przechowywanymi w rejestrze klasycznym, wynikającymi z wcześniejszych pomiarów."

#: ../../tutorials/textbook/01_IQPE.ipynb:13
msgid "**References**"
msgstr "**Źródła**"

#: ../../tutorials/textbook/01_IQPE.ipynb:15
msgid "`Section 2 of Lab 4: Iterative Phase Estimation (IPE) Algorithm <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>`__"
msgstr "`Section 2 of Lab 4: Iterative Phase Estimation (IPE) Algorithm <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>`__"

#: ../../tutorials/textbook/01_IQPE.ipynb:17
msgid "`Ch.3.6 Quantum Phase Estimation <https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html>`__"
msgstr "`Ch.3.6 Quantum Phase Estimation <https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html>`__"

#: ../../tutorials/textbook/01_IQPE.ipynb:42
msgid "Conditioned gates: the c_if method"
msgstr "Bramki logiczne: metoda``c_if``"

#: ../../tutorials/textbook/01_IQPE.ipynb:53
msgid "Before starting the IPE algorithm, we will give a brief tutorial about the Qiskit conditional method, c_if, as it goes into building the IPE circuit."
msgstr "Przed rozpoczęciem algorytmu IPE przeprowadzimy krótki poradnik o metodzie warunkowej Qiskit, ``c_if``, ponieważ jest ona częścią składową budowy obwodu IPE."

#: ../../tutorials/textbook/01_IQPE.ipynb:55
msgid "``c_if`` is a function (actually a method of the gate class) to perform conditioned operations based on the value stored previously in a classical register. With this feature you can apply gates after a measurement in the same circuit conditioned by the measurement outcome."
msgstr "``c_if`` to funkcja (a właściwie metoda o funkcji bramki) wykonująca operacje warunkowe oparte na wartości przechowywanej wcześniej w rejestrze klasycznym. Z tą funkcją można stosować bramki po pomiarach w obwodzie uwarunkowanym rezultatem pomiaru."

#: ../../tutorials/textbook/01_IQPE.ipynb:57
msgid "For example, the following code will execute the :math:`X` gate if the value of the classical register is :math:`0`."
msgstr "Na przykład, poniższy kod uruchomi bramkę :math:`X`, jeśli wartość rejestru klasycznego to :math:`0`."

#: ../../tutorials/textbook/01_IQPE.ipynb:93
msgid "We highlight that the method c_if expects as the first argument a whole classical register, not a single classical bit (or a list of classical bits), and as the second argument a value in decimal representation (a non-negative integer), not the value of a single bit, 0, or 1 (or a list/string of binary digits)."
msgstr "Podkreślamy, że metoda ``c_if`` spodziewa się jako pierwszy argument całego klasycznego rejestru, nie pojedynczego bitu klasycznego (lub listy bitów klasycznych), oraz jako drugi argument wartość w postaci dziesiętnej (nieujemna liczba całkowita), nie wartości pojedynczego bitu, 0 lub 1 (lub listy/ciągu znaków binarnych)."

#: ../../tutorials/textbook/01_IQPE.ipynb:95
msgid "Let's make another example. Consider that we want to perform a bit flip on the third qubit after the measurements in the following circuit, when the results of the measurement of :math:`q_0` and :math:`q_1` are both :math:`1`."
msgstr "Kolejny przykład. Chcemy wykonać bit flip na trzecim kubicie po pomiarach w następującym obwodzie, kiedy wyniki pomiaru :math:` q_0 ` i :math:` q_1 ` wynoszą dla obu :math:` 1 `."

#: ../../tutorials/textbook/01_IQPE.ipynb:133
msgid "We want to apply the :math:`X` gate, only if both the results of the measurement of :math:`q_0` and :math:`q_1` are :math:`1`. We can do this using the c_if method, conditioning the application of :math:`X` depending on the value passed as argument to c_if."
msgstr "Chcemy zastosować bramę :math:` X `, tylko jeśli zarówno wynik pomiaru :math:` q_0 `, jak i :math:` q_1 ` wynosi :math:` 1 `. Możemy to zrobić za pomocą metody ``c_if``, warunkującej aplikację :math:` X ` w zależności od wartości przekazanej jako argument do ``c_if``."

#: ../../tutorials/textbook/01_IQPE.ipynb:135
msgid "We will have to encode the value to pass to the c_if method such that it will check the values 011 and 111 (in binary representation), since it does not matter what :math:`q_2` is measured as."
msgstr "Będziemy musieli zakodować wartość, aby przejść do metody ``c_if`` w taki sposób, że sprawdzi wartości 011 i 111 (w reprezentacji binarnej), ponieważ nie ma znaczenia to, co mierzone jest :math:` q_2 `."

#: ../../tutorials/textbook/01_IQPE.ipynb:137
msgid "The 2 integer values in decimal representation:"
msgstr "Dwie liczby całkowite w reprezentacji dziesiętnej:"

#: ../../tutorials/textbook/01_IQPE.ipynb:148
msgid "|330e1b62db344e379ea36318476c352d|"
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:150
msgid "330e1b62db344e379ea36318476c352d"
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:161
msgid "We can check the solutions using the bin() method in python (the prefix ``0b`` indicates the binary format)."
msgstr "Możemy sprawdzić rozwiązania za pomocą metody bin () w p=Pythonie (prefiks ``0b`` wskazuje format binarny)."

#: ../../tutorials/textbook/01_IQPE.ipynb:210
msgid "So we have to apply :math:`X` to :math:`q_2` using c_if two times, one for each value corresponding to 011 and 111."
msgstr "Zatem musimy zastosować :math:`X` do :math:`q_2` używając ``c_if`` dwa razy, po jednym dla każdej wartości odpowiadającej 011 i 111."

#: ../../tutorials/textbook/01_IQPE.ipynb:253
msgid "IPE"
msgstr "IPE"

#: ../../tutorials/textbook/01_IQPE.ipynb:255
msgid "The motivation for using the IPE algorithm is that QPE algorithm works fine for short depth circuits but when the circuit starts to grow, it doesn't work properly due to gate noise and decoherence times."
msgstr "Uzasadnieniem dla stosowania algorytmu IPE jest to, że algorytm QPE działa poprawnie w przypadku krótkich obwodów głębokości, ale gdy obwód zaczyna rosnąć, nie działa poprawnie ze względu na szum bramy i czasy dekoherencji."

#: ../../tutorials/textbook/01_IQPE.ipynb:257
msgid "The detailed explanation of how the algorithm works can be found in `Iterative Phase Estimation (IPE) Algorithm <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>`__. To understand QPE in depth, you can see also `Ch.3.6 Quantum Phase Estimation <https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html>`__."
msgstr "Szczegółowe wyjaśnienie, w jaki sposób działa algorytm, można znaleźć w ` Iterative Phase Estimation (IPE) Algorithm <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>` __. Aby zrozumieć QPE in depth, można zobaczyć również ` Ch. 3.6 Quantum phase estimation <https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html>` __."

#: ../../tutorials/textbook/01_IQPE.ipynb:260
msgid "IPE example with a 1-qubit gate for :math:`U`"
msgstr "Przykład IPE z 1-kubitową bramą dla :math:`U`"

#: ../../tutorials/textbook/01_IQPE.ipynb:262
msgid "We want to apply the IPE algorithm to estimate the phase for a 1-qubit operator :math:`U`. For example, here we use the :math:`S`-gate."
msgstr "Chcemy zastosować algorytm IPE, aby oszacować fazę dla operatora 1-kubitowego :math:`U`. Na przykład tutaj używamy :math:`S`-gate."

#: ../../tutorials/textbook/01_IQPE.ipynb:264
msgid "Let's apply the IPE algorithm to estimate the phase for :math:`S`-gate. Its matrix is"
msgstr "Zastosujmy algorytm IPE, aby oszacować fazę dla :math:` S `-gate. Jej macierz to"

#: ../../tutorials/textbook/01_IQPE.ipynb:266
msgid " S =\n"
"\\begin{bmatrix}\n"
"1 & 0\\\\\n"
"0 & e^\\frac{i\\pi}{2}\\\\\n"
"\\end{bmatrix}"
msgstr " S =\n"
"\\begin{bmatrix}\n"
"1 & 0\\\\\n"
"0 & e^\\frac{i\\pi}{2}\\\\\n"
"\\end{bmatrix}"

#: ../../tutorials/textbook/01_IQPE.ipynb:274
msgid "That is, the :math:`S`-gate adds a phase :math:`\\pi/2` to the state :math:`|1\\rangle`, leaving unchanged the phase of the state :math:`|0\\rangle`"
msgstr "Oznacza to, że :math:` S `-gate dodaje fazę :math:` \\pi/2 ` do stanu :math:` | 1\\rkąt `, pozostawiając niezmienioną fazę stanu :math:` | 0\\rkąt `"

#: ../../tutorials/textbook/01_IQPE.ipynb:276
msgid "S|1\\rangle = e^\\frac{i\\pi}{2}|1\\rangle\n\n"
msgstr "S|1\\rangle = e^\\frac{i\\pi}{2}|1\\rangle\n\n"

#: ../../tutorials/textbook/01_IQPE.ipynb:278
msgid "In the following, we will use the notation and terms used in `Section 2 of lab 4 <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>`__."
msgstr "Poniżej użyjemy adnotacji i terminów używanych w `Sekcja 2 laboratorium 4 <https://qiskit.org/textbook/ch-labs/Lab04_IterativePhaseEstimation.html#2-iterative-phase-estimation-ipe-algorithm>`__."

#: ../../tutorials/textbook/01_IQPE.ipynb:280
msgid "Let's consider to estimate the phase :math:`\\phi=\\frac{\\pi}{2}` for the eigenstate :math:`|1\\rangle`, we should find :math:`\\varphi=\\frac{1}{4}` (where :math:`\\phi = 2 \\pi \\varphi`). Therefore to estimate the phase we need exactly 2 phase bits, i.e. :math:`m=2`, since :math:`1/2^2=1/4`. So :math:`\\varphi=0.\\varphi_1\\varphi_2`."
msgstr "Rozważmy oszacowanie fazy :math:`\\phi=\\frac{\\pi}{2}` dla kąta ostrości :math:`|1\\r`, powinniśmy znaleźć :math:`\\varphi=\\frac{1}{4}` (gdzie :math:`\\phi = 2 \\pi \\varphi`). Dlatego, aby oszacować fazę, potrzebujemy dokładnie 2 bitów faz tj. :math:`m=2`, od :math:`1/2^2=1/4`. Zatem :math:`\\varphi=0.\\varphi_1\\varphi_2`."

#: ../../tutorials/textbook/01_IQPE.ipynb:282
msgid "Remember from the theory that for the IPE algorithm, :math:`m` is also the number of iterations, so we need only :math:`2` iterations or steps."
msgstr "Pamiętaj z teorii dla algorytmu IPE, :math:`m` jest również liczbą iteracji, więc potrzebujemy tylko :math:`2` iteracji lub kroków."

#: ../../tutorials/textbook/01_IQPE.ipynb:284
msgid "First, we initialize the circuit. IPE works with only 1 auxiliary qubit, instead of :math:`m` counting qubits of the QPE algorithm. Therefore, we need 2 qubits, 1 auxiliary qubit and 1 for the eigenstate of :math:`U`-gate, and a classical register of 2 bits, for the phase bits :math:`\\varphi_1`, :math:`\\varphi_2`."
msgstr "Po pierwsze, inicjujemy obwód. IPE pracuje tylko z 1 pomocniczym kubitem, zamiast :math:`m` liczenia kubitów algorytmu QPE. Dlatego potrzebujemy 2 kubitów, 1 dodatkowego kubitu i 1 dla stanu własnego z :math:` U `-gate, oraz klasycznego rejestru 2 bitów, dla bitó fazowych :math:`\\varphi_1 `, :math:`\\varphi_2`."

#: ../../tutorials/textbook/01_IQPE.ipynb:311
#: ../../tutorials/textbook/01_IQPE.ipynb:702
msgid "First step"
msgstr "Pierwszy krok"

#: ../../tutorials/textbook/01_IQPE.ipynb:313
msgid "Now we build the quantum circuit for the first step, that is, the first iteration of the algorithm, to estimate the least significant phase bit :math:`\\varphi_m`, in this case :math:`\\varphi_2`. For the first step we have 3 sub-steps: - initialization - application of the Controlled-:math:`U` gates - measure of the auxiliary qubit in x-basis"
msgstr "Teraz budujemy obwód kwantowy dla pierwszego kroku, czyli pierwszej iteracji algorytmu, aby oszacować najmniej istotny bit fazy :math:`\\varphi_m`, w tym przypadku :math:`\\varphi_2`. W pierwszym kroku mamy 3 podkroki: - inicjalizacja - zastosowanie bramek kontrolowanych -:math:`U` - pomiar pomocniczego kubitu w oparciu o x-podstawę"

#: ../../tutorials/textbook/01_IQPE.ipynb:316
#: ../../tutorials/textbook/01_IQPE.ipynb:707
msgid "Initialization"
msgstr "Inicjalizacja"

#: ../../tutorials/textbook/01_IQPE.ipynb:318
msgid "The initialization consists of application the Hadamard gate to the auxiliary qubit and the preparation of the eigenstate :math:`|1\\rangle`."
msgstr "Inicjalizacja polega na zastosowaniu bramy Hadamard do kubitu pomocniczego i przygotowania się do stanu własnego :math:` | 1\\rangle `."

#: ../../tutorials/textbook/01_IQPE.ipynb:351
#: ../../tutorials/textbook/01_IQPE.ipynb:742
msgid "Application of the Controlled-:math:`U` gates"
msgstr "Zastosowanie bramki Controlled-:math:`U`"

#: ../../tutorials/textbook/01_IQPE.ipynb:353
msgid "Then we have to apply :math:`2^t` times the Controlled-:math:`U` operators (see also in the docs `Two qubit gates <https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Two-qubit-gates>`__), that, in this example, is the Controlled-:math:`S` gate (:math:`CS` for short)."
msgstr "Następnie musimy zastosować :math:` 2 ^ t ` razy operatory Controlled-:math:` U ` (patrz także w dokumentach `Two qubit gates <https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Two-qubit-gates>` __), że w tym przykładzie jest to Controlled-:math:` S ` gate (:math:`CS` w skrócie)."

#: ../../tutorials/textbook/01_IQPE.ipynb:355
msgid "To implement :math:`CS` in the circuit, since :math:`S` is a phase gate, we can use the controlled phase gate :math:`\\text{CP}(\\theta)`, with :math:`\\theta=\\pi/2`."
msgstr "Aby zaimplementować :math:`CS` w obwodzie, gdyż :math:`S` jest bramą fazową, możemy użyć kontrolowanej bramki fazy :math:`\\text{CP}(\\theta)`, z :math:`\\theta=\\pi/2`."

#: ../../tutorials/textbook/01_IQPE.ipynb:387
msgid "Let's apply :math:`2^t` times :math:`\\text{CP}(\\pi/2)`. Since for the first step :math:`t=m-1`, and :math:`m=2`, we have :math:`2^t=2`."
msgstr "Zastosujmy :math:` 2 ^ t ` razy :math:`\\text{CP}(\\pi/2) `. Ponieważ dla pierwszego kroku :math:` t=m-1 `, oraz :math:` m=2 `, mamy :math:` 2 ^ t=2 `."

#: ../../tutorials/textbook/01_IQPE.ipynb:420
#: ../../tutorials/textbook/01_IQPE.ipynb:811
msgid "Measure in x-basis"
msgstr "Środek w x-podstawie"

#: ../../tutorials/textbook/01_IQPE.ipynb:422
msgid "Finally, we perform the measurement of the auxiliary qubit in x-basis. So we will define a function to perform the x_measure and then apply it."
msgstr "Na koniec wykonujemy pomiar kubitu pomocniczego w x-bazie. Zdefiniujemy więc funkcję, która będzie wykonywała x_measure, a następnie zastosuje ją."

#: ../../tutorials/textbook/01_IQPE.ipynb:446
msgid "In this way we obtain the phase bit :math:`\\varphi_2` and store it in the classical bit :math:`c_0`."
msgstr "W ten sposób uzyskujemy bit fazowy :math:` \\varphi_2 ` i przechowujemy go w klasycznym bicie :math:` c_0 `."

#: ../../tutorials/textbook/01_IQPE.ipynb:478
msgid "Subsequent steps (2nd step)"
msgstr "Kolejne kroki (drugi krok)"

#: ../../tutorials/textbook/01_IQPE.ipynb:480
msgid "Now we build the quantum circuit for the other remaining steps, in this example, only the second one. In these steps we have 4 sub-steps: the 3 sub-steps as in the first step and, in the middle, the additional step of the phase correction - initialization with reset - phase correction - application of the Controlled-:math:`U` gates - measure of the auxiliary qubit in x-basis"
msgstr "Teraz budujemy obwód kwantowy dla pozostałych kroków, w tym przykładzie, tylko dla drugiego. W tych krokach mamy 4 podkroki: 3 podkroki jak w pierwszym kroku, a w środku dodatkowy stopień korekcji fazowej - inicjowanie z resetowaniem - zastosowanie Controlled-:math:`U` bramek - pomiar kubitu pomocniczeego w x-podstawie"

#: ../../tutorials/textbook/01_IQPE.ipynb:483
#: ../../tutorials/textbook/01_IQPE.ipynb:850
msgid "Initialization with reset"
msgstr "Inicjowanie z resetowaniem"

#: ../../tutorials/textbook/01_IQPE.ipynb:485
msgid "As we want to perform an iterative algorithm in the same circuit, we need to reset the auxiliary qubit :math:`q0` after the measument gate and initialize it again as before to recycle the qubit."
msgstr "Jak chcemy wykonać algorytm iteracyjny w tym samym obwodzie, musimy zresetować pomocniczy kubit :math:` q0 ` po bramie pomiaru i zainicjalizować go jeszcze raz tak, jak przedtem, aby regenerować kubit."

#: ../../tutorials/textbook/01_IQPE.ipynb:518
#: ../../tutorials/textbook/01_IQPE.ipynb:883
msgid "Phase correction (for step 2)"
msgstr "Faza korekty (dla kroku 2)"

#: ../../tutorials/textbook/01_IQPE.ipynb:520
msgid "As seen in the theory, in order to extract the phase bit :math:`\\varphi_{1}`, we perform a phase correction of :math:`-\\pi\\varphi_2/2`. Of course, we need to apply the phase correction in the circuit only if the phase bit :math:`\\varphi_2=1`, i.e. we have to apply the phase correction of :math:`-\\pi/2` only if the classical bit :math:`c_0` is 1."
msgstr "Jak widać w teorii, w celu wyodrębnienia bitu fazowego :math:` \\varphi_{1}`, wykonujemy korektę fazową :math:`-\\pi\\varphi_2/2 `. Oczywiście, musimy zastosować korektę fazową w obwodzie tylko wtedy, gdy bit fazowy :math:` \\varphi_2 = 1 `, czyli musimy zastosować poprawkę fazową :math:`-\\pi/2 ` tylko wtedy, gdy klasyczny bit :math:` c_0 ` wynosi 1."

#: ../../tutorials/textbook/01_IQPE.ipynb:522
msgid "So, after the reset we apply the phase gate :math:`P(\\theta)` with phase :math:`\\theta=-\\pi/2` conditioned by the classical bit :math:`c_0` (:math:`=\\varphi_2`) using the ``c_if`` method. So as we saw in the first part of this tutorial, we have to use the ``c_if`` method with a value of 1, as :math:`1_{10} = 001_{2}` (the subscripts :math:`_{10}` and :math:`_2` indicate the decimal and binary representations)."
msgstr "Tak więc po zresetowaniu zastosujemy bramkę fazową :math:` P (\\theta) ` z fazą :math:`\\theta=-\\pi/2 ` uwarunkowaną klasycznym bitem :math:` c_0 ` (:math:` = \\varphi_2 `) przy użyciu metody ``c_if``. Tak więc, jak widzieliśmy w pierwszej części tego kursu, musimy użyć metody ``c_if`` o wartości 1, jako :math:` 1_{10} = 001 _{2}` (indeksy :math:` _{10}` i :math:` _2 ` wskazują reprezentacje dziesiętne i binarne)."

#: ../../tutorials/textbook/01_IQPE.ipynb:554
#: ../../tutorials/textbook/01_IQPE.ipynb:919
msgid "Application of the Controlled-:math:`U` gates and x-measurement (for step 2)"
msgstr "Zastosowanie bramki Controlled-:math:`U` i x-pomiar (dla kroku 2)"

#: ../../tutorials/textbook/01_IQPE.ipynb:556
msgid "We apply the :math:`CU` operations as we did in the first step. For the second step we have :math:`t=m-2`, hence :math:`2^t=1`. So we apply :math:`\\text{CP}(\\pi/2)` once. And then we perform the x-measurement of the qubit :math:`q_0`, storing the result, the phase bit :math:`\\varphi_1`, in the bit :math:`c_1` of classical register."
msgstr "Zastosujemy operacje :math:`CU` tak jak to zrobiliśmy w pierwszym kroku. W drugim kroku mamy :math:`t=m-2`, stąd :math:`2^t=1`. A zatem stosujemy :math:`\\text{CP}(\\pi/2)` jeden raz. A następnie wykonujemy x-pomiar kubitu :math:`q_0`, zapisując wynik, bity fazy :math:`\\varphi_1`, w bitie :math:`c_1` rejestru klasycznego."

#: ../../tutorials/textbook/01_IQPE.ipynb:581
msgid "Et voilà, we have our final circuit"
msgstr "I voilà, mamy nasz ostatni obwód"

#: ../../tutorials/textbook/01_IQPE.ipynb:611
msgid "Let's execute the circuit with the ``qasm_simulator``, the simulator without noise that run locally."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:641
msgid "In the picture we have the same histograms but on the left we have on the x-axis the string with phase bits :math:`\\varphi_1`, :math:`\\varphi_2` and on the right the actual phase :math:`\\varphi` in decimal representation."
msgstr "Na obrazku mamy te same histogramy, ale po lewej stronie na osi x mamy ciąg znaków z bitami fazy :math:`\\varphi_1`, :math:`\\varphi_2` i po prawej stronie rzeczywisty etap :math:`\\varphi` w postaci dziesiętnej."

#: ../../tutorials/textbook/01_IQPE.ipynb:643
msgid "As we expected we have found :math:`\\varphi=\\frac{1}{4}=0.25` with a :math:`100\\%` probability."
msgstr "Jak się spodziewaliśmy znaleźliśmy :math:`\\varphi=\\frac{1}{4}=0.25` z prawdopodobieństwem :math:`100\\%`."

#: ../../tutorials/textbook/01_IQPE.ipynb:655
msgid "IPE example with a 2-qubit gate"
msgstr "Przykład IPE z dwukubitową bramą"

#: ../../tutorials/textbook/01_IQPE.ipynb:657
msgid "Now, we want to apply the IPE algorithm to estimate the phase for a 2-qubit gate :math:`U`. For this example, let's consider the controlled version of the :math:`T` gate, i.e. the gate :math:`U=\\textrm{Controlled-}T` (that from now we will express more compactly with :math:`CT`). Its matrix is"
msgstr "Teraz chcemy zastosować algorytm IPE, aby oszacować fazę dla dwukubitowej bramy :math:`U`. Dla tego przykładu rozważmy kontrolowaną wersję bramki `T` :math:, tzn. bramę :math:`U=\\tekstrm{Controlled-}T` (od teraz będziemy nazywać ją :math:`CT`). Jej macierz to"

#: ../../tutorials/textbook/01_IQPE.ipynb:659
msgid " CT =\n"
"\\begin{bmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^\\frac{i\\pi}{4}\\\\\n"
"\\end{bmatrix}"
msgstr " CT =\n"
"\\begin{bmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^\\frac{i\\pi}{4}\\\\\n"
"\\end{bmatrix}"

#: ../../tutorials/textbook/01_IQPE.ipynb:669
msgid "That is, the :math:`CT` gate adds a phase :math:`\\pi/4` to the state :math:`|11\\rangle`, leaving unchanged the phase of the other computational basis states :math:`|00\\rangle`, :math:`|01\\rangle`, :math:`|10\\rangle`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:671
msgid "Let's consider to estimate the phase :math:`\\phi=\\pi/4` for the eigenstate :math:`|11\\rangle`, we should find :math:`\\varphi=1/8`, since :math:`\\phi = 2 \\pi \\varphi`. Therefore to estimate the phase we need exactly 3 classical bits, i.e. :math:`m=3`, since :math:`1/2^3=1/8`. So :math:`\\varphi=0.\\varphi_1\\varphi_2\\varphi_3`."
msgstr "Rozważmy oszacowanie fazy :math:`\\phi=\\pi/4` dla kąta ostrości :math:`|11\\rangle`, powinniśmy znaleźć :math:`\\varphi=1/8` (gdzie :math:`\\phi = 2 \\pi \\varphi`). Dlatego, aby oszacować fazę, potrzebujemy dokładnie 3 klasycznych bitów, tj. :math:`m=3` (gdzie :math:`1/2^3=1/8`). Zatem :math:`\\varphi=0.\\varphi_1\\varphi_2\\varphi_3`."

#: ../../tutorials/textbook/01_IQPE.ipynb:673
msgid "As done with the example for the 1-qubit :math:`U` operator we will go through the same steps but this time we will have :math:`3` steps since :math:`m=3`, and we will not repeat all the explanations. So for details see the above example for 1-qubit :math:`U` gate."
msgstr "Tak jak zrobiono za pomocą przykładu operatora `U` 1-qubit :math:, przeprowadzimy te same kroki, ale tym razem będziemy mieć :math:`3`, gdzie :math:`m=3`, i nie będziemy już powtarzać wszystkich wyjaśnień. Więc aby uzyskać więcej informacji, zobacz powyższy przykład bramki jednokubitowej :math:`U`."

#: ../../tutorials/textbook/01_IQPE.ipynb:675
msgid "First, we initialize the circuit with 3 qubits, 1 for the auxiliary qubit and 2 for the 2-qubit gate, and 3 classical bits to store the phase bits :math:`\\varphi_1`, :math:`\\varphi_2`, :math:`\\varphi_3`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:704
msgid "Now we build the quantum circuit for the first step, to estimate the least significant phase bit :math:`\\varphi_m=\\varphi_3`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:709
msgid "We initialize the auxiliary qubit and the other qubits with the eigenstate :math:`|11\\rangle`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:744
msgid "Then we have to apply multiple times the :math:`CU` operator, that, in this example, is the Controlled-:math:`CT` gate (:math:`CCT` for short)."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:746
msgid "To implement :math:`CCT` in the circuit, since :math:`T` is a phase gate, we can use the multi-controlled phase gate :math:`\\text{MCP}(\\theta)`, with :math:`\\theta=\\pi/4`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:778
msgid "Let's apply :math:`2^t` times :math:`\\text{MCP}(\\pi/4)`. Since for the first step :math:`t=m-1` and :math:`m=3`, we have :math:`2^t=4`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:813
msgid "Finally, we perform the measurement of the auxiliary qubit in x-basis. We can use the ``x_measurement`` function defined above in the example for 1-qubit gate. In this way we have obtained the phase bit :math:`\\varphi_3` and stored it in the classical bit :math:`c_0`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:845
msgid "Subsequent steps (2nd, 3rd)"
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:847
msgid "Now we build the quantum circuit for the other remaining steps, the second and the third ones. As said in the first example, in these steps we have the additional sub-step of the phase correction."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:885
msgid "In order to extract the phase bit :math:`\\varphi_{2}`, we perform a phase correction of :math:`-\\pi\\varphi_3/2`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:887
msgid "So, after the reset we apply the phase gate :math:`P(\\theta)` with phase :math:`\\theta=-\\pi/2` conditioned by the classical bit :math:`c_0` (:math:`=\\varphi_3`)."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:921
msgid "We apply the :math:`CU` operations as we did in the first step. For the second step we have :math:`t=m-2`, hence :math:`2^t=2`. So we apply :math:`\\text{MCP}(\\pi/4)` :math:`2` times. And then we perform the x-measurement of the qubit :math:`q_0`, storing the phase bit :math:`\\varphi_2` in the bit :math:`c_1`."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:955
msgid "All substeps of the 3rd step"
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:957
msgid "For the 3rd and last step, we perform the reset and initialization of the auxiliary qubit as done in the second step."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:959
msgid "Then at the 3rd step we have to perform the phase correction of :math:`-2\\pi 0.0\\varphi_{2}\\varphi_{3}= -2\\pi \\left(\\frac{\\varphi_2}{4}+\\frac{\\varphi_3}{8}\\right)=-\\frac{\\varphi_2\\pi}{2}-\\frac{ \\varphi_3\\pi}{4}`, thus we have to apply 2 conditioned phase corrections, one conditioned by :math:`\\varphi_3` (:math:`=c_0`) and the other by :math:`\\varphi_2`\\ (:math:`=c_1`). To do this we have to apply the following: - gate :math:`P(-\\pi/4)` conditioned by :math:`c_0=1`, that is, by :math:`c=001` (c_if with value :math:`1`) - gate :math:`P(-\\pi/2)` conditioned by :math:`c_1=1`, that is, the gate is applied when :math:`c=010` (c_if with values :math:`2`) - gate :math:`P(-3\\pi/4)` conditioned by :math:`c_1=1` and :math:`c_0=1` that is, the gate is applied when :math:`c=011` (c_if with values :math:`3`)"
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:962
msgid "Next, the :math:`CU` operations: we apply :math:`2^t` times the :math:`\\text{MCP}(\\pi/4)` gate and since at the 3rd step :math:`t=m-3=0`, we apply the gate only once."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:1010
msgid "Now, we execute the circuit with the simulator without noise."
msgstr ""

#: ../../tutorials/textbook/01_IQPE.ipynb:1040
msgid "We have obtained :math:`100\\%` probability to find :math:`\\varphi=0.125`, that is, :math:`1/8`, as expected."
msgstr ""


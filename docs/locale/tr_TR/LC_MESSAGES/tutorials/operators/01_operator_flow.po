msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-28 17:09+0000\n"
"PO-Revision-Date: 2021-07-04 14:30\n"
"Last-Translator: \n"
"Language-Team: Turkish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: tr\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"
"Language: tr_TR\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "Bu sayfa `tutorials/operators/01_operator_flow.ipynb`__. tarafından oluşturulmuştur."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "Operatör akışı"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "Giriş"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit durum, operatör ve toplamalar, tensör ürünleri ve oluşturmaları açıklayan dersler veriyor. Bu cebirsel oluşmaları operatörleri temsil eden ifadeleri oluşturmamıza izin veriyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Biz bu ifadeleri Pauli operatörlerinden oluşturarak girdiriyoruz. Sonraki bölümlerde biz operatörleri ile durumları, onların nasıl temsil edildiği ve onlarla ne yapabileceğimiz gibi daha detaylı bir araştırma yapacağız. Son bölümde ise biz bir durumu oluşturuyoruz, bir Hamiltonian ile evrimleştiriyoruz, ve bir gözlemlenenin beklenti değerlerini hesaplıyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Pauli operatörleri, toplamalar, oluşturmalar, ve tensör ürünleri"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "En önemli temel operatörler Pauli operatörleridir. Pauli operatörleri bu şekilde temsil edilir."

#: ../../tutorials/operators/01_operator_flow.ipynb:71
msgid "These operators may also carry a coefficient."
msgstr "Bu operatörler ayrıca bir katsayı taşıyabilir."

#: ../../tutorials/operators/01_operator_flow.ipynb:114
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "Bu katsayıları, operatörlerin bir toplamada terim olarak kullanılmasına izin veriyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:156
msgid "Tensor products are denoted with a caret, like this."
msgstr "Tensör ürünleri gösterilen şapka simgesi ile belirtiliyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:196
msgid "Composition is denoted by the ``@`` symbol."
msgstr "Oluşturmalar ``@`` simgesi ile belirtiliyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:236
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "Önceki iki örnekteki tensör çarpımı ve Pauli operatörlerinin bileşimi bir anda (büyük ihtimalle çok-kübitli) eşdeğer olan Pauli operatörüne indirgendi. Eğer biz daha karmaşık nesneler tensörleştirir veya birleştirirsek, sonuç, değerlendirilmemiş işlemleri temsil eden nesneler olacaktır. Bu da, cebir ifadelerdir."

#: ../../tutorials/operators/01_operator_flow.ipynb:247
msgid "For example, composing two sums gives"
msgstr "Örneğin, iki toplama kompoze etmek bize aşağıdaki sonucu veriyor"

#: ../../tutorials/operators/01_operator_flow.ipynb:293
msgid "And tensoring two sums gives"
msgstr "Tensör etmemiz ise"

#: ../../tutorials/operators/01_operator_flow.ipynb:339
msgid "Let’s take a closer look at the types introduced above. First the Pauli operators."
msgstr "Yukarda gösterilen türlerine yakından bakalım. Evvela Pauli operatörleri."

#: ../../tutorials/operators/01_operator_flow.ipynb:380
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "Her Pauli operatörü, ``qiskit.quantum_info.Pauli``nın bir örneğini saran, ve bir ``coeff`` katsayısını ekleyen bir ``PauliOp`` nın örneğidir. Genel olarak, bir ``PauliOp`` Pauli operatörlerinin ağırlıklı tensör ürününü temsil ediyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:421
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Pauli operatörlerinin Boolean değerleri olarak kodlanmaları için ``qiskit.quantum_info.Pauli`` belgelerine bakınız."

#: ../../tutorials/operators/01_operator_flow.ipynb:423
msgid "All of the objects representing operators, whether as “primitive”s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr "Operatör temsil eden her nesne, ister ``PauliOp`` gibi temel olsun, veya cebirsel bir ifade olsun, bir katsayı taşıyor"

#: ../../tutorials/operators/01_operator_flow.ipynb:469
msgid "In the following we take a broader and deeper look at Qiskit’s operators, states, and the building blocks of quantum algorithms."
msgstr "Aşağıda Qiskit operatörlerine, durumlarına, ve kuantum algoritmalarının yapı temellerine daha geniş ve derin bir bakış atıyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:481
msgid "Part I: State Functions and Measurements"
msgstr "Bölüm 1: Durum fonksiyonları ve ölçmeler"

#: ../../tutorials/operators/01_operator_flow.ipynb:483
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "Kuantum durumları ``StateFn`` sınıfın alt sınıflarıyla temsil ediliyor. Kuantum durumların dört temsili var: ``DictStateFn`` bir \"dikt\" ile desteklenen, hesaplama temelinde seyrek bir temsildir. ``VectorStateFn`` numpy'in bir dizi tarafından desteklenen hesaplama temelinde yoğun bir temsildir. ``CircuitStateFn`` bir devre tarafından desteklenir ve devrenin tamamen sıfır hesaplama tabanlı durumda yürütülmesiyle elde edilen durumu temsil eder. ``OperatorStateFn`` yoğun matris aracıyla karışık durumları temsil eder. (İlerde göreceğimiz üzere ``OperatorStateFn`` gözlemlenebilirleri de temsil edebilir.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:486
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "Kolaylık için birkaç ``StateFn`` örnekleri sağlanacak. Örneğin \"Sıfır, bir, artı, eksi\"."

#: ../../tutorials/operators/01_operator_flow.ipynb:508
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "\"Sıfır\" ile \"Bir\" :math:`|0\\rangle` ile :math:`|1\\rangle` kuantum durumlarını temsil ediyor. ``DictStateFn`` yoluyla temsil edilirler."

#: ../../tutorials/operators/01_operator_flow.ipynb:548
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr "\"Artı\" ile \"Minus\", :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` ve :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` temsil ederek devrelerin tarafından temsil edilir. ``H``, ``Plus`` bir eş anlamlısıdır."

#: ../../tutorials/operators/01_operator_flow.ipynb:604
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "Kuantum durumlarını endekslenmeleri ``eval`` yöntemi ile yapılıyor. Bu örnekler ``0`` ve ``1`` temel durumlarının katsayılarını geri döndürüyor. (Aşağıda, ``eval`` yöntemi başka hesaplamalarında da kullanıldığını göreceğiz.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:656
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "Bir kuantum durumunun ikili vektörü, bu da bir *ket*e ait olan bir *bra*, ``adjoint`` yöntemiyle elde edilebilir. ``StateFn`` bir ``is_measurement`` bayrak taşıyor ki eğer nesne bir ket olsa ``False``, bir bra olsa ``True`` gösterir."

#: ../../tutorials/operators/01_operator_flow.ipynb:667
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "Burada, :math:`\\langle 1 |`. oluşturuyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:708
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "Kolaylık olsun için, aşağıda gösterildiği gibi ikili vektörünü elde edebilir"

#: ../../tutorials/operators/01_operator_flow.ipynb:750
msgid "Algebraic operations and predicates"
msgstr "Cebirsel hesaplamaları ve tahminler"

#: ../../tutorials/operators/01_operator_flow.ipynb:752
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including: \\* ``+`` - addition \\* ``-`` - subtraction, negation (scalar multiplication by -1) \\* ``*`` - scalar multiplication \\* ``/`` - scalar division \\* ``@`` - composition \\* ``^`` - tensor product or tensor power (tensor with self n times) \\* ``**`` - composition power (compose with self n times) \\* ``==`` - equality \\* ``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "Birçok cebirsel hesaplamaları ve tahminler ``StateFn``\\ s arasında desteklenmektedir, \\* ``+`` - addition \\* ``-`` - subtraction, negation (scalar multiplication by -1) \\* ``*`` - scalar multiplication \\* ``/`` - scalar division \\* ``@`` - composition \\* ``^`` - tensor product or tensor power (tensor with self n times) \\* ``**`` - composition power (compose with self n times) \\* ``==`` - equality \\* ``~`` - adjoint, durum fonksiyonu ve ölçmeleri ile birbirini değiştirerek"

#: ../../tutorials/operators/01_operator_flow.ipynb:754
msgid "Be aware that parentheses are often necessary to override **operator precedence**."
msgstr "**operator precedence**yi geçersiz kılmak için genellikle parantezlerin gerekli olduğunu unutmayın."

#: ../../tutorials/operators/01_operator_flow.ipynb:765
msgid "``StateFn``\\ s carry a coefficient. This allows us multiply states by a scalar, and so to construct sums."
msgstr "``StateFn``\\ s bir katsayıyı taşımaktadır. Bu da bize bir skaler ile durumları çarpmamıza, ve bu takdirde toplamalar oluşturmaya izin veriyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:776
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "Burada, :math:`(2 + 3i)|0\\rangle` oluşturuyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:817
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "Burada, iki ``DictStateFn``\\ s toplayarak aynı türünden olan bir nesneyi geri verdiğini görüyoruz. Biz :math:`|0\\rangle + |1\\rangle` oluşturuyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "Durumları elle normalleştirmen gerektiğine dikkat et. Örneğin, :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` oluşturmak için biz şöyle yazıyoruz"

#: ../../tutorials/operators/01_operator_flow.ipynb:900
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "Başka durumlarda, sonuç bir toplamanın sembolik temsilidir. Mesela, burada :math:`|+\\rangle + |-\\rangle` nın bir temsili var."

#: ../../tutorials/operators/01_operator_flow.ipynb:962
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "Kompozisyon operatörü, varsayılan olarak değerlendirilmemiş bir biçimde tutulan bir iç çarpımı gerçekleştirmek için kullanılır. Burada bir :math:`\\langle 1 | 1 \\rangle` temsili gösteriyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:1008
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "``is_measurement`` bayrağının bra durumu ``~One`` nın ``DictMeasurement`` olarak basılmasının sebep olduğuna dikkat et."

#: ../../tutorials/operators/01_operator_flow.ipynb:1019
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "Sembolik ifadeler ``eval`` yöntemiyle değerlendirilebilirler."

#: ../../tutorials/operators/01_operator_flow.ipynb:1090
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "İşte :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1131
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "``@`` kompozisyon operatörü ``compose`` yöntemi eşdeğerdir."

#: ../../tutorials/operators/01_operator_flow.ipynb:1177
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "İç çarpımlar, ``ComposedOp`` oluşturmadan direkt ``eval`` yöntemini kullanarak hesaplanabilirler."

#: ../../tutorials/operators/01_operator_flow.ipynb:1218
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "Sembolik tensör ürünü gösterilecek şekli üzere oluşturulur. İşte :math:`|0\\rangle \\otimes |+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1272
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "Bu da, (bileşik olmayan) basit bir ``CircuitStateFn`` olarak temsil edilebilir."

#: ../../tutorials/operators/01_operator_flow.ipynb:1324
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "Tensör kuvvetleri gösterilecek şekli üzerinde ``^`` şapka simgesini kullanarak oluşturulurlar. Burada :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1367
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "``to_matrix_op`` yöntemi ``to_matrix_op`` ya dönüşür."

#: ../../tutorials/operators/01_operator_flow.ipynb:1445
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "Bir StateFn oluşturmak kolaydır. ``StateFn`` sınıfı da fabrika gibi hizmet eder, yapıcısındaki herhangi bir uygulanabilir ilkeli alabilir ve doğru StateFn alt sınıfını döndürebilir. Şimdi, aşağıdaki ilkeliler yapıcısına geçirilebilir, ``StateFn``alt sınıfının yanında listelendiği zaman bunu oluşturuyor:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1447
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (equal to some basis bitstring) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1448
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1449
msgid "Qiskit Result object -> DictStateFn"
msgstr "Qiskit Result object -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1450
msgid "list -> VectorStateFn"
msgstr "list -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1451
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1452
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1453
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1454
msgid "Instruction -> CircuitStateFn"
msgstr "Instruction -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1455
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase -> OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "Bölüm II: ``PrimitiveOp``\\ s"

#: ../../tutorials/operators/01_operator_flow.ipynb:1524
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "Temel operatörler ``PrimitiveOp`` 'ın alt sınıflarırdır. ``StateFn`` gibi, verilen bir ilkele doğru ``PrimitiveOp`` türünü oluşturmak için ``PrimitiveOp`` da bir fabrikadır. Şimdi, aşağıdaki ilkeleri, oluşturdukları ``PrimitiveOp`` altsınıflarının yanında listelenmiş olarak oluşturucudan geçirebilir:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1526
msgid "Terra’s Pauli -> PauliOp"
msgstr "Terra’s Pauli -> PauliOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1527
msgid "Instruction -> CircuitOp"
msgstr "Instruction -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1528
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1529
msgid "2d List -> MatrixOp"
msgstr "2d List -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1530
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1531
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1532
msgid "Terra’s quantum_info.Operator -> MatrixOp"
msgstr "Terra’s quantum_info.Operator -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1554
msgid "Matrix elements"
msgstr "Matris öğeleri"

#: ../../tutorials/operators/01_operator_flow.ipynb:1565
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "``eval`` yöntemi bir sütünü bir operatörden geri getirir. örneğin, Pauli :math:`X` operatörü ``PauliOp`` ile temsil edilir. Bir sütünü istemek seyrek gösterimin bir örneğini, bir ``DictStateFn`` döndürür."

#: ../../tutorials/operators/01_operator_flow.ipynb:1635
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "Bir matris elde etmekle, ``eval`` yöntemine iki çağrı yaparak bir operatöre indekslemeyi takip eder."

#: ../../tutorials/operators/01_operator_flow.ipynb:1646
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "Biz de :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)` var. Matrisin öğesi de :math:`\\left\\{X \\right\\}_{0,1}` dır"

#: ../../tutorials/operators/01_operator_flow.ipynb:1687
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "Burada, bir devrede temsil edilen \"kontrollü X\" diye adlandırılan iki kübit operatörü ``CX`` kullandıldığı bir örnektir."

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "Applying an operator to a state vector"
msgstr "Bir durum vektörüne bir operatör uygulama"

#: ../../tutorials/operators/01_operator_flow.ipynb:1818
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "Bir durum vektörüne bir operatörün uygulanmasıyla (equivalently, ``@`` operator) ``compose`` yöntemiyle yapılabilir. Burada :math:`X | 1 \\rangle = |0\\rangle` temsili gösteriliyor."

#: ../../tutorials/operators/01_operator_flow.ipynb:1864
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "Daha basit bir temsil olan :math:`|0\\rangle` temsili ``DictStateFn`` ``eval`` yöntemiyle elde edilebilir."

#: ../../tutorials/operators/01_operator_flow.ipynb:1905
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "Direkt olarak ``eval``ı kullanarak ``ComposedOp`` orta düzey adımını önleyebiliriz."

#: ../../tutorials/operators/01_operator_flow.ipynb:1946
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "Operatörlerin bileşim ve tensör çarpımları ``@`` ve ``^` ile etkilenir. İşte bazı örnekler."

#: ../../tutorials/operators/01_operator_flow.ipynb:2100
msgid "Part III ``ListOp`` and subclasses"
msgstr "Bölüm III ``ListOp`` ve alt sınıflar"

#: ../../tutorials/operators/01_operator_flow.ipynb:2112
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2114
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp``, operatörlerin ve durumların listesinin üzerinde etkili vektörleştirme hesaplamarı için bir kapsayıcıdır."

#: ../../tutorials/operators/01_operator_flow.ipynb:2174
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "Örneğin yukardaki bileşim, basitleştirme yöntemi olan ``reduce`` u kullanarak (``ListOp``) listelerinin üzerinde dağıtılmıştır."

#: ../../tutorials/operators/01_operator_flow.ipynb:2257
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2259
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you’ve already played around with the above, you’ll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven’t implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you’ll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr "Yukarda tanıtılan ``ListOp``, hesapları vektörleştimek için kullanışlıdır, lakin liste-benzeri bileşik sınıflar için onların üst sınıfı olarak da işe yarar. Eğer yukardakini biraz denediysen belki genelde en etkili şekilde kullanışını bilmediğimiz (veya kendisi için daha etkili bir prosedür henüz bulamadığımız) ``CircuitOp``\\ s toplaması gibi, ``OperatorBase``\\ s ile kolayca hesaplamalar yapıldığını fark etmiş olacaksın. Bu durumda sen, operasyonunun tembelce yürütülmesini temsil eden operasyonundan gelen bir ``ListOp`` sonucunu (veya onun alt sınıflarından birini) alacaksın. Örnek olarak, eğer sen ``DictStateFn`` ile ``CircuitStateFn``birleştirmek istersen, ikisinin toplamasını elde edeceksin. Bu bileşik durumun fonksiyonu hâlâ çalışan bir ``eval``e sahiptir (ancak her ikisini de vektöre dönüştürmek gibi ölçeklendirilemeyen bir hesaplama gerçekleştirmesi gerekebilir)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2262
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "Bu ``OperatorBase``\\ s bileşiği ile``PrimitiveOp`` and ``StateFn`` yapı bloklarının dışında daha karmaşık ve zengin hesaplamalar yapıyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:2264
msgid "Every ``ListOp`` has four properties: \\* ``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc. \\* ``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays. \\* ``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``. \\* ``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "Her ``ListOp`` dört tane özelliği var: \\* ``oplist`` - Terim, faktör, vs kavramlarını temsil eden ``OperatorBase``\\ s. \\* ``combo_fn`` -, karmaşık sayıların listesini alıp ``oplist`` öğelerinin çıktısını birleştirmesini tanımlayan bir çıktı değerine götüren fonksiyonu. Yayın basitliği için, bu fonksiyon Numpy dizileriyle tanımlanıyor. \\* ``coeff`` bir ilkeli çarpan katsayıdır. ``coeff`` nin tam sayı, ondalık sayı, karmaşık veya ``Parameter``siz ( Terra'daki ``qiskit.circuit`` 'ten) bir nesne olabilir ve daha sonra ``my_op.bind_parameters '' kullanılarak bağlanacak. \\* ``abelian`` - ise, ``oplist`` 'teki operatörlerin (genellikle `` AbelianGrouper '' dönüştürücü tarafından dönüştürüldükten sonra ayarlanmış olarak) birbiriyle komüte edip etmediğini gösterir."

#: ../../tutorials/operators/01_operator_flow.ipynb:2267
msgid "Note that ``ListOp`` supports typical iteration overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "``ListOp` 'nun tipik yineleme aşırı yüklemelerini desteklediğine fark et, o yüzden ``oplist`` 'te olan ``OperatorBase``\\ s 'e erişebilmek için ``my_op[4]`` gibi bir endeksleme kullanabilirsin."

#: ../../tutorials/operators/01_operator_flow.ipynb:2279
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2281
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "Yukarıda ``OperatorStateFn`` nun bir yoğunluk operatörünü temsil ettiğini söylemiştik. Ama eğer ``is_measurement`` bayrağı ``True`` ise, o zaman, ``OperatorStateFn`` gözlemlenebiliri temsil etmektedir. Bu gözlemlenebilirin beklenti değeri o takdirde, ``ComposedOp`` yoluyla veya ``eval`` 'ı doğru doğruya kullanarak oluşturulabilir. ``is_measurement`` bayrağını (özelliğini) ``adjoint`` yöntemiyle kurulduğunu hatırla."

#: ../../tutorials/operators/01_operator_flow.ipynb:2292
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "Burada Pauli :math:`Z` operatörüne ait bir gözlemlenebiliri oluşturuyoruz. Onu görüntülediğimizde ``OperatorMeasurement`` diye adlandırıldığına fark et."

#: ../../tutorials/operators/01_operator_flow.ipynb:2354
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "Burada biz :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}` olduğu yerde, :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle` ve :math:`\\langle + | Z | + \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2401
msgid "Part IV: Converters"
msgstr "Bölüm IV: Dönüştürücüler"

#: ../../tutorials/operators/01_operator_flow.ipynb:2403
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter’s ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr "Dönüştürücüler, operatörleri ve durumları manipüle eden, algoritmaların inşa bloklarını çalıştıran sınıflardır. Bazı örnekler operatörlerin bazlarını ve trotterizasyonun değiştirmesini içeriyor. Dönüştürücüler bir ifadeyi geçirir ve ``convert()`` dönüştürücü yöntemiyle tanımlanan içindeki operatörlerine belirli bir manipülasyonu ve yer değiştirmeyi gerçekleştirir. Normalde, eğer bir dönüştürücü, özyinelemede dönüştürme amacı ile ilgisi olmayan bir ``OperatorBase`` ile karşılaşırsa, o ``OperatorBase`` değiştirilmez."

#: ../../tutorials/operators/01_operator_flow.ipynb:2428
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "Evrimler, ``exp_i()`` ve ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2430
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can’t perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr "Her ``PrimitiveOp`` ve ``ListOp`` :math:`e^{-iH}` ye ait olan ``H.exp_i()`` bir ``.exp_i()`` fonksiyonuna sahiptir. Uygulamada, bu operatörlerden sadece birkaçı (MatrixOp ve tek bir birim-olmayan tek kübitli Pauli ile PauliOps gibi) verimli bir şekilde hesaplanabilir üs alma özelliğine sahiptir; Bu nedenle bir yer tutucuyu veya (``SummedOp`` toplama yapamadığımız zamanlarda bir yer tutucu olduğu gibi) bir simgesel temsilini geri almak gerekir. Bu yer tutucu ``EvolvedOp`` diye adlandırılır ve ``.primitive`` özelliğinde üslenecek olan ``OperatorBase`` tutarını tutar."

#: ../../tutorials/operators/01_operator_flow.ipynb:2433
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there’s no “evolution time” argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr "Qiskit operatörleri parametrizasyonu tamamen destekliyor, bu yüzden buradaki zaman evrimiz için bir ``Parameter`` kullanabiliriz. Hiç bir fonksiyonda \"zaman evrimi\" argüman olmadığına fark et. Operatör akışı, hangi operatörün üslemesini söylüyorsak üsluyor, ve operatörü bir :math:`e^{-iHt}` zaman evrimi ile çarpmak istiyorsak, üs alma parametrelerimize yansıtılacaktır."

#: ../../tutorials/operators/01_operator_flow.ipynb:2445
msgid "Weighted sum of Pauli operators"
msgstr "Pauli operatörlerinin ağırlıklı toplamı"

#: ../../tutorials/operators/01_operator_flow.ipynb:2447
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "Bir çoklu kübit Pauli operatörlerinin bir lineer kombinasyon olarak ifade edilen bir Hamiltonian'ı bu şekilde oluşturulabilir."

#: ../../tutorials/operators/01_operator_flow.ipynb:2472
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "``two_qubit_H2`` nın kendi terimleri ``PauliOp``\\ s olan ``SummedOp`` olarak temsil edildiğine fark et."

#: ../../tutorials/operators/01_operator_flow.ipynb:2520
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "Sonra, Hamiltonian'ı ``Parameter`` ile çarpıyoruz. Bu ``Parameter`` ``SummedOp`` 'nun ``coeff`` özelliğinde saklanıyor. Sonuçlarda ``exp_i()`` çalıştırarak üslenmeyi temsil eden `` EvolvedOp '' ile sarılır."

#: ../../tutorials/operators/01_operator_flow.ipynb:2589
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "Bir gözlemlenebilir olarak ``two_qubit_H2`` temsil eden, biz ``h2_measurement``oluşturuyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:2638
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr ":math:`\\text{CX} (H\\otimes I) |00\\rangle`. yoluyla bir :math:`|\\Phi_+\\rangle` Bell durumunu oluşturuyoruz."

#: ../../tutorials/operators/01_operator_flow.ipynb:2691
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "İfade şu şekildedir: :math:`H e^{-iHt} |\\Phi_+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2772
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "Normalde, biz iki kübitli kapıları kullanarak :math:`e^{-iHt}` 'ı yaklaştırmak istiyoruz. Bunu bulunan bütün ``EvolvedOp``\\ lere trotterizasyonu uygulayarak ifadeleri geçiren ``PauliTrotterEvolution``'nun ``convert`` yöntemiyle elde ediyoruz. buna rağmen biz burada ``PauliTrotterEvolution`` kullanıyoruz, başka seçenekler de var, üs almayı tam olarak gerçekleştiren``MatrixEvolution`` gibi."

#: ../../tutorials/operators/01_operator_flow.ipynb:2862
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` bir ``Parameter`` 'i içerir. ``bind_parameters`` yöntemi belli bir `dict`` yoluya ifade bağlama değerlerini parametre adlarına geçirir. Bu durumda, tek bir parametre vardır."

#: ../../tutorials/operators/01_operator_flow.ipynb:2883
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let’s draw it to verify that the binding has taken place."
msgstr "``bound`` bir ``ComposedOp``'tur. Devrenin ikinci faktörüdür. Bağlanma gerçekleştiğini kanıtlamak için onu çizelim."

#: ../../tutorials/operators/01_operator_flow.ipynb:2998
msgid "Expectations"
msgstr "Beklentiler"

#: ../../tutorials/operators/01_operator_flow.ipynb:3000
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "``Expectation``\\ lar gözlemlenebilirlerin beklenti değerlerini hesaplamalarını etkinleştiren dönüştürücülerdir. Bunlar ``OperatorStateFn``\\ (gözlemlenebilirler) 'i kuantum veya klasik donanım üzerinde hesaplamaya daha uygun olan eşdeğer hesaplamalarla değiştirerek bir Operatör ağacını geçerler. Örneğin, Bir fonksiyonun durumuna bağlı olarak Pauli operatörlerinin toplanmalarıyla ifade edilen bir ``o`` operatörünün beklenti değerini hesaplamak istiyorsak, ama yalnızca kuantum donanımın üzerindeki çapraz hesaplamalarına erişebilirsek, bir ``~StateFn(o)`` gözlemlenebiliri oluşturup ve onu çapraz bir hesaplamaya ve duruma eklemek devrenin ön rotasyonlarına dönüştürmek için ``PauliExpectation``'u kullanabiliriz."

#: ../../tutorials/operators/01_operator_flow.ipynb:3003
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "Başka ilginç ``Expectation`` bir gözlemlenebiliri ``Aer``in yüksek performansla yerel olarak yürütebileceği özel bir beklenti anlık talimatını içeren ``CircuitStateFn``'e dönüştüren ``AerPauliExpectation``'dır."

#: ../../tutorials/operators/01_operator_flow.ipynb:3094
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "``SummedOp``u karşılıklı olarak kübit-bilge iletişim Pauli gruplarına dönüştürmek için ``AbelianGrouper``ı kullanacak olan varsayılan ``group_paulis=True``. Bu, her grup aynı devre uygulamasını paylaşabildiğinden, devre yürütme ek yükünü azaltır."

#: ../../tutorials/operators/01_operator_flow.ipynb:3166
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "Dönüştürücülerin özyineleme olarak çalıştığını fark et, bu da, onlar bir ifadeyi onun eylemini alıp sadece mümkün olduğu yerlerde uygulayarak geçirir. Böylece bizim tam evrim ve ölçüm ifademizi dönüştürebiliriz. Dönüştürülmüş ``h2_measurement`` yi evrimimiz ``CircuitStateFn`` ile eşdeğer olarak oluşturabilirdik. Biz ifadenin tamamına bu dönüşümü uygulamaya geçeriz."

#: ../../tutorials/operators/01_operator_flow.ipynb:3299
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "Şimdi biz, birden fazla parametre değerini bir ``ListOp`` içine bağlarız ve ardından tüm ifadeyi değerlendirmek için ``eval``ile devam ederiz. Eğer biz önce bağlasaydık ``eval`` ı kullanabilirdik ama verimli olmazdı. Burada ``eval`` bizim ``CircuitStateFn``\\ 'lerimizi iç bir simülasyondan geçirerek ``VectorStateFn``\\ 'lere dönüştürecektir."

#: ../../tutorials/operators/01_operator_flow.ipynb:3321
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "Farklı parametrenin farklı değerlerine ait olan beklenti değerleri :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` buradadır."

#: ../../tutorials/operators/01_operator_flow.ipynb:3367
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "``CircuitSampler`` i ``CircuitStateFn``\\ ler ile çalıştırmak"

#: ../../tutorials/operators/01_operator_flow.ipynb:3369
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFns`` into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule.)"
msgstr "``CircuitSampler`` bir operatörü geçirir ve herhangi bir ``CircuitStateFns`` bir kuantum arka ucunu kullanarak ``DictStateFn`` veya ``VectorStateFn`` ile elde edilen durum fonksiyonunun yaklaşık değerlerine dönüştürür. ``CircuitStateFn``nın 1) durum fonksiyonunu, tüm faz bilgilerini yok edecek bir depolarize edici kanal aracılığıyla göndermek ve 2) örneklenen frekansları, ham örnekleme olasılığı yerine (ki, bu da, Born yasasına göre durum fonksiyonunun **square** örneklemeye eşdeğer olacaktı) frekansın **square roots ** ile değiştirmek zorunda olduğunu fark et"

#: ../../tutorials/operators/01_operator_flow.ipynb:3418
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "Tekrar devrelerin, devre örnekleme olasılıklarının ** square roots ** olan dikteler ile değiştirildiğine fark et. Dönüşümden önce ve sonra bir alt ifadeye bak:"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-02 21:04+0000\n"
"PO-Revision-Date: 2023-03-02 21:46\n"
"Last-Translator: \n"
"Language: fr\n"
"Language-Team: French\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: fr\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "Cette page a été générée à partir de `tutorials/operators/01_operator_flow.ipynb`__."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "Flux d'opérateur"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "Introduction"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit fournit des classes représentant les états, les opérateurs, les combinaisons linéaires, les produits tensoriels et leurs compositions. Ces constructions algébriques nous permettent de construire des expressions représentant des opérateurs."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Nous introduisons des expressions en les construisant à partir des opérateurs de Pauli. Dans les sections suivantes, nous explorons plus en détail les opérateurs et les états, comment ils sont représentés et ce que nous pouvons faire avec eux. Dans la dernière section, nous construisons un état, le faisons évoluer avec un Hamiltonien, et calculons les valeurs d'espérance d'un observable."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Opérateurs de Pauli, sommes, compositions et produits tensoriels"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "Les opérateurs de base les plus importants sont les opérateurs Pauli. Les opérateurs Pauli sont représentés comme ceci."

#: ../../tutorials/operators/01_operator_flow.ipynb:76
msgid "These operators may also carry a coefficient."
msgstr "Ces opérateurs peuvent également porter un coefficient."

#: ../../tutorials/operators/01_operator_flow.ipynb:125
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "Ces coefficients permettent aux opérateurs d'être utilisés comme termes dans une somme."

#: ../../tutorials/operators/01_operator_flow.ipynb:173
msgid "Tensor products are denoted with a caret, like this."
msgstr "Les produits tensoriels sont signalés par un caret, comme celui-ci."

#: ../../tutorials/operators/01_operator_flow.ipynb:218
msgid "Composition is denoted by the ``@`` symbol."
msgstr "La composition est indiquée par le symbole ``@``."

#: ../../tutorials/operators/01_operator_flow.ipynb:263
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "Dans les deux exemples précédents, le produit tensoriel et la composition des opérateurs de Pauli ont été immédiatement réduits à l'opérateur de Pauli équivalent (éventuellement multiqubit). Si nous composons des objets plus complexes, le résultat sera un objet représentant le s opérations à évaluer. Il s'agit d'expressions algébriques."

#: ../../tutorials/operators/01_operator_flow.ipynb:274
msgid "For example, composing two sums gives"
msgstr "Par exemple, composer deux sommes donne"

#: ../../tutorials/operators/01_operator_flow.ipynb:328
msgid "And tensoring two sums gives"
msgstr "Et le produit tensoriel de deux sommes donne"

#: ../../tutorials/operators/01_operator_flow.ipynb:382
msgid "Let’s take a closer look at the types introduced above. First the Pauli operators."
msgstr "Examinons de plus près les types présentés ci-dessus. D'abord les opérateurs de Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:428
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "Chaque opérateur de Pauli est une instance de ``PauliOp``, qui enveloppe une instance de ``qiskit.quantum_info.Pauli``, et ajoute un coefficient ``coeff``. D'une manière générale, un `` PauliOp`` représente un produit tensoriel pondéré d'opérateurs de Pauli."

#: ../../tutorials/operators/01_operator_flow.ipynb:474
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Pour le codage des opérateurs Pauli en tant que paires de valeurs booléennes, consultez la documentation de ``qiskit.quantum_info.Pauli``."

#: ../../tutorials/operators/01_operator_flow.ipynb:476
msgid "All of the objects representing operators, whether as “primitive”s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr "Tous les objets représentant les opérateurs, qu'il s'agisse de \"primitives\" telles que ``PauliOp``, ou d'expressions algébriques ont un coefficient"

#: ../../tutorials/operators/01_operator_flow.ipynb:530
msgid "In the following we take a broader and deeper look at Qiskit’s operators, states, and the building blocks of quantum algorithms."
msgstr "Dans ce qui suit, nous avons un regard plus large et plus approfondi sur les opérateurs de Qiskit, les états et les blocs de construction des algorithmes quantiques."

#: ../../tutorials/operators/01_operator_flow.ipynb:542
msgid "Part I: State Functions and Measurements"
msgstr "Partie I: Fonctions et mesures"

#: ../../tutorials/operators/01_operator_flow.ipynb:544
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "Les états quantiques sont représentés par des sous-classes de la classe ``StateFn``. Il y a quatre représentations d'états quantiques: ``DictStateFn`` est une représentation éparse dans la base de calcul, s'appuyant sur un ``dict``. ``VectorStateFn`` est une représentation dense sur la base de calcul, et utilise un tableau numpy. ``CircuitStateFn`` est représenté par un circuit et désigne l'état obtenu en exécutant le circuit sur l'état ouù touls les qubits sont initialement à zéro dans la base de caclul. ``OperatorStateFn`` représente des états mixtes à l'aide d'une matrice de densité. (Comme nous le verrons plus loin, ``OperatorStateFn`` est également utilisé pour représenter des observables.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:547
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "Plusieurs instances ``StateFn`` sont fournies pour des raisons de commodité. Par exemple, ``Zero, One, Plus, Minus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:569
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "``Zéro`` et ``One`` représentent les états quantiques :math:`| 0\\rangle` et :math:`| 1\\rangle`. Ils sont représentés par ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:614
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr "``Plus`` et ``Minus``, représentant les états :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` et :math:`(|0\\rangle-|1\\rangle)/\\sqrt{2}` sont représentés par des circuits. ``H`` est un synonyme de ``Plus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:683
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "L'indexation dans les états quantiques se fait avec la méthode ``eval``. Ces exemples renvoient les coefficients des états de base ``0`` et ``1``. (Ci-dessous, nous verrons que la méthode ``eval`` est aussi utilisée pour d'autres calculs.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:744
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "Le vecteur dual d'un état quantique, c'est-à-dire le *bra* correspondant à un *ket* est obtenu via la méthode ``adjoint``. ``StateFn`` porte un drapeau ``is_measurement``, qui est à ``Flase`` si l'objet est un ket et ``True`` s'il s'agit d'un bra."

#: ../../tutorials/operators/01_operator_flow.ipynb:755
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "Ici, nous construisons :math:`\\langle 1 |`."

#: ../../tutorials/operators/01_operator_flow.ipynb:801
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "Pour des raisons de commodité, on peut obtenir le vecteur dual avec un tilde, comme celui-ci"

#: ../../tutorials/operators/01_operator_flow.ipynb:848
msgid "Algebraic operations and predicates"
msgstr "Opérations et prédicats algébriques"

#: ../../tutorials/operators/01_operator_flow.ipynb:850
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including:"
msgstr "De nombreuses opérations algébriques et prédicats entre les ``StateFn``\\ s sont pris en charge, notamment :"

#: ../../tutorials/operators/01_operator_flow.ipynb:852
msgid "``+`` - addition"
msgstr "``+`` - addition"

#: ../../tutorials/operators/01_operator_flow.ipynb:853
msgid "``-`` - subtraction, negation (scalar multiplication by -1)"
msgstr "``-`` - soutraction, négation (multiplication scalaire par -1)"

#: ../../tutorials/operators/01_operator_flow.ipynb:854
msgid "``*`` - scalar multiplication"
msgstr "``*``-multiplication scalaire"

#: ../../tutorials/operators/01_operator_flow.ipynb:855
msgid "``/`` - scalar division"
msgstr "``/`` division scalaire"

#: ../../tutorials/operators/01_operator_flow.ipynb:856
msgid "``@`` - composition"
msgstr "``@``-composition"

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "``^`` - tensor product or tensor power (tensor with self n times)"
msgstr "` ` ^ ``-produit tensoriel ou tenseur (tenseur n fois avec soi-même)"

#: ../../tutorials/operators/01_operator_flow.ipynb:858
msgid "``**`` - composition power (compose with self n times)"
msgstr "``**`` - puissance de composition (composition n fois de soi-même)"

#: ../../tutorials/operators/01_operator_flow.ipynb:859
msgid "``==`` - equality"
msgstr "``==`` - égalité"

#: ../../tutorials/operators/01_operator_flow.ipynb:860
msgid "``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "``~`` - adjoint, alternant entre une Fonction d'Etat et une Mesure"

#: ../../tutorials/operators/01_operator_flow.ipynb:862
msgid "Be very aware that these operators obey the `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, which might not be what you expect mathematically. For example, ``I^X + X^I`` will actually be parsed as ``I ^ (X + X) ^ I == 2 * (I^X^I)`` because Python evaluates ``+`` before ``^``. In these cases, you can use the methods (``.tensor()``, etc) or parentheses."
msgstr "Sachez que ces opérateurs obéissent aux `règles Python pour la priorité de l'opérateur <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, ce qui pourrait ne pas être ce que vous attendez mathématiquement. Par exemple, ``I^X + X^I`` sera en fait analysé comme ``I ^ (X + X) ^ I == 2 * (I^X^I)`` parce que Python évalue ``+`` avant ``^``. Dans ces cas, vous pouvez utiliser les méthodes (``.tensor()``, etc) ou les parenthèses."

#: ../../tutorials/operators/01_operator_flow.ipynb:873
msgid "``StateFn``\\ s carry a coefficient. This allows us to multiply states by a scalar, and so to construct sums."
msgstr "Les ``StateFn``\\ s portent un coefficient. Cela nous permet de multiplier les états par un scalaire, et donc de construire des sommes."

#: ../../tutorials/operators/01_operator_flow.ipynb:884
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "Ici, nous construisons :math:`(2 + 3i)|0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:930
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "Ici, nous voyons que l'ajout de deux ``DictStateFn`` \\ s renvoie un objet du même type. Nous construisons :math:` |0\\rangle + |1\\rangle `."

#: ../../tutorials/operators/01_operator_flow.ipynb:975
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "Notez que vous devez normaliser les états à la main. Par exemple, pour construire :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, nous écrivons"

#: ../../tutorials/operators/01_operator_flow.ipynb:1023
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "Dans d'autres cas, le résultat est une représentation symbolique d'une somme. Par exemple, voici une représentation de :math:`|+\\rangle + |-\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1101
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "L'opérateur de composition est utilisé pour effectuer un produit intérieur qui, par défaut, est détenu sous une forme non évaluée. Voici une représentation de :math:`\\langle 1 | 1 \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1155
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "Notez que l'indicateur ``is_measurement`` fait que l'état (bra) ``~ One`` doit être imprimé ``DictMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1166
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "Les expressions symboliques peuvent être évaluées avec la méthode ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1247
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "Ici est :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1293
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "L'opérateur de composition ``@`` est équivalent à l'appel de la méthode ``compose``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1347
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "Les produits internes peuvent également être calculés à l'aide de la méthode ``eval`` directement, sans construire de ``ComposedOp``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1393
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "Les produits tensoriels symboliques sont construits comme suit. Voici :math:`|0\\rangle \\otimes | + \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1459
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "Cela peut être représenté comme un ``CircuitStateFn`` simple (et non pas composé)."

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "Les puissances de Tensor sont construites à l'aide du caret ``^`` comme suit : :math:`600 (| 11111\\rangle + |00000\\rangle)`, et :math:`|10\\rangle^{\\otimes 3 }`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1571
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "La méthode ``to_matrix_op`` convertit en ``VectorStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1672
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "Construire un StateFn est facile. La classe ``StateFn`` sert également de fabrique, et peut prendre n'importe quelle primitive applicable dans son constructeur et retourner la sous-classe StateFn correcte. Actuellement, les primitives suivantes peuvent être transmises au constructeur, répertoriées pour la sous-classe ``StateFn`` ils produisent :"

#: ../../tutorials/operators/01_operator_flow.ipynb:1674
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (égal à une chaîne de bits de base) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1675
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1676
msgid "Qiskit Result object -> DictStateFn"
msgstr "Objet Résultat Qiskit-> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1677
msgid "list -> VectorStateFn"
msgstr "list -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1678
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1679
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1680
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1681
msgid "Instruction -> CircuitStateFn"
msgstr "Instruction -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1682
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase -> OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1764
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "Partie II: ``PrimitiveOp``\\ s"

#: ../../tutorials/operators/01_operator_flow.ipynb:1766
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "Les opérateurs de base sont des sous-classes de ``PrimitiveOp``. Tout comme ``StateFn``, ``PrimitiveOp`` est aussi un constructeur pour créer le type correct de ``PrimitiveOp`` pour une primitive donnée. Actuellement, les primitives suivantes peuvent être transmises au constructeur, répertoriées à côté de la sous-classe ``PrimitiveOp`` ils produisent :"

#: ../../tutorials/operators/01_operator_flow.ipynb:1768
msgid "Terra’s Pauli -> PauliOp"
msgstr "Terra's Pauli-> PauliOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1769
msgid "Instruction -> CircuitOp"
msgstr "Instruction -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1770
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1771
msgid "2d List -> MatrixOp"
msgstr "2d List -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1772
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1773
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1774
msgid "Terra’s quantum_info.Operator -> MatrixOp"
msgstr "Terra's quantum_info.Operator-> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1796
msgid "Matrix elements"
msgstr "Eléments de matrice"

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "La méthode ``eval`` renvoie une colonne d'un opérateur. Par exemple, l'opérateur Pauli :math:`X` est représenté par un ``PauliOp``. Le fait d'obtenir une colonne renvoie une instance de la représentation éparse, une ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1887
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "Il s'ensuit que l'indexation dans un opérateur, qui obtient un élément de matrice, est effectuée avec deux appels à la méthode ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1898
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "Nous avons :math:` X = \\left (\\begin{matrix} 0 & 1 \\\\ 1 & 0 \\end{matrix} \\right) `. Et l'élément de matrice :math:` \\left\\ { X \\right\\ } _{0,1}` est"

#: ../../tutorials/operators/01_operator_flow.ipynb:1944
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "Voici un exemple utilisant l'opérateur de deux qubits ``CX``, le ``X`` contrôlé, qui est représenté par un circuit."

#: ../../tutorials/operators/01_operator_flow.ipynb:2088
msgid "Applying an operator to a state vector"
msgstr "Application d'un opérateur à un vecteur d'état"

#: ../../tutorials/operators/01_operator_flow.ipynb:2099
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "L'application d'un opérateur à un vecteur d'état peut être effectuée avec la méthode ``compose`` (équivalence, ``@`` opérateur). Voici une représentation de :math:`X | 1 \\rangle = | 0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2153
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "Une représentation plus simple, la représentation ``DictStateFn`` de :math:`| 0\\rangle `, est obtenue avec ``eval``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2199
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "L'étape intermédiaire ``ComposedOp`` peut être évitée en utilisant ``eval`` directement."

#: ../../tutorials/operators/01_operator_flow.ipynb:2245
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "La composition et les produits tensoriels des opérateurs sont effectués avec ``@`` et ``^``. Voici quelques exemples."

#: ../../tutorials/operators/01_operator_flow.ipynb:2449
msgid "Part III: ``ListOp`` and subclasses"
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2461
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2463
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp`` est un conteneur pour des opérations de vectorisation efficace sur une liste d'opérateurs et d'états."

#: ../../tutorials/operators/01_operator_flow.ipynb:2537
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "Par exemple, la composition ci-dessus est distribuée sur les listes (``ListOp``) à l'aide de la méthode de simplification ``reduce``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2646
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2648
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you’ve already played around with the above, you’ll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven’t implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you’ll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr "``ListOp``, introduit ci-dessus, est utile pour les opérations de vectorisation. Mais il sert aussi de superclasse pour les classes composites de type liste. Si vous avez déjà joué avec ce qui précède, vous remarquerez que vous pouvez facilement effectuer des opérations entre les ``OperatorBase`` que nous ne savons peut-être pas comment effectuer efficacement en général (ou simplement pas encore implémenté une procédure efficace), comme l'ajout entre les ``CircuitOp``\\ s. Dans ces cas, vous pouvez recevoir un résultat ``ListOp`` (ou une sous-classe) de votre opération représentant l'exécution paresseuse de l'opération. Par exemple, si vous essayez d'ajouter ensemble un ``DictStateFn`` et un ``CircuitStateFn``, vous recevrez un ``SummedOp`` représentant la somme des deux. Cette fonction d'état composite a encore un ``eval`` fonctionnel (mais peut avoir besoin d'effectuer un calcul non évolutif sous le capot, comme la conversion des deux en vecteurs)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2651
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "Ces ``OperatorBase``\\ s composites sont à l'image de comment nous construisons des calculs de plus en plus complexes et riches en utilisant les blocs de construction ``PrimitiveOp`` et ``StateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2653
msgid "Every ``ListOp`` has four properties:"
msgstr "Chaque ``ListOp`` a quatre propriétés :"

#: ../../tutorials/operators/01_operator_flow.ipynb:2655
msgid "``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc."
msgstr "``oplist`` - La liste des ``OperatorBase``\\ s qui peuvent représenter des termes, des facteurs, etc."

#: ../../tutorials/operators/01_operator_flow.ipynb:2656
msgid "``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays."
msgstr "``combo_fn`` - La fonction qui prend une liste de nombres complexes à une valeur de sortie qui définit comment combiner les sorties des éléments ``oplist``. Pour la simplicité de diffusion, cette fonction est définie sur les tableaux NumPy."

#: ../../tutorials/operators/01_operator_flow.ipynb:2657
msgid "``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``."
msgstr "``coeff`` - Un coefficient multiplicateur de la primitive. Notez que ``coeff`` peut être int, float, complexe ou un objet ``Parameter`` libre (à partir de ``qiskit. ircuit`` dans Terra) pour être lié plus tard en utilisant ``my_op.bind_parameters``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2658
msgid "``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "``abelian`` - Indique si les Opérateurs de ``oplist`` sont connus pour être mutuellement commutés (généralement définis après avoir été convertis par le convertisseur ``AbelianGrouper``)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2660
msgid "Note that ``ListOp`` supports typical sequence overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "Notez que ``ListOp`` supporte les surcharges de séquences typiques, donc vous pouvez utiliser l'indexation comme ``my_op[4]`` pour accéder aux ``OperatorBase``\\ s dans ``oplist``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2672
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2674
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "Nous avons mentionné ci-dessus que ``OperatorStateFn`` représente un opérateur de densité. Mais si le flag ``is_measurement`` est ``True``, alors ``OperatorStateFn`` représente un observable. La valeur attendue de cette observable peut alors être construite via ``ComposedOp``. Ou directement, en utilisant ``eval``. Rappelez-vous que le flag ``is_measurement`` (property) est défini via la méthode ``adjoint``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2685
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "Ici nous construisons l'observable correspondant à l'opérateur Pauli :math:`Z`. Notez que lors de l'impression, il est appelé ``OperatorMeasurement``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2757
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "Ici, nous calculons :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2811
msgid "Part IV: Converters"
msgstr "Partie IV : Convertisseurs"

#: ../../tutorials/operators/01_operator_flow.ipynb:2813
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter’s ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr "Les convertisseurs sont des classes qui manipulent les opérateurs et les états et exécutent des blocs de construction d'algorithmes. Par exemple, modifier la base des opérateurs et de Trotterisation. Les convertisseurs traversent une expression et effectuent une manipulation ou un remplacement particuliers, définis par la méthode ``convert()`` du convertisseur, des Opérateurs à l'intérieur. Typiquement, si un convertisseur rencontre une ``OperatorBase`` dans la récursion qui n'est pas pertinente à son but de conversion, que ``OperatorBase`` est laissé inchangé."

#: ../../tutorials/operators/01_operator_flow.ipynb:2838
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "Evolutions, ``exp_i()`` et le ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2840
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can’t perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr "Chaque ``PrimitiveOp`` et ``ListOp`` a une fonction ``.exp_i()`` telle que ``H.exp_i()`` correspond à :math:`e^{-iH}`. Dans la pratique, seuls quelques-uns de ces opérateurs disposent d'une exponentiation calculable de manière efficace (comme MatrixOp et PauliOps avec un seul qubit), donc nous avons besoin de retourner un espace réservé, ou une représentation symbolique (similaire à la façon dont ``SummedOp`` est un espace réservé quand nous ne pouvons pas effectuer d'ajout). Ce espace réservé s'appelle ``EvolvedOp``, et il contient la ``OperatorBase`` pour être exponentiée dans sa propriété ``.primitive``."

#: ../../tutorials/operators/01_operator_flow.ipynb:2843
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there’s no “evolution time” argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr "Les opérateurs Qiskit supportent entièrement le paramétrage, donc nous pouvons utiliser un ``Parameter`` pour notre temps d'évolution ici. Notez qu’il n’y a pas d’argument « temps d’évolution» dans une fonction. Le flux de l'opérateur exponentialise n'importe quel opérateur que nous lui désignons, et si nous choisissons de multiplier l'opérateur par un temps d'évolution, :math:`e^{-iHt}`, ce sera reflété dans nos paramètres d'exponentiation."

#: ../../tutorials/operators/01_operator_flow.ipynb:2855
msgid "Weighted sum of Pauli operators"
msgstr "Somme pondérée des opérateurs Pauli"

#: ../../tutorials/operators/01_operator_flow.ipynb:2857
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "Un Hamiltonien exprimé comme une combinaison linéaire d'opérateurs Pauli multi-qubit peut être construit comme ceci."

#: ../../tutorials/operators/01_operator_flow.ipynb:2882
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "Notez que ``two_qubit_H2`` est représenté comme un ``SummedOp`` dont les termes sont des ``PauliOp``\\ s."

#: ../../tutorials/operators/01_operator_flow.ipynb:2939
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "Ensuite, nous multiplions l'Hamiltonien par un ``Parameter``. Ce ``Parameter`` est stocké dans la propriété ``coeff`` du ``SummedOp``. Appeler ``exp_i()`` sur le résultat l'enveloppe dans ``EvolvedOp``, représentant l'exponentiation."

#: ../../tutorials/operators/01_operator_flow.ipynb:3014
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "Nous construisons ``h2_measurement``, qui représente ``two_qubit_H2`` comme observable."

#: ../../tutorials/operators/01_operator_flow.ipynb:3072
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr "Nous construisons un état Bell :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3136
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "Voici l'expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3242
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "Généralement, nous voulons approximer :math:`e^{-iHt}` en utilisant des portes à deux qubits. Nous y parvenons avec la méthode ``convert`` de ``PauliTrotterEvolution``, qui traverse les expressions en appliquant la trotterisation à tous les ``EvolvedOp``\\ s rencontrés. Bien que nous utilisions ``PauliTrotterEvolution`` ici, il y a d'autres possibilités, telles que ``MatrixEvolution``, qui effectue l'exponentiation exactement."

#: ../../tutorials/operators/01_operator_flow.ipynb:3361
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` contient un ``Parameter``. La méthode ``bind_parameters`` traverse les valeurs de liaison de l'expression aux noms de paramètres comme spécifié via un ``dict``. Dans ce cas, il n'y a qu'un seul paramètre."

#: ../../tutorials/operators/01_operator_flow.ipynb:3382
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let’s draw it to verify that the binding has taken place."
msgstr "``bound`` est un ``ComposedOp``. Le second facteur est le circuit. Dessinons-le pour vérifier que la liaison a eu lieu."

#: ../../tutorials/operators/01_operator_flow.ipynb:3502
msgid "Expectations"
msgstr "Espérances"

#: ../../tutorials/operators/01_operator_flow.ipynb:3504
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "Les ``Expectation``\\ s sont des convertisseurs qui permettent le calcul des valeurs attendues des observables. Ils traversent une arborescence de Operator, remplaçant les ``OperatorStateFn``\\ s (observables) par des instructions équivalentes qui sont plus aptes au calcul sur le matériel quantique ou classique. Par exemple, si nous voulons mesurer la valeur attendue d'un Operator ``o`` exprimé en somme de Paulis par rapport à une fonction d'état, mais que nous ne pouvons accéder qu'aux mesures diagonales sur le matériel quantique, nous pouvons créer un observable ``~StateFn(o)`` et utiliser une ``PauliExpectation`` pour le convertir en une mesure diagonale et des pré-rotations de circuit à ajouter à l'état."

#: ../../tutorials/operators/01_operator_flow.ipynb:3507
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "Une autre ``Expectation`` intéressante est la ``AerPauliExpectation``, qui convertit l'observable en un ``CircuitStateFn`` contenant une instruction intstantanée d'espérance que ``Aer`` peut exécuter nativement avec de hautes performances."

#: ../../tutorials/operators/01_operator_flow.ipynb:3628
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "Par défaut ``group_paulis=True``, qui utilisera le ``AbelianGrouper`` pour convertir le ``SummedOp`` en des groupes de Paulis commutant mutuellement sur les qubits. Cela réduit la surcharge d'exécution du circuit, car chaque groupe peut partager le même circuit exécution."

#: ../../tutorials/operators/01_operator_flow.ipynb:3721
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "Notez que les convertisseurs agissent récursivement, c'est-à-dire qu'ils traversent une expression en appliquant leur action uniquement lorsque cela est possible. Nous pouvons donc simplement convertir notre évolution complète et notre expression de mesure. Nous pourrions avoir également composé le ``h2_measurement`` converti avec notre évolution ``CircuitStateFn``. Nous procéderons en appliquant la conversion sur toute l'expression."

#: ../../tutorials/operators/01_operator_flow.ipynb:3905
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "Maintenant nous associons plusieurs valeurs de paramètres dans un ``ListOp``, suivi par ``eval`` pour évaluer l'expression entière. Nous aurions pu utiliser ``eval`` plus tôt si nous lions plus tôt, mais cela ne serait pas efficace. Ici, ``eval`` convertira nos ``CircuitStateFn``\\ s en ``VectorStateFn``\\ s à travers la simulation interne."

#: ../../tutorials/operators/01_operator_flow.ipynb:3927
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "Voici les valeurs d'espérance :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` correspondant aux différentes valeurs du paramètre."

#: ../../tutorials/operators/01_operator_flow.ipynb:3980
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "Exécution des ``CircuitStateFn``\\ s avec le ``CircuitSampler``"

#: ../../tutorials/operators/01_operator_flow.ipynb:3982
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFn``\\ s into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule)."
msgstr "Le ``CircuitSampler`` traverse un Operator et convertit n'importe quel ``CircuitStateFn``\\ s en approximations de la fonction d'état qui en résulte par un ``DictStateFn`` ou un ``VectorStateFn`` en utilisant un backend quantique. Notez que pour approcher la valeur du ``CircuitStateFn``, il doit 1) envoyer la fonction d'état par un canal dépolarisant, qui détruira toutes les informations de phase et 2) remplacera les fréquences échantillonnées par des **racines carrées** de la fréquence, plutôt que la probabilité brute d'échantillonnage (qui serait l'équivalent de l'échantillonnage du **carré** de la fonction d'état, selon la règle de Born)."

#: ../../tutorials/operators/01_operator_flow.ipynb:4038
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "Notez à nouveau que les circuits sont remplacés par des dicts avec **racines carrées** des probabilités d'échantillonnage du circuit. Jetez un coup d'œil à une sous-expression avant et après la conversion :"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-13 18:47+0000\n"
"PO-Revision-Date: 2021-07-13 19:42\n"
"Last-Translator: \n"
"Language-Team: French\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: fr\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/circuits/3_summary_of_quantum_operations.po\n"
"X-Crowdin-File-ID: 9118\n"
"Language: fr_FR\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:10
msgid "This page was generated from `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."
msgstr "Cette page a été générée à partir de `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr "Liste des opérateurs quantiques"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:20
msgid "In this section we will go into the different operations that are available in Qiskit Terra. These are:"
msgstr "Dans cette section, nous aborderons les différentes opérations disponibles dans le module Terra de Qiskit. Celles-ci sont :"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:22
msgid "Single-qubit quantum gates"
msgstr "Portes quantiques mono-qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:23
msgid "Multi-qubit quantum gates"
msgstr "Portes quantiques multi-qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:24
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3282
msgid "Measurements"
msgstr "Mesures"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:25
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3496
msgid "Reset"
msgstr "Réinitialisation"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:26
msgid "Conditionals"
msgstr "Conditions"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:27
msgid "State initialization"
msgstr "Initialisation d'état"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:29
msgid "We will also show you how to use the three different simulators:"
msgstr "Nous vous montrerons également comment utiliser les trois simulateurs différents:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:31
msgid "unitary_simulator"
msgstr "unitary_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:32
msgid "qasm_simulator"
msgstr "qasm_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:33
msgid "statevector_simulator"
msgstr "statevector_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:73
msgid "Single Qubit Quantum states"
msgstr "Etats quantiques d'un Qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:75
msgid "A single qubit quantum state can be written as"
msgstr "L'état quantique d'un seul qubit peut être écrit en tant que"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:77
msgid "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:79
msgid "where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a measurement the probability of the bit being in :math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and :math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this is"
msgstr "où :math:`\\alpha` et :math:`\\beta` sont des nombres complexes. Dans une mesure, la probabilité que le bit soit dans :math:`\\left|0\\right\\rangle est :math:`|\\alpha|^2` et :math:`\\left|1\\right\\rangle` est :math:`|\\beta|^2`. En tant que vecteur, c'est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:81
msgid "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:90
msgid "Note, due to the conservation of probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` and since global phase is undetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` we only require two real numbers to describe a single qubit quantum state."
msgstr "Notez que , en raison de la conservation de la probabilité :math:`|\\alpha|^2+ |\\beta|^2 = 1` et puisque la phase globale n'est pas détectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` nous n'avons besoin que de deux nombres réels pour décrire un seul état quantique."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:92
msgid "A convenient representation is"
msgstr "Une représentation pratique est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:94
msgid "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:96
msgid "where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq \\pi`. From this, it is clear that there is a one-to-one correspondence between qubit states (:math:`\\mathbb{C}^2`) and the points on the surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the Bloch sphere representation of a qubit state."
msgstr "où :math:`0\\leq \\phi < 2\\pi`, et :math:`0\\leq \\theta \\leq \\pi`. À partir de là, il est clair qu'il y a une correspondance un à un entre les états du qubit (:math:`\\mathbb{C}^2`) et les points à la surface d'une sphère unitaire (:math:`\\mathbb{R}^3`). Ceci est appelé la représentation de la sphère Bloch de l'état du qubit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:98
msgid "Quantum gates/operations are usually represented as matrices. A gate which acts on a qubit is represented by a :math:`2\\times 2` unitary matrix :math:`U`. The action of the quantum gate is found by multiplying the matrix representing the gate with the vector which represents the quantum state."
msgstr "Les portes/opérations quantiques sont généralement représentées par des matrices. Une porte qui agit sur un qubit est représentée par une matrice unitaire :math:`2\\times 2` :math:`U`. L'action de la porte quantique se calcule en multipliant la matrice représentant la porte avec le vecteur qui représente l'état quantique."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:100
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:102
msgid "A general unitary must be able to take the :math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr "Un état unitaire général doit être en mesure de prendre l'angle :math:`\\left|0\\rdroit\\rà l'état ci-dessus. C'est à dire"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:104
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:112
msgid "where :math:`a` and :math:`b` are complex numbers constrained such that :math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and :math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where :math:`0\\leq \\lambda<2\\pi` giving"
msgstr "où :math:`a` et :math:`b` sont des nombres complexes contraints tels que :math:`U^\\dagger U = I` pour tous les :math:`0\\leq\\theta\\leq\\pi` et :math:`0\\leq \\phi<2\\pi`. Cela donne 3 contraintes et donc :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` et :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` où :math:`0\\leq \\lambda<2\\pi` qui donnent"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:114
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & -e^{i\\lambda}\\sin(\\theta/2) \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & e^{i\\lambda+i\\phi}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:122
msgid "This is the most general form of a single qubit unitary."
msgstr "Il s'agit de la forme la plus générale d'un qubit unitaire/unique."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:134
msgid "Single-Qubit Gates"
msgstr "Portes à un seul Qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:136
msgid "The single-qubit gates available are: - u gates - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr "Les portes (gates) mono-qubit disponibles sont: - u gates - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:138
msgid "We have provided a backend: ``unitary_simulator`` to allow you to calculate the unitary matrices."
msgstr "Nous avons fourni un backend : ``unitary_simulator`` pour vous permettre de calculer les matrices unitaires."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:160
msgid "u gates"
msgstr "portes U"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:162
msgid "In Qiskit we give you access to the general unitary using the :math:`u3` gate"
msgstr "Dans Qiskit nous vous donnons accès à l'unicité générale en utilisant la porte :math:`u3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:164
msgid "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"
msgstr "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:262
msgid "The :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` gate has the matrix form"
msgstr "La porte :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` a la forme de la matrice"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:264
msgid "u2(\\phi, \\lambda) =\n"
"\\frac{1}{\\sqrt{2}} \\begin{pmatrix}\n"
"1 & -e^{i\\lambda} \\\\\n"
"e^{i\\phi} & e^{i(\\phi + \\lambda)}\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:273
msgid "This is a useful gate as it allows us to create superpositions."
msgstr "C'est une porte utile car elle nous permet de créer des superpositions."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:368
msgid "The :math:`u1(\\lambda)= u3(0, 0, \\lambda)` gate has the matrix form"
msgstr "La porte :math:` u1 (\\lambda) = u3 (0, 0, \\lambda) a la forme matricielle"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:370
msgid "u1(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:379
msgid "which is useful as it allows us to apply a quantum phase."
msgstr "qui est utile car il nous permet d'appliquer une phase quantique."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:475
msgid "Identity gate"
msgstr "Porte identité"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:477
msgid "The identity gate is :math:`Id = u0(1)`."
msgstr "La porte identité est :math:`Id = u0(1)`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:573
msgid "Pauli gates"
msgstr "Portes de Pauli"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:576
msgid ":math:`X`: bit-flip gate"
msgstr ":math:` X `: porte d'inversion (flip-bit)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:578
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr "La porte bit-flip :math:`X` est définie comme :"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:580
msgid "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u3(\\pi,0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:683
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ":math:`Y`: porte d'inversion de bits et de phase"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:685
msgid "The :math:`Y` gate is defined as:"
msgstr "La porte :math:`Y` est définie comme :"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:687
msgid "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u3(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:790
msgid ":math:`Z`: phase-flip gate"
msgstr ":math:`Z` : porte d'inversion de phase"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:792
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr "La porte d'inversion (flip) de phase :math:` Z ` est définie comme suit:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:794
msgid "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=u1(\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:897
msgid "Clifford gates"
msgstr "Portes de Clifford"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:900
msgid "Hadamard gate"
msgstr "Porte d'Hadamard"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:902
msgid "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u2(0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1006
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr "porte :math:`S` (ou, :math:`\\sqrt{Z}` phase)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1008
msgid "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= u1(\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1111
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr "porte :math:`S^{\\dagger}` (ou, conjuguant la phase :math:`\\sqrt{Z}` )"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1113
msgid "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= u1(-\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1216
msgid ":math:`C3` gates"
msgstr "portes :math:`C3`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1219
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr "porte :math:`T` (ou, phase :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1221
msgid "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= u1(\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1324
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr "porte :math:`T^{\\dagger}` (ou, conjuguant la phase :math:`\\sqrt{S}`)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1326
msgid "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= u1(-\\pi/4)"
msgstr "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= u1(-\\pi/4)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1429
msgid "Standard Rotations"
msgstr "Rotations standard"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1431
msgid "The standard rotation gates are those that define rotations around the Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr "Les portes de rotation standard sont celles qui définissent les rotations autour des :math:`P=\\{X,Y,Z\\}` de Pauli. Elles sont définies comme"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1433
msgid "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1436
msgid "Rotation around X-axis"
msgstr "Rotation autour de l'axe X"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1438
msgid "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u3(\\theta, -\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1541
msgid "Rotation around Y-axis"
msgstr "Rotation autour de l'axe des Y"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1543
msgid "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u3(\\theta,0,0)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1646
msgid "Rotation around Z-axis"
msgstr "Rotation autour de l'axe Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1648
msgid "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv u1(\\phi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1657
msgid "Note that here we have used an equivalent as it is different to u1 by a global phase :math:`e^{-i \\phi/2}`."
msgstr "Notez qu'ici nous avons utilisé un équivalent car il est différent de u1 par une phase globale :math:` e ^ {-i \\phi/2 } `."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1752
msgid "Note this is different due only to a global phase."
msgstr "Notez que ceci est différent en raison de la phase globale."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1764
msgid "Multi-Qubit Gates"
msgstr "Portes multi-Qubit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1767
msgid "Mathematical Preliminaries"
msgstr "Préliminaires mathématiques"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1769
msgid "The space of a quantum computer grows exponentially with the number of qubits. For :math:`n` qubits the complex vector space has dimension :math:`d=2^n`. To describe states of a multi-qubit system, the tensor product is used to “glue together” operators and basis vectors."
msgstr "L'espace de calcul d'un ordinateur quantique croît exponentiellement avec le nombre de qubits. Pour les :math:`n` qubits, l'espace vectoriel complexe correspondant a une dimension :math:`d=2^n`. Pour décrire les états d'un système multiqubit, le produit tensoriel est utilisé pour \"coller\" les opérateurs et les vecteurs de base."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1771
msgid "Let’s start by considering a 2-qubit system. Given two operators :math:`A` and :math:`B` that each act on one qubit, the joint operator :math:`A \\otimes B` acting on two qubits is"
msgstr "Commençons par considérer un système a 2-qubit. Étant donné les deux opérateurs :math:`A` et :math:`B` chacun agissant sur un seul qubit, l'opérateur commun :math:`A\\otimes B` agissant sur les deux qubits est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1773
msgid "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1795
msgid "where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of :math:`A` and :math:`B`, respectively."
msgstr "où :math:` A_{jk}` et :math:` B_{lm}` sont les éléments matriciels de :math:` A ` et :math:` B `, respectivement."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1797
msgid "Analogously, the basis vectors for the 2-qubit system are formed using the tensor product of basis vectors for a single qubit:"
msgstr "De façon analogue, les vecteurs de base pour le système à deux qubits sont formés à l'aide du produit tensoriel des vecteurs de base pour un seul qubit:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1799
msgid "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1823
msgid "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1846
msgid "Note we’ve introduced a shorthand for the tensor product of basis vectors, wherein :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. The state of an :math:`n`-qubit system can be described using the :math:`n`-fold tensor product of single-qubit basis vectors. Notice that the basis vectors for a 2-qubit system are 4-dimensional; in general, the basis vectors of an :math:`n`-qubit system are :math:`2^{n}`-dimensional, as noted earlier."
msgstr "Remarque : nous avons introduit un raccourci pour le produit tenseur de vecteurs de base, où :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` est écrit comme :math:`\\left|00\\right\\rangle`. L'état d'un système à :math:`n`-qubit peut être décrit en utilisant le produit tensoriel :math:`n`-fois de vecteurs de base mono-qubit. Notez que les vecteurs de base pour un système 2-qubit définissent un espace de dimension 4 ; en général, les vecteurs de base d'un système :math:`n`-qubit ont :math:`2^{n}`-dimensions, comme indiqué plus tôt."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1849
msgid "Basis vector ordering in Qiskit"
msgstr "Ordre des vecteurs de base dans Qiskit"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1851
msgid "Within the physics community, the qubits of a multi-qubit systems are typically ordered with the first qubit on the left-most side of the tensor product and the last qubit on the right-most side. For instance, if the first qubit is in state :math:`\\left|0\\right\\rangle` and second is in state :math:`\\left|1\\right\\rangle`, their joint state would be :math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different ordering of the qubits, in which the qubits are represented from the most significant bit (MSB) on the left to the least significant bit (LSB) on the right (big-endian). This is similar to bitstring representation on classical computers, and enables easy conversion from bitstrings to integers after measurements are performed. For the example just given, the joint state would be represented as :math:`\\left|10\\right\\rangle`. Importantly, *this change in the representation of multi-qubit states affects the way multi-qubit gates are represented in Qiskit*, as discussed below."
msgstr "Au sein de la communauté des physiciens, les qubits d'un système multiqubit sont généralement classés avec le premier qubit sur le côté gauche du produit tensoriel et le dernier qubit sur le côté droit. Par exemple, si le premier qubit est à l'état :math:` \\left | 0\\right\\rangle ` et le second est dans l'état :math:` \\left | 1\\right\\rangle `, leur état joint est :math:` \\left | 01\\right\\rangle `. Qiskit utilise un ordre légèrement différent des qubits, dans lequel les qubits sont représentés du bit le plus significatif (MSB) sur la gauche au bit le moins significatif (LSB) à droite (big-endian). Ceci est similaire à la représentation chaine de bits 'bitstring' sur les ordinateurs classiques, et permet une conversion facile des bitstring en nombres entiers une fois les mesures effectuées. Pour l'exemple qui vient d'être donné, l'état joint est représenté sous la forme :math:` \\left | 10\\right\\rangle `. Fait important, * ce changement dans la représentation des états multiqubits affecte la façon dont les portes multiqubit sont représentées dans Qiskit *, comme indiqué ci-dessous."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1854
msgid "The representation used in Qiskit enumerates the basis vectors in increasing order of the integers they represent. For instance, the basis vectors for a 2-qubit system would be ordered as :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. Thinking of the basis vectors as bit strings, they encode the integers 0,1,2 and 3, respectively."
msgstr "La représentation utilisée dans Qiskit énumère les vecteurs de base dans l'ordre croissant des entiers qu'ils représentent. Par exemple, les vecteurs de base d'un système 2-qubit sont classés comme ceci :math:` \\left | 00\\right\\rangle `, :math:` \\left | 01\\right\\rangle `, :math:` \\left | 10\\right\\rangle `, and :math:` \\left | 11\\right\\rangle `. En pensant aux vecteurs de base comme des chaînes de bits, ils encodent les entiers 0,1,2 et 3, respectivement."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1857
msgid "Controlled operations on qubits"
msgstr "Opérations contrôlées sur des qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1859
msgid "A common multi-qubit gate involves the application of a gate to one qubit, conditioned on the state of another qubit. For instance, we might want to flip the state of the second qubit when the first qubit is in :math:`\\left|0\\right\\rangle`. Such gates are known as *controlled gates*. The standard multi-qubit gates consist of two-qubit gates and three-qubit gates. The two-qubit gates are: - controlled Pauli gates - controlled Hadamard gate - controlled rotation gates - controlled phase gate - controlled u3 gate - swap gate"
msgstr "Une porte multiqubit simple implique l'application d'une porte à un qubit, conditionnée à l'état d'un autre qubit. Par exemple, nous pourrions faire basculer l'état du deuxième qubit lorsque le premier qubit est en :math:` \\left | 0\\right\\rangle `. Ces portes sont connues sous le nom de \"portes contrôlées\" *. Les portes multi-qubits standard se composent de portes avec deux qubits et de portes avec trois qubit.s Les portes de deux qubits sont: - les portes de Pauli  -  les portes Hadamard contrôlées - les portes de rotation contrôlée -les portes de contrôle de phase - la porte contrôlée u3 - la poste de permutation (swap)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1862
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr "Les portes à trois qubits sont:- la porte de Toffoli - la porte de Fredkin"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1874
msgid "Two-qubit gates"
msgstr "Portes à deux qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1876
msgid "Most of the two-qubit gates are of the controlled type (the SWAP gate being the exception). In general, a controlled two-qubit gate :math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the second qubit when the state of the first qubit is in :math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix representation"
msgstr "La plupart des portes à deux qubits sont de type contrôlé (la porte SWAP étant l'exception). En général, une porte à deux qubits contrôlée :math:`C_{U}` agit pour appliquer l'unitaire a simple qubit :math:`U` au second qubit lorsque l'état du premier qubit est en :math:`\\left|1\\right\\rangle`. Supposons que :math:`U` ait une représentation matricielle"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1878
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1880
msgid "We can work out the action of :math:`C_{U}` as follows. Recall that the basis vectors for a two-qubit system are ordered as :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the **control qubit** is **qubit 0** (which, according to Qiskit’s convention, is one the *right-hand* side of the tensor product). If the control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be applied to the **target** (qubit 1, on the *left-hand* side of the tensor product). Therefore, under the action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr "Nous pouvons définir l'action de :math:`C_{U}` comme suit. Rappelez-vous que les vecteurs de base pour un système à deux qubits sont ordonnés comme ceci: :math:`\\left|00\\rdroit\\r\\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Supposons que le **qubit de contrôle** soit le **qubit 0** (ce qui, selon la convention de Qiskit, est du côté *droit* du produit de tenseur). Si le qubit de contrôle est en :math:`\\left|1\\right\\rangle`, :math:`U` devrait être appliqué à la **cible** (qubit 1, du côté *gauche* du produit de tenseur). Par conséquent, sous l'action de :math:`C_{U}`, les vecteurs de base sont transformés en fonction de"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1883
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1892
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr "Sous forme de matrice, l'action de :math:` C_{U}` est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1894
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1905
msgid "To work out these matrix elements, let"
msgstr "Pour trouver ces éléments de la matrice, prenons"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1907
msgid "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| k \\right\\rangle}\\right),\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1909
msgid "compute the action of :math:`C_{U}` (given above), and compute the inner products."
msgstr "calcule l'action de :math:`C_{U}` (donné ci-dessus) et calcule les produits intérieurs."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1911
msgid "As shown in the examples below, this operation is implemented in Qiskit as ``cU(q[0],q[1])``."
msgstr "Comme le montrent les exemples ci-dessous, cette opération est implémentée dans Qiskit sous la forme ` ` cU (q[0], q[1]) ` `."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1913
msgid "If **qubit 1 is the control and qubit 0 is the target**, then the basis vectors are transformed according to"
msgstr "Si ** qubit 1 est le contrôle et qubit 0 est la cible * *, les vecteurs de base sont transformés selon"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1915
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1924
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr "qui implique que la forme matricielle de :math:` C_{U}` est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1926
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1957
msgid "Controlled Pauli Gates"
msgstr "Portes de Pauli contrôlées"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1960
msgid "Controlled-X (or, controlled-NOT) gate"
msgstr "Porte control-X (ou, control-NOT)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1962
msgid "The controlled-not gate flips the ``target`` qubit when the control qubit is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr "La porte control-NOT inverse le qubit ``cible`` lorsque le qubit de contrôle est dans l'état :math:`\\left |1\\right\\rangle`. Si nous prenons le MSB (most significant bit ou bit de poids fort) comme qubit de contrôle (par exemple ``cx(q[1], q[0])``), alors la matrice ressemblera à"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1964
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1975
msgid "However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), this gate is equivalent to the following matrix:"
msgstr "Et lorsque c'est le bit de poids faible (LSB, less significant bit) qui est le qubit de contrôle (par exemple ``cx(q[0], q[1])``), cette porte est équivalente à la matrice suivante :"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1977
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."
msgstr "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2092
msgid "Controlled :math:`Y` gate"
msgstr "Porte control:math:`Y`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2094
msgid "Apply the :math:`Y` gate to the target qubit if the control qubit is the MSB"
msgstr "Applique la porte :math:` Y au qubit cible si le qubit de contrôle est le MSB"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2096
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2107
msgid "or when the LSB is the control"
msgstr "ou lorsque le LSB est le qubit de contrôle"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2109
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2224
msgid "Controlled :math:`Z` (or, controlled Phase) gate"
msgstr "Porte de contrôle :math:`Z` (ou, porte de contrôle de phase)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2226
msgid "Similarly, the controlled Z gate flips the phase of the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks the same regardless of whether the MSB or LSB is the control qubit:"
msgstr "De même, la porte contrôlée Z inverse la phase du qubit cible si le qubit de contrôle est :math:` \\left | 1\\right\\rangle `. La matrice est la même, que le qubit de contrôle soit le MSB ou le LSB:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2228
msgid "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2343
msgid "Controlled Hadamard gate"
msgstr "Porte de Hadamard contrôlée"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2345
msgid "Apply :math:`H` gate to the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. Below is the case where the control is the LSB qubit."
msgstr "Applique la porte  :math:` H ` au qubit cible si le qubit de contrôle est :math:` \\left | 1\\right\\rangle `. Ci-dessous se trouve le cas où le qubit de contrôle est le LSB."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2347
msgid "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2462
msgid "Controlled rotation gates"
msgstr "Portes de rotation contrôlées"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2465
msgid "Controlled rotation around Z-axis"
msgstr "Rotation contrôlée autour de l'axe Z"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2467
msgid "Perform rotation around Z-axis on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Effectue rotation autour de Z-axis sur le qubit cible si le qubit de contrôle (ici LSB) est :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2469
msgid "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2584
msgid "Controlled phase rotation"
msgstr "Rotation de phase contrôlée"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2586
msgid "Perform a phase rotation if both qubits are in the :math:`\\left|11\\right\\rangle` state. The matrix looks the same regardless of whether the MSB or LSB is the control qubit."
msgstr "Effectuez une rotation de phase si les deux bits se trouvent dans l'état :math:` \\left | 11\\right\\r. La matrice est la même, que le MSB ou le LSB soit le qubit de contrôle."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2588
msgid "C_{u1}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2703
msgid "Controlled :math:`u3` rotation"
msgstr "Rotation :math:`u3` contrôlée"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2705
msgid "Perform controlled-\\ :math:`u3` rotation on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "Effectue la rotation contrôlée-\\ :math:`u3` sur le qubit cible si le qubit de contrôle (ici LSB) est :math:`\\left|1\\right\\rangle`."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2707
msgid "C_{u3}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2822
msgid "SWAP gate"
msgstr "Porte SWAP"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2824
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr "La porte SWAP échange les deux qubits. Elle transforme les vecteurs de base en"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2826
msgid "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2828
msgid "which gives a matrix representation of the form"
msgstr "qui donne une représentation matricielle de la forme"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2830
msgid "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2945
msgid "Three-qubit gates"
msgstr "Portes à trois qubits"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2947
msgid "There are two commonly-used three-qubit gates. For three qubits, the basis vectors are ordered as"
msgstr "Il y a deux portes à trois qubits communément utilisées. Pour trois qubits, les vecteurs de base sont ordonnés comme"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2949
msgid "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2951
msgid "which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. Again, Qiskit uses a representation in which the first qubit is on the right-most side of the tensor product and the third qubit is on the left-most side:"
msgstr "qui, en tant que chaînes de bits, représentent les entiers :math:`0,1,2,\\cdots, 7`. Encore une fois, Qiskit utilise une représentation dans laquelle le premier qubit est celui le plus à droite du produit tenseur et le troisième qubit est le plus à gauche :"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2953
msgid "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2965
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr "Porte de Toffoli (:math:` ccx ` gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2967
msgid "The `Toffoli gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ flips the third qubit if the first two qubits (LSB) are both :math:`\\left|1\\right\\rangle`:"
msgstr "La \" porte de Toffoli <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>` __ inverse le troisième qubit si les deux premiers qubits (LSB) sont tous les deux :math:` \\left | 1\\right\\rangle `:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2969
msgid "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2971
msgid "In matrix form, the Toffoli gate is"
msgstr "Sous forme de matrice, la porte Toffoli est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2973
msgid "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3116
msgid "Controlled swap gate (Fredkin Gate)"
msgstr "Porte d'échange (swap) contrôlée (Porte de Fredkin)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3118
msgid "The `Fredkin gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, or the *controlled swap gate*, exchanges the second and third qubits if the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr "La `porte de Fredkin <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, ou la *porte d'échange contrôlée*, échange les deuxième et troisième qubits si le premier qubit (LSB) est :math:`\\left|1\\right\\rangle`:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3120
msgid "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3122
msgid "In matrix form, the Fredkin gate is"
msgstr "Sous forme de matrice, la porte Fredkin est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3124
msgid "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3257
msgid "Non-unitary operations"
msgstr "Opérations non unitaires"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3259
msgid "Now that we have gone through all the unitary operations in quantum circuits, we also have access to non-unitary operations. These include measurements, reset of qubits, and classical conditional operations."
msgstr "En plus de toutes les opérations unitaires dans les circuits quantiques, nous avons aussi accès à des opérations non unitaires. Il s'agit notamment des mesures, de la réinitialisation des qubits et des opérations conditionnelles classiques."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3284
msgid "We don’t have access to all the information when we make a measurement in a quantum computer. The quantum state is projected onto the standard basis. Below are two examples showing a circuit that is prepared in a basis state and the quantum computer prepared in a superposition state."
msgstr "Nous n'avons pas accès à toutes les informations lorsque nous faisons une mesure dans un ordinateur quantique. L'état quantique est projeté sur la base standard. Ci-dessous sont deux exemples montrant d'une part un circuit qui est préparé dans un état de base et d'autre part un état de superposition."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3384
msgid "The simulator predicts that 100 percent of the time the classical register returns 0."
msgstr "Le simulateur prédit 100% du temps que le registre classique renvoie 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3484
msgid "The simulator predicts that 50 percent of the time the classical register returns 0 or 1."
msgstr "Le simulateur prédit que la valeur du registre classique sera 1 ou 0 à 50% du temps."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3498
msgid "It is also possible to ``reset`` qubits to the :math:`\\left|0\\right\\rangle` state in the middle of computation. Note that ``reset`` is not a Gate operation, since it is irreversible."
msgstr "Il est également possible de ` ` réinitialiser ` ` les qubits vers l'état  :math:` \\left | 0\\rposition\\rangle ` au milieu du calcul. Notez que ` ` reset ` ` n'est pas une porte logique, puisqu'elle est irréversible."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3688
msgid "Here we see that for both of these circuits the simulator always predicts that the output is 100 percent in the 0 state."
msgstr "Ici, nous voyons que pour ces deux circuits, le simulateur prévoit toujours que la sortie est à 100% dans l'état 0."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3700
msgid "Conditional operations"
msgstr "Opérations conditionnelles"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3702
msgid "It is also possible to do operations conditioned on the state of the classical register"
msgstr "Il est également possible d'effectuer des opérations conditionnées par l'état du registre classique"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3774
msgid "Here the classical bit always takes the value 0 so the qubit state is always flipped."
msgstr "Ici, le bit classique prend toujours la valeur 0 donc l'état du qubit est toujours inversé."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3910
msgid "Here the classical bit by the first measurement is random but the conditional operation results in the qubit being deterministically put into :math:`\\left|1\\right\\rangle`."
msgstr "Ici, le bit classique de la première mesure est aléatoire, mais l'opération conditionnelle résulte en un qubit déterministiquement mis en :math:` \\left | 1\\right\\rangle `."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3922
msgid "Arbitrary initialization"
msgstr "Initialisation arbitraire"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3924
msgid "What if we want to initialize a qubit register to an arbitrary state? An arbitrary state for :math:`n` qubits may be specified by a vector of :math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals 1. For example, the following three-qubit state can be prepared:"
msgstr "Et si nous voulons initialiser un registre de qubit à un état arbitraire? Un état arbitraire pour :math:` n ` qubits peut être spécifié par un vecteur d'amplitude  :math:` 2 ^ n ` , où la somme des amplitudes au carré est égale à 1. Par exemple, l'état tri-qubit suivant peut être préparé:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3926
msgid "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4055
msgid "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ is useful to check whether two states are the same or not. For quantum (pure) states :math:`\\left|\\psi_1\\right\\rangle` and :math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr "`La fidelité <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>` __ est utile pour vérifier si deux états sont identiques ou non. Pour les états quantiques (purs) :math:` \\left | \\psi_1\\right\\rangle ` et :math:` \\left | \\psi_2\\right\\rangle `, la fidélité est"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4057
msgid "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4062
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr "La fidélité est égale à :math:` 1 si et seulement si les deux états sont égaux."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4104
msgid "Further details:"
msgstr "Plus de détails:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4106
msgid "How does the desired state get generated behind the scenes? There are multiple methods for doing this. Qiskit uses a `method proposed by Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to assume the quantum register to have started from our desired state, and construct a circuit that takes it to the :math:`\\left|00..0\\right\\rangle` state. The initialization circuit is then the reverse of such circuit."
msgstr "Comment l'état souhaité est-il généré ? Il existe plusieurs méthodes pour ce faire. Qiskit utilise une méthode proposée par Shende et al <https://arxiv.org/abs/quant-ph/0406176>` __. Ici, l'idée est de supposer que le registre quantique a commencé à partir de notre état souhaité, et de construire un circuit qui l'emmène à l'état :math:` \\left | 00 .. 0\\right\\rangle ` . Le circuit d'initialisation est alors l'inverse de ce circuit."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4108
msgid "To take an arbitrary quantum state to the zero state in the computational basis, we perform an iterative procedure that disentangles qubits from the register one-by-one. We know that any arbitrary single-qubit state :math:`\\left|\\rho\\right\\rangle` can be taken to the :math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree rotation about the Z axis followed by a :math:`\\theta`-degree rotation about the Y axis:"
msgstr "Pour obtenir un état quantique arbitraire zéro dans la base de calcul, nous effectuons une procédure itérative qui démêle les qubits du registre un par un. Nous savons que tout état arbitraire à un seul qubit :math:` \\left |\\rho\\right\\rangle ` peut être modifié vers  l'état :math:` \\left | 0\\right\\rangle ` en utilisant une rotation autout de l'axe Z de :math:` \\phi `-degrès suivie d'une rotation autour de l'axe Y de :math:`\\theta `-degrés"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4110
msgid "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4112
msgid "Since now we are dealing with :math:`n` qubits instead of just 1, we must factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr "Puisque maintenant nous avons affaire avec :math:` n ` qubits au lieu de seulement 1, nous devons factoriser le vecteur d'état pour extraire le bit le moins significatif (LSB least significant bit):"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4114
msgid "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4122
msgid "Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to :math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and :math:`\\theta` angles per the equation above. Doing this simultaneously on all states amounts to the following unitary, which disentangles the LSB:"
msgstr "Maintenant chacun des états à un seul qubit :math:` \\left |\\rho_0\\right\\rangle, ..., \\left |\\rho_ { 2 ^{n-1}-1 }\\right\\rangle ` peut être transformé vers :math:` \\left | 0\\right\\rangle ` en trouvant les angles :math:` \\phi ` et :math: `\\theta ` appropriés en suivant l'équation ci-dessus. Faire cela simultanément sur tous les états revient à l'unité suivante, qui démêle la LSB:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4124
msgid "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4134
msgid "Hence,"
msgstr "C'est pourquoi"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4136
msgid "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4138
msgid "U can be implemented as a “quantum multiplexor” gate, since it is a block diagonal matrix. In the quantum multiplexor formalism, a block diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select qubits and :math:`n-s` data qubits. Depending on the state of the select qubits, the corresponding blocks are applied to the data qubits. A multiplexor of this kind can be implemented after recursive decomposition to primitive gates of cx, rz and ry."
msgstr "U peut être implémenté comme un \"multiplexeur quantique\", puisqu'il s'agit d'une matrice diagonale par bloc. Dans le formalisme quantique de multiplexage, une matrice diagonale par bloc de dimensions :math:`2^n \\times 2^n`, et comprenant :math:`2^s` blocs est équivalente à un multiplexeur avec :math:`s` qubits de selection et :math:`n - s` qubits de données. En fonction de l'état des bits de sélection, les blocs correspondants sont appliqués aux bits de données. Un multiplexeur de ce type peut être mis en œuvre après une décomposition récursive vers les portes primitives cx, rz et ry."


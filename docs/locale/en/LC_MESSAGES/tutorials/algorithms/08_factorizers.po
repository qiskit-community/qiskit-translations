# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2023, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-23 17:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../tutorials/algorithms/08_factorizers.ipynb:10
msgid ""
"This page was generated from "
"`tutorials/algorithms/08_factorizers.ipynb`__."
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:9
msgid "Shor's algorithms"
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:11
msgid ""
"Qiskit has an implementation of `Shor's algorithm "
"<https://qiskit.org/textbook/ch-algorithms/shor.html>`__."
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:13
msgid ""
"The preceding reference has detailed explanations and build-out of "
"circuits whereas this notebook has examples with the pre-built algorithms"
" in Qiskit that you can use for experimentation and education purposes."
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:39
msgid "Shor's Factoring algorithm"
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:41
msgid ""
"`Shorâ€™s Factoring algorithm "
"<https://qiskit.org/documentation/stubs/qiskit.algorithms.Shor.html>`__ "
"is one of the most well-known quantum algorithms and finds the prime "
"factors for input integer :math:`N` in polynomial time. The algorithm "
"implementation in Qiskit is simply provided a target integer to be "
"factored and run, as follows:"
msgstr ""

#: ../../tutorials/algorithms/08_factorizers.ipynb:91
msgid ""
"Note: this implementation of Shor's algorithm uses :math:`4n + 2` qubits,"
" where :math:`n` is the number of bits representing the integer in "
"binary. So in practice, for now, this implementation is restricted to "
"factorizing small integers. Given the above value of N we compute "
":math:`4n +2` below and confirm the size from the actual circuit."
msgstr ""


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 18:58+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:10
msgid ""
"This page was generated from "
"`tutorials/algorithms/09_textbook_algorithms.ipynb`__."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:12
msgid ""
"Run interactively in the `IBM Quantum lab <https://quantum-"
"computing.ibm.com/jupyter/tutorial/algorithms/09_textbook_algorithms.ipynb>`_."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:9
msgid "Textbook and Shor’s algorithms"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:11
msgid ""
"Qiskit contains implementations of the well known textbook quantum "
"algorithms such as the `Deutsch-Jozsa algorithm "
"<https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html>`__, the "
"`Bernstein-Vazirani algorithm <https://qiskit.org/textbook/ch-algorithms"
"/bernstein-vazirani.html>`__ and `Simon’s algorithm "
"<https://qiskit.org/textbook/ch-algorithms/simon.html>`__."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:13
msgid ""
"Qiskit also has an implementation of `Shor’s algorithm "
"<https://qiskit.org/textbook/ch-algorithms/shor.html>`__."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:15
msgid ""
"The preceding references have detailed explanations and build-out of "
"circuits whereas this notebook has examples with the pre-built algorithms"
" in Qiskit that you can use for experimentation and education purposes."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:42
msgid "Deutsch-Jozsa algorithm"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:44
msgid ""
"Lets start with the `Deutsch-Jozsa algorithm "
"<https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.DeutschJozsa.html>`__"
" which can determine if a function is ``'balanced'`` or ``'constant'`` "
"given such a function as input. We can experiment with it in Qiskit using"
" an oracles created from a truth tables. So for example, we can create a "
"``TruthTableOracle`` instance as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:66
msgid ""
"As shown, the truthtable is specified with the ``bitstr`` containing "
"values of all entries in the table. It has length :math:`8`, so the "
"corresponding truth table is of :math:`3` input bits. We can of course "
"see that this truth table represents a ``'balanced'`` function as half of"
" values are :math:`1` and the other half :math:`0`."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:68
msgid ""
"It might seem like a moot point running Deutsch-Jozsa on a truthtable as "
"the function outputs are literally listed as the truthtable’s values. The"
" intention is to create an oracle circuit whose groundtruth information "
"is readily available to us but obviously not to the quantum Deutsch-Jozsa"
" algorithm that is to act upon the oracle circuit. In more realistic "
"situations, the oracle circuit would be provided as a blackbox to the "
"algorithm."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:70
msgid ""
"Above said, we can inspect the circuit corresponding to the function "
"encoded in the ``TruthTableOracle`` instance."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:100
msgid ""
"As seen, the :math:`v_i`\\ ’s correspond to the 3 input bits; the "
":math:`o_0` is the oracle’s output qubit; the :math:`a_0` is an ancilla "
"qubit."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:102
msgid ""
"Next we can simply create a ``DeutschJozsa`` instance using the oracle, "
"and run it to check the result."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:145
msgid ""
"We can of course quickly put together another example for a "
"``'constant'`` function, as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:191
msgid "Bernstein-Vazirani algorithm"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:193
msgid ""
"Next the `Bernstein-Vazirani algorithm "
"<https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.BernsteinVazirani.html>`__"
" which tries to find a hidden string. Again, for the example, we create a"
" TruthTableOracle instance."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:215
msgid ""
"As shown, the truthtable is specified with the ``bitstr`` containing "
"values of all entries in the table. It has length :math:`8`, so the "
"corresponding truth table is of :math:`3` input bits. The truthtable "
"represents the function mappings as follows:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:217
msgid ":math:`\\mathbf{a} \\cdot 000 \\mod 2 = 0`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:218
msgid ":math:`\\mathbf{a} \\cdot 001 \\mod 2 = 0`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:219
msgid ":math:`\\mathbf{a} \\cdot 010 \\mod 2 = 1`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:220
msgid ":math:`\\mathbf{a} \\cdot 011 \\mod 2 = 1`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:221
msgid ":math:`\\mathbf{a} \\cdot 100 \\mod 2 = 1`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:222
msgid ":math:`\\mathbf{a} \\cdot 101 \\mod 2 = 1`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:223
msgid ":math:`\\mathbf{a} \\cdot 110 \\mod 2 = 0`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:224
msgid ":math:`\\mathbf{a} \\cdot 111 \\mod 2 = 0`"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:226
msgid ""
"And obviously the goal is to find the bitstring :math:`\\mathbf{a}` that "
"satisfies all the inner product equations."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:228
msgid ""
"Lets again look at the oracle circuit, that now corresponds to the binary"
" function encoded in the ``TruthTableOracle`` instance."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:258
msgid ""
"Again the :math:`v_i`\\ ’s correspond to the 3 input bits; the "
":math:`o_0` is the oracle’s output qubit; the :math:`a_0` is an ancilla "
"qubit."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:260
msgid "Let us first compute the groundtruth :math:`\\mathbf{a}` classically:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:305
msgid ""
"Next we can create a ``BernsteinVazirani`` instance using the oracle, and"
" run it to check the result against the groundtruth."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:350
msgid "Simon’s algorithm"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:352
msgid ""
"`Simon’s algorithm "
"<https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.Simon.html>`__"
" is used to solve `Simon’s problem "
"<https://en.wikipedia.org/wiki/Simon's_problem>`__. Once again, for the "
"example, we create a TruthTableOracle instance, where the construction "
"shows a different form."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:378
msgid ""
"As shown, the truthtable is specified with three length-8 bitstrings, "
"each containing the values of all entries for a particular output column "
"in the table. Each bitstring has length :math:`8`, so the truthtable has "
":math:`3` input bits; There are :math:`3` bitstrings, so the truthtable "
"has :math:`3` output bits."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:380
msgid ""
"The function :math:`f` represented by the truthtable is promised to be "
"either 1-to-1 or 2-to-1. Our goal is to determine which. For the case of "
"2-to-1, we also need to compute the mask :math:`\\mathbf{s}`, which "
"satisfies :math:`\\forall \\mathbf{x},\\mathbf{y}`: :math:`\\mathbf{x} "
"\\oplus \\mathbf{y} = \\mathbf{s}` iff :math:`f(\\mathbf{x}) = "
"f(\\mathbf{y})`. Apparently, if :math:`f` is 1-to-1, the corresponding "
"mask :math:`\\mathbf{s} = \\mathbf{0}`."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:382
msgid "Let us first compute the groundtruth mask :math:`\\mathbf{s}` classically:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:468
msgid ""
"We can also quickly try a truthtable that represents a 1-to-1 function "
"(i.e., the corresponding mask is :math:`\\mathbf{0}`), as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:523
msgid "Shor’s Factoring algorithm"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:525
msgid ""
"`Shor’s Factoring algorithm "
"<https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.Shor.html>`__"
" is one of the most well-known quantum algorithms and finds the prime "
"factors for input integer :math:`N` in polynomial time. The algorithm "
"implementation in Qiskit is simply provided a target integer to be "
"factored and run, as follows:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:570
msgid ""
"Note: this implementation of Shor’s algorithm uses :math:`4n + 2` qubits,"
" where :math:`n` is the number of bits representing the integer in "
"binary. So in practice, for now, this implementation is restricted to "
"factorizing small integers. Given the above value of N we compute "
":math:`4n +2` below and confirm the size from the actual circuit."
msgstr ""


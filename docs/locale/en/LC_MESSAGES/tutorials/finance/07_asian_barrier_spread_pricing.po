# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-05 21:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:10
msgid ""
"This page was generated from "
"`tutorials/finance/07_asian_barrier_spread_pricing.ipynb`__."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:9
msgid "**Pricing Asian Barrier Spreads**"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:21
msgid "Introduction"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:23
msgid ""
"An Asian barrier spread is a combination of 3 different option types, and"
" as such, combines multiple possible features that the Qiskit Finance "
"option pricing framework supports:"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:25
msgid ""
"Asian option: The payoff depends on the average price over the considered"
" time horizon."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:26
msgid ""
"Barrier Option: The payoff is zero if a certain threshold is exceeded at "
"any time within the considered time horizon."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:27
msgid ""
"(Bull) Spread: The payoff follows a piecewise linear function (depending "
"on the average price) starting at zero, increasing linear, staying "
"constant."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:29
msgid ""
"Suppose strike prices :math:`K_1 < K_2` and time periods :math:`t=1,2`, "
"with corresponding spot prices :math:`(S_1, S_2)` following a given "
"multivariate distribution (e.g. generated by some stochastic process), "
"and a barrier threshold :math:`B>0`. The corresponding payoff function is"
" defined as"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:31
msgid ""
"P(S_1, S_2) =\n"
"\\begin{cases}\n"
"\\min\\left\\{\\max\\left\\{\\frac{1}{2}(S_1 + S_2) - K_1, 0\\right\\}, "
"K_2 - K_1\\right\\}, & \\text{ if } S_1, S_2 \\leq B \\\\\n"
"0, & \\text{otherwise.}\n"
"\\end{cases}"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:40
msgid ""
"In the following, a quantum algorithm based on amplitude estimation is "
"used to estimate the expected payoff, i.e., the fair price before "
"discounting, for the option"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:42
msgid ""
"\\mathbb{E}\\left[ P(S_1, S_2) \\right].\n"
"\n"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:44
msgid ""
"The approximation of the objective function and a general introduction to"
" option pricing and risk analysis on quantum computers are given in the "
"following papers:"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:46
msgid "Quantum Risk Analysis. Woerner, Egger. 2018."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:47
msgid "Option Pricing using Quantum Computers. Stamatopoulos et al. 2019."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:104
msgid "Uncertainty Model"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:106
msgid ""
"We construct a circuit factory to load a multivariate log-normal random "
"distribution into a quantum state on :math:`n` qubits. For every "
"dimension :math:`j = 1,\\ldots,d`, the distribution is truncated to a "
"given interval :math:`[low_j, high_j]` and discretized using "
":math:`2^{n_j}` grid points, where :math:`n_j` denotes the number of "
"qubits used to represent dimension :math:`j`, i.e., "
":math:`n_1+\\ldots+n_d = n`. The unitary operator corresponding to the "
"circuit factory implements the following:"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:108
msgid ""
"\\big|0\\rangle_{n} \\mapsto \\big|\\psi\\rangle_{n} = "
"\\sum_{i_1,\\ldots,i_d} \\sqrt{p_{i_1\\ldots "
"i_d}}\\big|i_1\\rangle_{n_1}\\ldots\\big|i_d\\rangle_{n_d},\n"
"\n"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:110
msgid ""
"where :math:`p_{i_1\\ldots i_d}` denote the probabilities corresponding "
"to the truncated and discretized distribution and where :math:`i_j` is "
"mapped to the right interval using the affine map:"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:112
msgid ""
"\\{0, \\ldots, 2^{n_j}-1\\} \\ni i_j \\mapsto \\frac{high_j - "
"low_j}{2^{n_j} - 1} * i_j + low_j \\in [low_j, high_j].\n"
"\n"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:114
msgid ""
"For simplicity, we assume both stock prices are independent and "
"identically distributed. This assumption just simplifies the "
"parametrization below and can be easily relaxed to more complex and also "
"correlated multivariate distributions. The only important assumption for "
"the current implementation is that the discretization grid of the "
"different dimensions has the same step size."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:199
msgid "Payoff Function"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:201
msgid ""
"For simplicity, we consider the sum of the spot prices instead of their "
"average. The result can be transformed to the average by just dividing it"
" by 2."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:203
msgid ""
"The payoff function equals zero as long as the sum of the spot prices "
":math:`(S_1 + S_2)` is less than the strike price :math:`K_1` and then "
"increases linearly until the sum of the spot prices reaches :math:`K_2`. "
"Then payoff stays constant to :math:`K_2 - K_1` unless any of the two "
"spot prices exceeds the barrier threshold :math:`B`, then the payoff goes"
" immediately down to zero. The implementation first uses a weighted sum "
"operator to compute the sum of the spot prices into an ancilla register, "
"and then uses a comparator, that flips an ancilla qubit from "
":math:`\\big|0\\rangle` to :math:`\\big|1\\rangle` if :math:`(S_1 + S_2) "
"\\geq K_1` and another comparator/ancilla to capture the case that "
":math:`(S_1 + S_2) \\geq K_2`. These ancillas are used to control the "
"linear part of the payoff function."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:206
msgid ""
"In addition, we add another ancilla variable for each time step and use "
"additional comparators to check whether :math:`S_1`, respectively "
":math:`S_2`, exceed the barrier threshold :math:`B`. The payoff function "
"is only applied if :math:`S_1, S_2 \\leq B`."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:208
msgid ""
"The linear part itself is approximated as follows. We exploit the fact "
"that :math:`\\sin^2(y + \\pi/4) \\approx y + 1/2` for small :math:`|y|`. "
"Thus, for a given approximation scaling factor :math:`c_{approx} \\in [0,"
" 1]` and :math:`x \\in [0, 1]` we consider"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:210
msgid ""
"\\sin^2( \\pi/2 * c_{approx} * ( x - 1/2 ) + \\pi/4) \\approx \\pi/2 * "
"c_{approx} * ( x - 1/2 ) + 1/2\n"
"\n"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:212
msgid "for small :math:`c_{approx}`."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:214
msgid "We can easily construct an operator that acts as"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:216
msgid ""
"\\big|x\\rangle \\big|0\\rangle \\mapsto \\big|x\\rangle \\left( "
"\\cos(a*x+b) \\big|0\\rangle + \\sin(a*x+b) \\big|1\\rangle \\right),\n"
"\n"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:218
msgid "using controlled Y-rotations."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:220
msgid ""
"Eventually, we are interested in the probability of measuring "
":math:`\\big|1\\rangle` in the last qubit, which corresponds to "
":math:`\\sin^2(a*x+b)`. Together with the approximation above, this "
"allows to approximate the values of interest. The smaller we choose "
":math:`c_{approx}`, the better the approximation. However, since we are "
"then estimating a property scaled by :math:`c_{approx}`, the number of "
"evaluation qubits :math:`m` needs to be adjusted accordingly."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:222
msgid ""
"For more details on the approximation, we refer to: Quantum Risk "
"Analysis. Woerner, Egger. 2018."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:224
msgid ""
"Since the weighted sum operator (in its current implementation) can only "
"sum up integers, we need to map from the original ranges to the "
"representable range to estimate the result, and reverse this mapping "
"before interpreting the result. The mapping essentially corresponds to "
"the affine mapping described in the context of the uncertainty model "
"above."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:424
msgid "Evaluate Expected Payoff"
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:426
msgid ""
"We first verify the quantum circuit by simulating it and analyzing the "
"resulting probability to measure the :math:`|1\\rangle` state in the "
"objective qubit."
msgstr ""

#: ../../tutorials/finance/07_asian_barrier_spread_pricing.ipynb:538
msgid ""
"Next we use amplitude estimation to estimate the expected payoff. Note "
"that this can take a while since we are simulating a large number of "
"qubits. The way we designed the operator (asian\\_barrier\\_spread) "
"implies that the number of actual state qubits is significantly smaller, "
"thus, helping to reduce the overall simulation time a bit."
msgstr ""


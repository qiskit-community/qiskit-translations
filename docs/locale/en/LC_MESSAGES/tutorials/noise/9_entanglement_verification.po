# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-05 21:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:10
msgid ""
"This page was generated from "
"`tutorials/noise/9_entanglement_verification.ipynb`__."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:9
msgid "Entanglement Verification"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:12
msgid "Introduction to the GHZ state"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:14
msgid ""
"**The Greenberger-Horne-Zeilinger (GHZ)** State is a :math:`n`-qubit "
"entangled state best defined by the following state vector:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:16
msgid ""
"|{\\rm GHZ} \\rangle = \\frac{|0 \\rangle ^{\\otimes n} + |1 \\rangle "
"^{\\otimes n}}{\\sqrt{2}} , n > 2\n"
"\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:18
msgid ""
"Characterization of the GHZ state is very useful in assessing multi-qubit"
" interactions, whose robustness is key to developing large scale quantum "
"computers."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:21
msgid "Characterizing a quantum state"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:23
msgid ""
"Any mixed quantum state can be identified by a density matrix, defined as"
" $ :nbsphinx-math:`\\rho `= :nbsphinx-math:`\\Sigma`\\ *{i} p\\_i "
"\\|:nbsphinx-math:`\\psi`*\\ {i} :nbsphinx-math:`\\rangle `:nbsphinx-"
"math:`\\langle `:nbsphinx-math:`\\psi`\\_{i}\\| $, where "
":math:`|\\psi_{i} \\rangle` are the pure quantum states forming the "
"mixture and :math:`0 < p_i \\le 1`, :math:`\\Sigma_{i} p_i = 1` are the "
"classical probabilities to be in state :math:`|\\psi_{i} \\rangle`. We "
"denote the pure density matrix of an ideal GHZ State by :math:`\\rho_{p} "
"\\equiv |{\\rm GHZ} \\rangle \\langle {\\rm GHZ}|`. We want to see how "
"close this matrix is to the density matrix of a GHZ State as produced in "
"an experiment, :math:`\\rho_{T}`. One method to quantify this similarity "
"is to calculate the fidelity between the states, "
":math:`F(\\rho_{p},\\rho_{T})`"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:26
msgid ""
"F = \\Big[ Tr \\sqrt{\\sqrt{\\rho_{p}}\\rho_{T}\\sqrt{\\rho_{p}}} \\Big] "
"^{2}\n"
"\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:28
msgid ""
"The aim of this tutorial is two-fold: we will explore ways in which we "
"can characterize the GHZ state, and ways in which we can use Ignis' error"
" mitigation tools to increase readout fidelity, regardless of "
"characterization method"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:30
msgid ""
"Before we go further, let us import everything we will need from basic "
"Qiskit:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:64
msgid ""
"The next two functions are from ignis. The first is for the general error"
" mitigation technique, and the second is specifically for quantum "
"tomography"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:87
msgid ""
"The following import from the ``entanglement`` package contains "
"information needed to create, parallellize and analyze GHZ State circuits"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:111
msgid "Preparing a GHZ State"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:113
msgid "Let us first go over how to prepare a GHZ State:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:115
msgid ""
"Say we have a system of :math:`n` qubits, all prepared in the "
":math:`|0\\rangle` state:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:117
msgid ""
"|\\psi \\rangle = |00...0\\rangle\n"
"\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:119
msgid ""
"We apply a Hadamard gate to the first qubit: :math:`|0\\rangle "
"\\longrightarrow \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)`. Our "
"state now looks like:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:121
msgid ""
"|\\psi \\rangle = \\frac{|00...0\\rangle + |10...0\\rangle}{\\sqrt{2}}\n"
"\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:123
msgid ""
"Applying on this state a sequence of :math:`n-1` CNOT gate between the "
":math:`n^{th}` and :math:`(n+1)^{th}` qubits for :math:`n = 0 \\ldots "
"n-1` leaves the :math:`n+1` qubit at :math:`|0\\rangle` if the "
":math:`n^{th}` is in :math:`|0\\rangle`, and at :math:`|1\\rangle` if the"
" :math:`n^{th}` is in :math:`|1\\rangle`, thus creating the GHZ State:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:125
msgid ""
"|GHZ \\rangle = \\frac{|00...0\\rangle + |11...1\\rangle}{\\sqrt{2}} "
"\\equiv \\frac{|0 \\rangle ^{\\otimes n} + |1 \\rangle ^{\\otimes "
"n}}{\\sqrt{2}}\n"
"\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:127
msgid ""
"The following function creates this \"linear\" circuit that can measure "
"the GHZ state:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:169
msgid "Characterization, Part I"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:172
msgid "Multiple Quantum Coherence (MQC)"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:174
msgid ""
"Multiple Quantum Coherence (MQC) works by taking the preliminary "
"preparation of an :math:`n` qubit GHZ State, and rotating each of the "
"qubit states around the z axis by a phase :math:`\\phi`. After that, we "
"apply a X gate, i.e., a :math:`\\pi` pulse around the x axis. Then, we "
"apply the inverse of the operations we originally applied to get the GHZ "
"state. In an ideal situation the final state is :math:`|\\psi \\rangle = "
"\\frac{|0 \\rangle ^{\\otimes n} + e^{i n \\phi}|1 \\rangle ^{\\otimes "
"n}}{\\sqrt{2}}`. We can ideally observe the phase collected by projecting"
" :math:`|\\psi \\rangle` onto the state $\\|0 :nbsphinx-math:`\\rangle "
"`^{:nbsphinx-math:`\\otimes `n} $. This technique is reminiscent of an "
"echo sequence, and has been shown to substantially improve the fidelity "
"during readout."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:177
msgid ""
"The function below creates a linear MQC circuit. As with every circuit "
"from here on, you can change the ``full_measurement`` argument to toggle "
"between full measurement of all qubits or measurement of only the control"
" qubit. Full measurement yields the most accurate results, but for more "
"than 7 qubits, it is recommended to set it to false, and observe only the"
" oscillations between the ``'0'`` and ``'1'`` states."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:217
msgid ""
"After running experiments on this MQC circuit, we can pick a state to "
"observe oscillations as we sweep :math:`\\phi` from :math:`0` to :math:`2"
" \\pi`. Our signal in theory should follow :math:`S(\\phi) = "
"\\frac{1}{2}(1+cos(n \\phi))`. We then perform a Discrete Fourier "
"Transform (DFT: :math:`I_{v}=(1/N)|\\Sigma_{\\phi}e^{iv\\phi}S(\\phi)`) "
"to extract the Fidelity of the state, defined by the bounds "
":math:`2\\sqrt{I_{n}} \\leq F \\leq \\sqrt{I_{0}/2}+ \\sqrt{I_{n}}`; if "
"desired, an actual value for the fidelity can be obtained: :math:`F = "
"\\frac{1}{2}(P_{00...0}+P_{11...1})+\\sqrt{I_{n}})` (arXiv:1905.05720)."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:230
msgid "Parity Oscillations"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:232
msgid ""
"The next method we use to characterize the GHZ state is parity "
"oscillations. After preparing a GHZ state, we apply a combination of "
"rotations about the x and y axes to create various superposition states "
"as a function of :math:`\\phi`: :math:`U(\\phi) = \\otimes_{j}^{N} "
"e^{i\\frac{\\pi}{4}(cos(\\phi)\\sigma_{x}^{j}+sin(\\phi)\\sigma_{y}^{j})}`."
" We then measure the expectation value :math:`\\langle \\otimes_{j}^{N} "
"\\sigma_{z}^{j} \\rangle_{\\phi}` as a function of :math:`\\phi`, which "
"in theory should lead to parity oscillations between 1 and -1."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:235
msgid ""
"The following function generates a circuit which is the Parity "
"Oscillation equivalent of the MQC circuit given above"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:275
msgid ""
"We can obtain fidelity for parity oscillations :math:`S_{\\phi}` from "
":math:`F = \\frac{1}{2}(P_{00...0}+P_{11...1}+C)`, where :math:`C`, the "
"coherence is defined as :math:`2\\sqrt{I_{n}}`, following the same "
"convention for the DFT as with the MQC method."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:287
msgid "Tomography"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:289
msgid ""
"Tomography measures the density matrix by producing many nominally "
"identical states and measuring the state instances in different bases. "
"The ideal result of a GHZ state is four equal density matrix elements at "
"the 4 corners of the tensor-product basis, with all other elements "
"vanishing. Although the fidelity can be readily calculated by this "
"method, the method is slow (requires exponential number of measurements "
"in n), and takes prohibitively long times if n is larger than 7 or so. "
"Nevertheless, we will show below how to perform this method as it is "
"relevant for small numbers of qubits."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:302
msgid "Parallelizing circuits"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:304
msgid ""
"The above \"linear\" circuits are good to perform simulations, but what "
"do we do when we use real devices, where the system can have an arbitrary"
" topology and various errors? We are specifically targeting real hardware"
" here, not just Aer simulation. One technique to reduce real-hardware "
"effects is to parallelize the CNOT gates and thus create a shorter-depth "
"circuit. This can be hugely beneficial efficiency wise, and fidelity "
"wise. The class ``BConfig`` from the module ``parallelize`` does exactly "
"this."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:307
msgid ""
"First we must configure the optimal backend we want to use. We will "
"consider a simulation backend, ``'ibmq_qasm_simulator'``, disguised as a "
"real device, ``'ibmq_16_melbourne'`` by using a the mock backend "
"``'FakeMelbourne'``"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:331
msgid ""
"Using the ``noise`` module, we can now define a noise model from "
"``'ibmq_16_melbourne'`` to \"assign\" to ``'ibmq_qasm_simulator'``."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:354
msgid ""
"And there we have it. From now on, in the tutorial, when using a real "
"device, not a simulation, just take out every mention and assignment of "
"``noise_model`` and ``coupling_map``, and assign the real device to "
"``backend``. The simulator used from now on is no substitute for running "
"a real device."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:365
msgid ""
"``BConfig`` lays the blueprint for creating paralellized circuits. Let us"
" initialize an object taking in the real device we just defined, and name"
" it ``protocirc``. All of our experiments will use it:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:387
msgid "Error Mitigation"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:389
msgid ""
"Qiskit Ignis provides very accurate tools to take raw data and return "
"calibrated data. This is done by getting the raw data, in the form of a "
"vector :math:`v_{raw}` and getting a calibration matrix :math:`A`. The "
"output is then the solution to the optimization problem: "
":math:`argmin_{v_{cal}} ||Av_{cal}-v_{raw}||^{2}`"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:401
msgid "Experiment Time"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:404
msgid "Preliminary Steps"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:406
msgid ""
"The probabilities of measuring :math:`|0\\rangle ^{\\otimes n}` and "
":math:`|1\\rangle^{\\otimes n}` in the GHZ state are important in "
"calculating fidelity. For this, we need to run the following test"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:417
msgid "We begin by defining standard execution parameters:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:815
msgid "Now with error mitigation:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:945
msgid "We will load these values in a dictionary for assessing fidelity later on:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:967
msgid "Part 1 : MQC"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:969
msgid "We now retrieve a parallellized MQC circuit for the n qubit device"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1025
msgid "We now execute the MQC experiment:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1068
msgid ""
"Now we will plot the amount of counts measured for :math:`|0 \\rangle "
"^{\\otimes n}` as a function of phase. It is important to note that when "
"using a parametrized circuit like the one here, the method "
"``get_counts()`` accepts an **index** and not a **circuit**. In any other"
" type of experiment, ``get_counts()`` accepts a **circuit**."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1099
msgid ""
"Now we get started on error mitigation. We create an identical quantum "
"register and use complete\\_meas\\_cal from Ignis, to create circuits for"
" calibrated measurements to be excecuted, and a calibration matrix."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1165
msgid "Finally, we have our error mitigated results:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1186
msgid ""
"We can see how the error mitigated results yield a far greater fidelity "
"than the raw data"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1301
msgid ""
"We now plot the DFT and compare the heights of the peaks to give bounds "
"for the fidelity"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1312
msgid ""
"Statistical bootstrapping has found that the error on these measurements "
"is at most 1.5% (arXiv 1905.05720), so these result fall within error "
"bounds, despite the fidelity being slightly higher than the upper bound, "
"and show how error mitigation dramatically increases fidelity"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1324
msgid "Part 2: Parity Oscillation"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1326
msgid ""
"We now retrieve a parallellized Parity Oscillation circuit for the n "
"qubit device, and run experiments in the same fashion as we did in MQC."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1415
msgid ""
"Now we construct the :math:`\\otimes _{j}^{N} \\sigma_z^{j}` matrix for "
"instruction, although this is already taken into account in the following"
" method, ``entanglement.analysis.composite_pauli_z_expvalue()``:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1438
msgid ""
"Now we want to make sure that our list of counts is correctly ordered so "
"that it coincides with the states of the :math:`\\otimes _{j}^{N} "
"\\sigma_z^{j}`, so that calculating :math:`\\langle \\otimes _{j}^{N} "
"\\sigma_z^{j} \\rangle` will be as simple as taking the dot product of "
"this ordered list with the diagonal of :math:`\\otimes _{j}^{N} "
"\\sigma_z^{j}`. The ``composite_pauli_z_expvalue`` function does just "
"that; it takes a circuit and appropriately orders the state vector "
"counts. We can plot this dot product as a function of :math:`\\phi` to "
"observe parity oscillations."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1489
msgid "Now for standard error mitigation:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1584
msgid ""
"We can see how error mitigation dramatically improves our measurement "
"(much more so in PO than in MQC). Let us quantify this using the same DFT"
" method we used in MQC, and calulating the actual fidelities:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1662
msgid ""
"As we see, the raw fidelity is much lower than what is acheived with MQC,"
" but the error mitigated result is about the same."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1674
msgid "Part 3: Tomography"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1676
msgid ""
"The first step in this experiment to just pass a simple GHZ state with "
"*no* measurements. Also, the circuit cannot be transpiled; the "
"``transpiled`` argument in the ``getGHZChecker()`` method can be turned "
"on and off as is shown"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1711
msgid ""
"We now pass a simulated backend from ``Aer`` to get theoretical "
"statevector counts"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1754
msgid ""
"This following code runs tomography experiments on the circuit we defined"
" first, which is then compared to the theortical statevector to generate "
"a density matrix"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1806
msgid ""
"From here we can get the fidelity, although this method is not as fool "
"proof as the one we will get to eventually:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1852
msgid "...And now for error mitigation..."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1930
msgid ""
"Now, using ``qiskit.visualization``, we can plot the raw density matrix, "
"real, and imiginary parts being on separate plots,..."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1960
msgid "And also the error mitigated density matrix,..."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1990
msgid ""
"The actual density matrices can be obtained using the ``fit()`` method. "
"Once we have the density matrix, we can compute the fidelity, which is "
"nothing but half the sum of the four corners of the density matrix; the "
"following method helps us:"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2064
msgid ""
"As we see, the raw fidelity is much lower than what is acheived with "
"either MQC or Parity Oscillations, but the error mitigated result is "
"about the same."
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2066
msgid "**A note on tomography**"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2068
msgid "Do not perform quantum tomography with >5 qubits"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2080
msgid "Conclusion"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2082
msgid ""
"In conclusion, we see that without error mitigation, MQC is the superior "
"method for characterizing the GHZ state. However, with error mitigation, "
"all methods can, at least for a small number of qubits, acheive a much "
"greater fidelity, and all near the same value. To get more accurate "
"results, aside from using a real device, it is worth increasing the "
"number of shots four to eight-fold. It may be worth comparing how the "
"parallellized circutis used in this notebook perform fidelity-wise versus"
" linearized circuits."
msgstr ""


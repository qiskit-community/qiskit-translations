msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-02 15:42+0000\n"
"PO-Revision-Date: 2020-10-02 16:16\n"
"Last-Translator: \n"
"Language-Team: Korean\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/chemistry/1_programmatic_approach.po\n"
"X-Crowdin-File-ID: 9288\n"
"Language: ko_KR\n"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:10
msgid "This page was generated from `tutorials/chemistry/1_programmatic_approach.ipynb`__."
msgstr "이 페이지는 `tutorials/chemistry/1_programmatic_approach.ipynb`__ 에서 생성되었다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:9
msgid "**Qiskit Chemistry, Programmatic Approach**"
msgstr "**키스킷 화학(Qiskit Chemistry), 프로그램적 접근법**"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:21
msgid "Introduction"
msgstr "도입"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:23
msgid "This notebook illustrates how to use Qiskit Chemistry's programmatic APIs."
msgstr "이 노트북은 키스킷 화학의 프로그램 API를 사용하는 방법을 설명한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:25
msgid "In this notebook, we decompose the computation of the ground state energy of a molecule into 4 steps: 1. Define a molecule and get integrals from a computational chemistry driver (PySCF in this case) 2. Construct a Fermionic Hamiltonian and map it onto a qubit Hamiltonian 3. Instantiate and initialize dynamically-loaded algorithmic components, such as the quantum algorithm VQE, the optimizer and variational form it will use, and the initial\\_state to initialize the variational form 4. Run the algorithm on a quantum backend and retrieve the results"
msgstr "이 노트북에서 분자의 바닥 상태 에너지의 계산을 4단계로 분해한다. 1. 분자를 정의하고 계산 화학 드라이버로부터 적분을 얻는다. (이 경우에는 PySCF) 2. 페르미오닉 해밀토안(Fermionic Hamiltonian) 을 구성하고, 그것을 큐비트 해밀토니안에 사상한다. 3. 양자 알고리즘 VQE, 사용할 최적화 프로그램 및 변형 양식, 변형 양식을 초기화하는 초기 상태(initial\\_state) 와 같이 동적으로 로드된 알고리즘 구성 요소를 만들고, 초기화 한다. 4. 양자 후위 처리 장치에서 알고리즘을 구현하고, 결과를 추출한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:63
msgid "Step 1: Define a molecule"
msgstr "단계 1: 분자 정의"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:65
msgid "Here, we use LiH in the sto3g basis with the PySCF driver as an example. The ``molecule`` object records the information from the PySCF driver."
msgstr "여기에서, 예로서 PySCF 드라이버로 sto3g 기저에서 LiH를 사용한다. 이 ``분자`` 객체는 PySCF 드라이버로 부터의 정보를 기록한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:91
msgid "Step 2: Prepare qubit Hamiltonian"
msgstr "2단계: 큐비트 해밀토니안 준비"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:93
msgid "Here, we setup the **to-be-frozen** and **to-be-removed** orbitals to reduce the problem size when we map to the qubit Hamiltonian. Furthermore, we define the **mapping type** for the qubit Hamiltonian. For the particular ``parity`` mapping, we can further reduce the problem size."
msgstr "여기서는 큐비트 해밀토니안으로 사상할 때, 문제 크기를 줄이기 위해서 **to-be-frozen**과 **to-be-removed** 궤도(orbitals) 을 설정한다. 더욱이 큐비트 해밀토니안을 위해 **사상 형식(mapping type)**을 정의한다. 특정 ``패리티(parity)`` 사상을 위해서 문제 크기를 더 많이 줄일 수 있다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:409
msgid "We use the classical eigen decomposition to get the smallest eigenvalue as a reference."
msgstr "가장 작은 고유치 (eigenvalue) 를 얻기 위해서 전통적인 고유치 분해법을 사용한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:456
msgid "Step 3: Initiate and configure dynamically-loaded instances"
msgstr "3단계: 동적으로 로드된 인스턴스의 시작 및 구성"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:458
msgid "To run VQE with the UCCSD variational form, we require:"
msgstr "VQE를 UCCSD 변형 양식으로 사용하는 방법은 다음과 같다:"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:460
msgid "VQE algorithm"
msgstr "VQE 알고리즘"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:461
msgid "Classical Optimizer"
msgstr "고전적 최적화 프로그램"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:462
msgid "UCCSD variational form"
msgstr "UCCSD 변형 양식"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:463
msgid "Prepare the initial state in the HartreeFock state"
msgstr "하트리∙폭 (HartreeFock) 상태에서 초기 상태 준비하기"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:475
msgid "[Optional] Setup token to run the experiment on a real device"
msgstr "[Optional] 실제 장치에서 실험을 실행하려면 토큰을 설정해야 한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:477
msgid "If you would like to run the experiment on a real device, you need to setup your account first."
msgstr "실제 장치에서 실험을 실행하려면 먼저 계정을 설정해야 한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:479
msgid "Note: If you did not store your token yet, use ``IBMQ.save_account('MY_API_TOKEN')`` to store it first."
msgstr "참고: 토큰을 저장하지 않은 경우에는 ``IBMQ.save_account(MY_API_TOKEN)`` 를 사용하여 먼저 저장한다."

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:538
msgid "Step 4: Run algorithm and retrieve the results"
msgstr "4단계: 알고리즘 실행 및 결과 추출"

#: ../../tutorials/chemistry/1_programmatic_approach.ipynb:549
msgid "results = vqe.run(quantum\\_instance) print('The computed ground state energy is: {:.12f}'.format(results.eigenvalue.real)) print('The total ground state energy is: {:.12f}'.format(results.eigenvalue.real + energy\\_shift + nuclear\\_repulsion\\_energy)) print(\"Parameters: {}\".format(results.optimal\\_point))"
msgstr ""


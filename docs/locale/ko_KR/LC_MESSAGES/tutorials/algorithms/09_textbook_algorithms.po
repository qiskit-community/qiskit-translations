msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-07 16:27+0000\n"
"PO-Revision-Date: 2020-12-20 03:36\n"
"Last-Translator: \n"
"Language-Team: Korean\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/algorithms/09_textbook_algorithms.po\n"
"X-Crowdin-File-ID: 9460\n"
"Language: ko_KR\n"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:10
msgid "This page was generated from `tutorials/algorithms/09_textbook_algorithms.ipynb`__."
msgstr "이 페이지는 `tutorials/algorithms/09_textbook_algorithms.ipynb`__ 에서 생성되었다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:12
msgid "Run interactively in the `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/algorithms/09_textbook_algorithms.ipynb>`_."
msgstr "`IBM 퀀텀 랩 <https://quantum-computing.ibm.com/jupyter/tutorial/algorithms/09_textbook_algorithms.ipynb>`_ 에서 대화식으로 실행하시오."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:9
msgid "Textbook and Shor’s algorithms"
msgstr "사용 지침서와 쇼어 알고리즘"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:11
msgid "Qiskit contains implementations of the well known textbook quantum algorithms such as the `Deutsch-Jozsa algorithm <https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html>`__, the `Bernstein-Vazirani algorithm <https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html>`__ and `Simon’s algorithm <https://qiskit.org/textbook/ch-algorithms/simon.html>`__."
msgstr "키스킷에서는 `Deutsch-Jozsa algorithm <https://qiskit.org/textbook/ch-algorithms/deutsch-jozsa.html>`__, `Bernstein-Vazirani algorithm <https://qiskit.org/textbook/ch-algorithms/bernstein-vazirani.html>`__ 및 `Simon’s algorithm <https://qiskit.org/textbook/ch-algorithms/simon.html>`__ 과 같이 잘 알려진 양자 알고리즘들을 구현해두어 포함하고 있다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:13
msgid "Qiskit also has an implementation of `Shor’s algorithm <https://qiskit.org/textbook/ch-algorithms/shor.html>`__."
msgstr "키스킷에는 `Shor’s algorithm <https://qiskit.org/textbook/ch-algorithms/shor.html>`__ 이 구현되어 있다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:15
msgid "The preceding references have detailed explanations and build-out of circuits whereas this notebook has examples with the pre-built algorithms in Qiskit that you can use for experimentation and education purposes."
msgstr "이전 참조들은 회로들의 상세한 설명들 및 구축-아웃 (build-out of circuits) 을 가지는 반면, 이 노트북은 실험 및 교육 목적으로 사용할 수 있는 Qiskit 에서 사전에 구현된 알고리즘들을 갖는 예들을 갖는다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:42
msgid "Deutsch-Jozsa algorithm"
msgstr "도이체-조자 (Deutsch-Jozsa) 알고리즘"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:44
msgid "Lets start with the `Deutsch-Jozsa algorithm <https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.DeutschJozsa.html>`__ which can determine if a function is ``'balanced'`` or ``'constant'`` given such a function as input. We can experiment with it in Qiskit using an oracles created from a truth tables. So for example, we can create a ``TruthTableOracle`` instance as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:66
msgid "As shown, the truthtable is specified with the ``bitstr`` containing values of all entries in the table. It has length :math:`8`, so the corresponding truth table is of :math:`3` input bits. We can of course see that this truth table represents a ``'balanced'`` function as half of values are :math:`1` and the other half :math:`0`."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:68
msgid "It might seem like a moot point running Deutsch-Jozsa on a truthtable as the function outputs are literally listed as the truthtable’s values. The intention is to create an oracle circuit whose groundtruth information is readily available to us but obviously not to the quantum Deutsch-Jozsa algorithm that is to act upon the oracle circuit. In more realistic situations, the oracle circuit would be provided as a blackbox to the algorihtm."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:70
msgid "Above said, we can inspect the circuit corresponding to the function encoded in the ``TruthTableOracle`` instance."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:100
msgid "As seen, the :math:`v_i`\\ ’s correspond to the 3 input bits; the :math:`o_0` is the oracle’s output qubit; the :math:`a_0` is an ancilla qubit."
msgstr "보여지는 바와 같이, :math:\"v_i\" 는 3개의 입력 비트들에 대응하고, :math:'o_0' 는 oracle의 출력 쿼트이고, :math:'a_0' 는 언니크 (ancilla qubit) 이다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:102
msgid "Next we can simply create a ``DeutschJozsa`` instance using the oracle, and run it to check the result."
msgstr "다음으로, 우리는 단순히 oracle을 사용하여 ` ` DeutschJozsa ` 인스턴스를 생성하고, 이를 실행하여 결과를 확인할 수 있다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:145
msgid "We can of course quickly put together another example for a ``'constant'`` function, as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:191
msgid "Bernstein-Vazirani algorithm"
msgstr "번스타인-바조니 (Bernstein-Vazirani) 알고리즘"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:193
msgid "Next the `Bernstein-Vazirani algorithm <https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.BernsteinVazirani.html>`__ which tries to find a hidden string. Again, for the example, we create a TruthTableOracle instance."
msgstr "그 다음에는 숨겨진 끈을 찾으려는 '베르테신-바자이라니 알고리즘 <https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.BernsteinVazirani.html>'. 예를 들어, 이 예제에서는 TruthTableOracle 인스턴스를 작성한다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:215
msgid "As shown, the truthtable is specified with the ``bitstr`` containing values of all entries in the table. It has length :math:`8`, so the corresponding truth table is of :math:`3` input bits. The truthtable represents the function mappings as follows:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:217
msgid ":math:`\\mathbf{a} \\cdot 000 \\mod 2 = 0`"
msgstr ":math:`\\mathbf{a} \\cdot 000 \\mod 2 = 0`"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:218
msgid ":math:`\\mathbf{a} \\cdot 001 \\mod 2 = 0`"
msgstr ":math:`\\mathbf{a} \\cdot 001 \\mod 2 = 0`"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:219
msgid ":math:`\\mathbf{a} \\cdot 010 \\mod 2 = 1`"
msgstr ":math:` \\mathbf{a} \\cdot 010 \\mod 2 = 1 `"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:220
msgid ":math:`\\mathbf{a} \\cdot 011 \\mod 2 = 1`"
msgstr ":math:` \\mathbf{a} \\cdot 011 \\mod 2 = 1 `"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:221
msgid ":math:`\\mathbf{a} \\cdot 100 \\mod 2 = 1`"
msgstr ":math:`\\mathbf{a} \\cdot 100 \\mod 2 = 1`"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:222
msgid ":math:`\\mathbf{a} \\cdot 101 \\mod 2 = 1`"
msgstr ":math:` \\mathbf{a} \\cdot 101 \\mod 2 = 1 `"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:223
msgid ":math:`\\mathbf{a} \\cdot 110 \\mod 2 = 0`"
msgstr ":math:` \\mathbf{a} \\cdot 110 \\mod 2 = 0 `"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:224
msgid ":math:`\\mathbf{a} \\cdot 111 \\mod 2 = 0`"
msgstr ":math:` \\mathbf{a} \\cdot 111 \\mod 2 = 0 `"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:226
msgid "And obviously the goal is to find the bitstring :math:`\\mathbf{a}` that satisfies all the inner product equations."
msgstr "그리고 목표는 모든 내부 제품 방정식을 만족시키는 비트스트링 :math:'\\mathbf{a}' 를 찾는 것이다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:228
msgid "Lets again look at the oracle circuit, that now corresponds to the binary function encoded in the ``TruthTableOracle`` instance."
msgstr "oracle 회로를 다시 살펴보면, 이제 ` ` TruthTableOracle ` 인스턴스에 인코딩된 2진 함수에 해당한다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:258
msgid "Again the :math:`v_i`\\ ’s correspond to the 3 input bits; the :math:`o_0` is the oracle’s output qubit; the :math:`a_0` is an ancilla qubit."
msgstr "다시, :math:의 \"v_i\" 는 3개의 입력 비트들에 대응하고, :math:'o_0' 는 oracle의 출력 쿼트이고, :math:'a_0' 는 언실라 (ancilla qubit) 이다."

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:260
msgid "Let us first compute the groundtruth :math:`\\mathbf{a}` classically:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:305
msgid "Next we can create a ``BernsteinVazirani`` instance using the oracle, and run it to check the result against the groundtruth."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:350
msgid "Simon’s algorithm"
msgstr "사이먼의 알고리즘"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:352
msgid "`Simon’s algorithm <https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.Simon.html>`__ is used to solve `Simon’s problem <https://en.wikipedia.org/wiki/Simon's_problem>`__. Once again, for the example, we create a TruthTableOracle instance, where the construction shows a different form."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:378
msgid "As shown, the truthtable is specified with three length-8 bitstrings, each containing the values of all entries for a particular output column in the table. Each bitstring has length :math:`8`, so the truthtable has :math:`3` input bits; There are :math:`3` bitstrings, so the truthtable has :math:`3` output bits."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:380
msgid "The function :math:`f` represented by the truthtable is promised to be either 1-to-1 or 2-to-1. Our goal is to determine which. For the case of 2-to-1, we also need to compute the mask :math:`\\mathbf{s}`, which satisfies :math:`\\forall \\mathbf{x},\\mathbf{y}`: :math:`\\mathbf{x} \\oplus \\mathbf{y} = \\mathbf{s}` iff :math:`f(\\mathbf{x}) = f(\\mathbf{y})`. Apparently, if :math:`f` is 1-to-1, the corresponding mask :math:`\\mathbf{s} = \\mathbf{0}`."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:382
msgid "Let us first compute the groundtruth mask :math:`\\mathbf{s}` classically:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:468
msgid "We can also quickly try a truthtable that represents a 1-to-1 function (i.e., the corresponding mask is :math:`\\mathbf{0}`), as follows."
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:523
msgid "Shor’s Factoring algorithm"
msgstr "쇼어의 소인수분해 알고리즘"

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:525
msgid "`Shor’s Factoring algorithm <https://qiskit.org/documentation/stubs/qiskit.aqua.algorithms.Shor.html>`__ is one of the most well-known quantum algorithms and finds the prime factors for input integer :math:`N` in polynomial time. The algorithm implementation in Qiskit is simply provided a target integer to be factored and run, as follows:"
msgstr ""

#: ../../tutorials/algorithms/09_textbook_algorithms.ipynb:570
msgid "Note: this implementation of Shor’s algorithm uses :math:`4n + 2` qubits, where :math:`n` is the number of bits representing the integer in binary. So in practice, for now, this implementation is restricted to factorizing small integers. Given the above value of N we compute :math:`4n +2` below and confirm the size from the actual circuit."
msgstr ""


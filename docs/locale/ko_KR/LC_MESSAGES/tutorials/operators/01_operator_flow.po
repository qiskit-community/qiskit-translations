msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-16 11:25+0000\n"
"PO-Revision-Date: 2023-03-16 11:58\n"
"Last-Translator: \n"
"Language: ko\n"
"Language-Team: Korean\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "이 페이지는 `tutorials/operators/01_operator_flow.ipynb`__ 에서 생성되었다."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "연산자 플로우 (Operator Flow)"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "소개"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit은 상태와 연산자와 그들의 합, 텐서 곱, 그리고 그들의 합성을 나타내는 클래스들을 제공한다. 이런 대수적 구조들은 연산자들을 나타내는 표현을 빌드할 수 있도록 해 준다."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Pauli 연산자(Pauli operators)로부터 빌드되는 표현을 소개한다. 후속 절에서는 연산자와 상태, 그들이 어떻게 표현되는지, 그리고 그들로 무엇을 할 수 있는지 더 상세하게 알아본다. 마지막 절에서는 해밀토니안을 따라 변화(time-evolution)하는 상태를 구성하고, 관측가능량(observable)의 기댓값을 계산할 것이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Pauli 연산자, 합계, 합성 및 텐서 곱"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "가장 중요한 기반 연산자는 Pauli 연산자이다. Pauli 연산자는 다음과 같이 표현된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:76
msgid "These operators may also carry a coefficient."
msgstr "이 연산자들은 계수 또한 가져갈 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:125
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "이 계수들은 연산자들을 합계의 항들로 사용할 수 있도록 해준다."

#: ../../tutorials/operators/01_operator_flow.ipynb:173
msgid "Tensor products are denoted with a caret, like this."
msgstr "텐서 곱은 이와 같이 캐럿(caret)으로 표시된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:218
msgid "Composition is denoted by the ``@`` symbol."
msgstr "합성은 ``@`` 기호로 표시된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:263
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "앞의 두 예에서, Pauli 연산자들의 텐서 곱과 합성은 즉각 동등한 (다수의 큐비트일 가능성이 있는) Pauli 연산자로 줄여 표현되었다. 텐서 곱과 합성이 포함된 더 복잡한 객체의 경우, 결과는 평가 전의 연산들(unevaluated operations)을 나타내는 객체가 된다. 즉, 대수적 표현으로 나타난다."

#: ../../tutorials/operators/01_operator_flow.ipynb:274
msgid "For example, composing two sums gives"
msgstr "예를 들어, 두 합의 합성은 다음을 주고"

#: ../../tutorials/operators/01_operator_flow.ipynb:328
msgid "And tensoring two sums gives"
msgstr "두 합의 텐서 곱은 다음을 준다"

#: ../../tutorials/operators/01_operator_flow.ipynb:382
msgid "Let's take a closer look at the types introduced above. First the Pauli operators."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:428
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "각 Pauli 연산자는 ``PauliOp`` 인스턴스로써 ``qiskit.quantum_info.Pauli`` 인스턴스를 래핑하고, 계수 ``coeff`` 를 갖는다. 일반적으로 ``PauliOp`` 는 Pauli 연산자의 가중 텐서 곱을 나타낸다."

#: ../../tutorials/operators/01_operator_flow.ipynb:474
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Pauli 연산자를 불리언 값 쌍으로 인코딩하려면 ``qiskit.quantum_info.Pauli`` 문서를 참조하라."

#: ../../tutorials/operators/01_operator_flow.ipynb:476
msgid "All of the objects representing operators, whether as \"primitive\"s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:530
msgid "In the following we take a broader and deeper look at Qiskit's operators, states, and the building blocks of quantum algorithms."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:542
msgid "Part I: State Functions and Measurements"
msgstr "파트 I: 상태 함수 및 측정"

#: ../../tutorials/operators/01_operator_flow.ipynb:544
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "양자 상태는 ``StateFn`` 클래스의 하위 클래스로 표현될 수 있다. 양자 상태를 표현하는 4개의 하위 클래스는 다음과 같다: ``DictStateFn`` 은 ``dict`` 를 기반으로 한 계산 기저의 희소 표현이다. ``VectorStateFn`` 은 NumPy array를 기반으로 한 계산 기저의 밀집 표현이다. ``CircuitStateFn`` 은 회로를 기반으로, 계산 기저가 전부 0인 상태를 회로에 수행시켜 얻은 상태를 나타낸다. ``OperatorStateFn`` 은 밀도 행렬로 표현한 섞인 상태를 나타낸다. (나중에 확인하겠지만, ``OperatorStateFn`` 은 관측량을 나타낼 때도 사용된다.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:547
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "몇 개의 ``StateFn`` 인스턴스가 편의를 위해 제공된다. 예를 들어, ``Zero, One, Plus, Minus`` 이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:569
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "``Zero`` 와 ``One`` 은 각각 양자 상태 :math:`|0\\rangle` 와 :math:`|1\\rangle` 을 의미한다. 이들을 ``DictStateFn`` 을 통해 표현된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:614
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr ":math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` 와 :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` 상태를 표현하는 ``Plus`` 와 ``Minus`` 가 회로를 통해 표현되었다. ``H`` 는 ``Plus`` 를 나타내는 동의어이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:683
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "양자 상태들의 인덱싱은 ``eval`` 메서드로 수행할 수 있다. 아래의 코드는 ``0`` 과 ``1`` 의 기저 상태의 계수를 반환하는 예제이다. (아래에서 ``eval`` 메서드가 다른 계산에 이용되는 것도 확인할 것이다.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:744
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "양자 상태의 쌍대 벡터 (dual vector), 즉 주어진 *ket* 에 해당하는 *bra* 는 ``adjoint`` 메서드를 통해 얻어진다. ``StateFn`` 은 ``is_measurement`` 라는 플래그를 가지고 있는데, 이것은 해당 객체가 ket이면 ``False`` 이고 bra 이면 ``True`` 상태가 된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:755
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "여기서 :math:`\\langle 1 |` 을 구성한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:801
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "편의상, 이와 같이 틸데(tilde)를 이용하여 쌍대 벡터를 얻을 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:848
msgid "Algebraic operations and predicates"
msgstr "대수적 연산자들과 술어"

#: ../../tutorials/operators/01_operator_flow.ipynb:850
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including:"
msgstr "``StateFn``\\ 들 간에 다양한 대수적 연산과 술어가 지원된다:"

#: ../../tutorials/operators/01_operator_flow.ipynb:852
msgid "``+`` - addition"
msgstr "``+`` - 덧셈"

#: ../../tutorials/operators/01_operator_flow.ipynb:853
msgid "``-`` - subtraction, negation (scalar multiplication by -1)"
msgstr "``-`` - 뺄셈, 부정 (-1을 스칼라 곱)"

#: ../../tutorials/operators/01_operator_flow.ipynb:854
msgid "``*`` - scalar multiplication"
msgstr "``*`` - 스칼라 곱셈"

#: ../../tutorials/operators/01_operator_flow.ipynb:855
msgid "``/`` - scalar division"
msgstr "``/`` - 스칼라 나눗셈"

#: ../../tutorials/operators/01_operator_flow.ipynb:856
msgid "``@`` - composition"
msgstr "``@`` - 합성"

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "``^`` - tensor product or tensor power (tensor with self n times)"
msgstr "``^`` - 텐서 곱 또는 텐서 지수 (n 제곱 텐서)"

#: ../../tutorials/operators/01_operator_flow.ipynb:858
msgid "``**`` - composition power (compose with self n times)"
msgstr "``**`` - 합성 지수 (n번 합성)"

#: ../../tutorials/operators/01_operator_flow.ipynb:859
msgid "``==`` - equality"
msgstr "``==`` - 상등"

#: ../../tutorials/operators/01_operator_flow.ipynb:860
msgid "``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "``~`` - 수반, State Function 과 Measurement 사이에서 변동"

#: ../../tutorials/operators/01_operator_flow.ipynb:862
msgid "Be very aware that these operators obey the `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, which might not be what you expect mathematically. For example, ``I^X + X^I`` will actually be parsed as ``I ^ (X + X) ^ I == 2 * (I^X^I)`` because Python evaluates ``+`` before ``^``. In these cases, you can use the methods (``.tensor()``, etc) or parentheses."
msgstr "이 연산자들은 `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__ 을 따르며, 수학적으로 예상되는 결과가 아닐 수 있음에 주의하라. 예를 들어, ``I^X + X^I`` 는 정확히 ``I ^ (X + X) ^ I == 2 * (I^X^I)`` 에 해당하며 Python 은 ``^`` 전에 ``+`` 를 먼저 연산한다. 이런 경우에는 메서드(``.tensor()``, 등)나 괄호를 사용할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:873
msgid "``StateFn``\\ s carry a coefficient. This allows us to multiply states by a scalar, and so to construct sums."
msgstr "``StateFn``\\ 들은 계수를 지니고 있다. 이는 다중 상태들을 스칼라로 곱을 하여 합계를 만들 수 있게 해준다."

#: ../../tutorials/operators/01_operator_flow.ipynb:884
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "여기서는 :math:`(2 + 3i)|0\\rangle` 을 구성한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:930
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "여기에서는 두 개의 ``DictStateFn`` 을 더하는 것이 동일한 유형의 객체를 반환하는 것을 볼 수 있다: :math:`|0\\rangle + |1\\rangle`"

#: ../../tutorials/operators/01_operator_flow.ipynb:975
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "상태를 수동으로 정규화해야 하는 것에 유의하라. 예를 들어, :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` 를 구성하고자 아래와 같이 작성할 수 있다"

#: ../../tutorials/operators/01_operator_flow.ipynb:1023
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "다른 경우에는 결과가 합계의 심볼릭 표현으로 쓰여진다. 예를 들어, :math:`|+\\rangle + |-\\rangle` 의 표현은 다음과 같다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1101
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "합성 연산자는 내적을 수행할 때 사용될 수 있으며, 내적 값이 계산되지 않은 상태로 초기화된다. :math:`\\langle 1 | 1 \\rangle` 의 표현은 다음과 같다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1155
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "``is_measurement`` 플래그는 (브라) 상태 ``~One`` 이 ``DictMeasurement`` 에 출력되도록 했다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1166
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "심볼릭 표현은 ``eval`` 메서드로 값을 구할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1247
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "여기 :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle` 이 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1293
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "합성 연산자 ``@`` 는 ``compose`` 메서드를 호출하는 것과 동등하다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1347
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "내적은 ``ComposedOp`` 를 통해 구성하지 않고도 ``eval`` 메서드를 통해 바로 계산하는 것도 가능하다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1393
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "심볼릭 텐서 곱은 다음과 같이 만들어질 수 있다. 여기서는 :math:`|0\\rangle \\otimes |+\\rangle` 의 경우이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1459
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "이는 간단한 (합성되지 않은) ``CircuitStateFn`` 로 표현될 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "텐서 파워는 탈자 기호 ``^`` 를 사용하여 다음과 같이 구성된다. 여기 :math:`600 (|11111\\rangle + |00000\\rangle)` 와 :math:`|10\\rangle^{\\otimes 3}` 이 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1571
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "``to_matrix_op`` 는 ``VectorStateFn`` 으로 변환된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1672
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "StateFn을 생성하는 것은 쉽다. ``StateFn`` 은 팩토리로도 제공되며, 어떤 원시 자료형이라도 생성자에서 받을 수 있으며, 정확한 StateFn 하위 클래스를 반환할 수 있다. 현재 다음과 같은 원시 자료형을 생성자로 전달할 수 있으며, 이는 그들이 생성하는 ``StateFn`` 하위 클래스들과 나란히 나열되어 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1674
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (일부 기저 비트 문자열과 동일) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1675
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1676
msgid "Qiskit Result object -> DictStateFn"
msgstr "Qiskit Result object -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1677
msgid "list -> VectorStateFn"
msgstr "list -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1678
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1679
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1680
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1681
msgid "Instruction -> CircuitStateFn"
msgstr "Instruction -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1682
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase -> OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1764
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "파트 II: ``PrimitiveOp``\\ 들"

#: ../../tutorials/operators/01_operator_flow.ipynb:1766
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "기본 연산자들은 ``PrimitiveOp`` 의 하위 클래스이다. ``StateFn`` 과 마찬가지로 ``PrimitiveOp`` 는 주어진 원시 자료형에 올바른 자료형을 생성하기 위한 팩토리이기도 하다. 지금은 다음의 원시 자료형들이 생성자를 통해 ``PrimitiveOp`` 의 하위 클래스로서 만들어 질 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1768
msgid "Terra's Pauli -> PauliOp"
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:1769
msgid "Instruction -> CircuitOp"
msgstr "Instruction -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1770
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1771
msgid "2d List -> MatrixOp"
msgstr "2d List -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1772
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1773
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1774
msgid "Terra's quantum_info.Operator -> MatrixOp"
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:1796
msgid "Matrix elements"
msgstr "행렬 원소"

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "``eval`` 메서드는 연산자의 열을 반환한다. 예를 들어서 파울리 :math:`X` 연산자는 ``PauliOp`` 로 표현되어 있다. 열을 요청하는 것은 객체의 희소 표현 ``DictStateFn`` 을 반환한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1887
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "연산자에 인덱싱을 하는 것, 즉 행렬의 원소를 얻는 것은 ``eval`` 메서드를 두 번 호출하는 것으로 수행할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1898
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "행렬  :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)` 이 주어지면, 행렬의 원소 :math:`\\left\\{X \\right\\}_{0,1}` 는 다음과 같이 구할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:1944
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "여기에 회로로 표현된 두 큐비트 연산자 ``CX`` (제어 ``X``) 를 사용한 예시가 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2088
msgid "Applying an operator to a state vector"
msgstr "상태 벡터에 연산자 적용하기"

#: ../../tutorials/operators/01_operator_flow.ipynb:2099
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "상태 벡터에 연산자를 가하는 것은 ``compose`` 메서드를 통해 할 수 있다 (``@`` 연산자도 가능하다). :math:`X | 1 \\rangle = |0\\rangle` 라는 표현은 다음과 같다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2153
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "더 간단한 표현으로, :math:`|0\\rangle`의 ``DictStateFn`` 표현은 ``eval`` 메서드로 얻을 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2199
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "``eval`` 을 직접적으로 사용함으로써 중간 단계인 ``ComposedOp`` 을 건너뛸 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2245
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "연산자의 합성 및 텐서곱은 ``@`` 와 ``^`` 에 영향을 받는다. 여기 몇가지 예시들이 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2449
msgid "Part III: ``ListOp`` and subclasses"
msgstr "파트 III: ``ListOp`` 및 서브클래스"

#: ../../tutorials/operators/01_operator_flow.ipynb:2461
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2463
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp`` 는 효과적으로 벡터화된 연산자들의 컨테이너로써 연산자와 상태들의 리스트에 가해진다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2537
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "예를 들어, 위의 합성은 단순화 메서드 ``reduce`` 를 사용하여 리스트 (``ListOp``) 위에 분배된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2646
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ 의 종류: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2648
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you've already played around with the above, you'll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven't implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you'll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2651
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "이렇게 합성된 ``OperatorBase``\\ 들은 더 복잡하고 풍부한 계산을 할 때 ``PrimitiveOp`` 와 ``StateFn`` 빌딩 블록에서 벗어날 수 있게 한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2653
msgid "Every ``ListOp`` has four properties:"
msgstr "모든 ``ListOp`` 는 다음과 같은 네 가지 속성을 갖고 있다:"

#: ../../tutorials/operators/01_operator_flow.ipynb:2655
msgid "``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc."
msgstr "``oplist`` - 항과 인자 등을 나타내는 ``OperatorBase`` 의 리스트."

#: ../../tutorials/operators/01_operator_flow.ipynb:2656
msgid "``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays."
msgstr "``combo_fn`` - 복소수들의 리스트를 받아 ``oplist`` 의 항목의 결과를 어떻게 결합시킬지를 정의하는 출력값을 내는 함수. 브로드캐스팅을 단순하게 하고자 NumPy의 행렬을 받도록 정의되어 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2657
msgid "``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``."
msgstr "``coeff`` - 원시 값을 곱하는 계수. ``coeff`` 는 정수, 소수, 복소수, 또는 나중에 ``my_op.bind_parameters`` 를 사용하여 바인드되는 (테라의 ``qiskit.circuit`` 에 있는) 자유로운 ``Parameter`` 객체일 수도 있다는 점을 유의하라."

#: ../../tutorials/operators/01_operator_flow.ipynb:2658
msgid "``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "``abelian`` - ``oplist`` 의 연산자가 상호 통근하는 것으로 알려져 있는지 표시한다(일반적으로 ``AbelianGrouper`` 변환기에 의해 변환된 후에 설정된다)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2660
msgid "Note that ``ListOp`` supports typical sequence overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "``ListOp`` 는 일반적인 시퀀스 오버로드를 지원하므로, ``oplist`` 에 있는 ``OperatorBase`` 들에 접근할 때 ``my_op[4]`` 와 같은 인덱싱을 사용할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2672
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2674
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "위에서 ``OperatorStateFn`` 은 밀도 연산자를 나타낸다고 했다. 그러나 ``is_measurement`` 플래그가 ``True`` 일 경우, ``OperatorStateFn`` 은 관측가능량을 나타낸다. 이 관측가능량의 기댓값은 ``ComposedOp`` 를 통해 만들 수 있다. 또는 ``eval`` 을 직접 이용할 수도 있다. ``is_measurement`` 플래그(특성)는 ``adjoint`` 매서드로 설정된다는 것을 기억하라."

#: ../../tutorials/operators/01_operator_flow.ipynb:2685
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "여기서는 Pauli :math:`Z` 연산자에 해당하는 관측가능량을 구성한다. 프린트를 할 때는 ``OperatorMeasurement`` 로 불리는 것을 주의하라."

#: ../../tutorials/operators/01_operator_flow.ipynb:2757
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "이번에는 :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, 그리고 :math:`\\langle + | Z | + \\rangle` 를 계산할 것이다. 이 때 :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}` 이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2811
msgid "Part IV: Converters"
msgstr "파트 IV: 변환기 (Converters)"

#: ../../tutorials/operators/01_operator_flow.ipynb:2813
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter's ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2838
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "시간 변화, ``exp_i()``, 그리고 ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2840
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can't perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2843
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there's no \"evolution time\" argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:2855
msgid "Weighted sum of Pauli operators"
msgstr "Pauli 연산자의 가중합"

#: ../../tutorials/operators/01_operator_flow.ipynb:2857
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "멀티 큐비트 Pauli 연산자들의 선형 결합으로 표현되는 해밀토니안은 이와 같이 구성될 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2882
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "``two_qubit_H2`` 는 ``PauliOp``\\ 들의 항을 갖는 ``SummedOp`` 로 표현된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:2939
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "다음에는 해밀토니안에 ``Parameter`` 를 곱할 것이다. 이 ``Parameter`` 는 ``SummedOp`` 의 ``coeff`` 속성에 저장되어 있다. ``exp_i()`` 를 결과에 호출하면 그것을 지수 표현인 ``EvolvedOp`` 에 감싼다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3014
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "``two_qubit_H2`` 를 관측가능량으로 나타내는 ``h2_measurement`` 를 구성할 것이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3072
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr ":math:`\\text{CX} (H\\otimes I) |00\\rangle` 를 통해 Bell 상태 :math:`|\\Phi_+\\rangle` 를 구축한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3136
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "여기서는 :math:`H e^{-iHt} |\\Phi_+\\rangle` 표현이 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3242
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "대체로 :math:`e^{-iHt}`는 두 큐비트 게이트로 근사된다. 이는 표현들을 오가며 마주한 모든 ``EvolvedOp`` 에 트로터리제이션을 적용하는 ``PauliTrotterEvolution`` 의 ``convert`` 메서드로 얻을 수 있다. 여기서는 ``PauliTrotterEvolution`` 을 사용했지만, 같은 지수화를 수행하는 ``MatrixEvolution`` 과 같은 다양한 방법들도 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3361
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` 는 ``Parameter`` 를 포함하고 있다. ``bind_parameters`` 메서드는 표현을 오가며 ``dict`` 로 지정된 매개변수 이름과 해당하는 값을 바인딩 한다. 여기서는 파라미터가 1개 뿐인 경우이다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3382
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let's draw it to verify that the binding has taken place."
msgstr ""

#: ../../tutorials/operators/01_operator_flow.ipynb:3502
msgid "Expectations"
msgstr "기댓값"

#: ../../tutorials/operators/01_operator_flow.ipynb:3504
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "``Expectation``\\ 들은 관측가능량들의 기댓값을 계산할 수 있는 변환기이다. 이들은 연산자 트리를 오가며 ``OperatorStateFn``\\ 들(관측가능량)을 양자 혹은 고전 하드웨어에서의 계산에 적합하도록 동등한 명령어로 대체한다. 예를 들어서, 어떤 상태 함수에 대한 Pauli 연산자들의 합으로 표현된 연산자 ``o`` 의 기댓값을 측정하고 싶다면, 양자 하드웨어에서는 오직 대각 성분 측정에만 접근할 수 있으므로, 관측가능량 ``~StateFn(o)`` 을 생성하고 ``PauliExpectation`` 을 사용하여 그것을 대각 성분 측정으로 변환하고 회전 전 회로를 상태에 추가할 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3507
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "다른 흥미로운 ``Expectation`` 은 ``AerPauliExpectation`` 으로, 관측가능량을 ``Aer`` 이 고성능으로 처리할 수 있는 특별한 기댓값 스냅샷을 가진 ``CircuitStateFn`` 으로 변환한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3628
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "기본값 키워드 ``group_paulis=True`` 는 ``AbelianGrouper`` 를 사용하여 ``SummedOp`` 를 큐비트 단위로 상호 교환 가능한 Pauli 연산자의 모음으로 변환한다. 각각의 모음이 동일한 회로 실행을 공유하므로, 이를 통해 전반적인 회로 실행을 줄일 수 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3721
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "변환기는 재귀적으로 동작하는데, 그 말은, 표현을 오가면서 오직 동작 가능한 경우에만 적용한다는 말이다. 그러므로 전체 시간 변화(full evolution)와 식 측정을 바로 변환할 수 있다. 변환된 ``h2_measurement`` 는 시간 변화 ``CircuitStateFn`` 으로 동등하게 구성될 수 있다. 이는 전체 표현에 변환을 적용하여 진행된다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3905
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "이제 여러 매개변수를 ``ListOp`` 로 바인드 하고, 이어서 전체 표현을 ``eval`` 로 구한다. 바인딩이 먼저 되었다면 ``eval`` 을 먼저 사용할 수도 있지만, 별로 효과적이진 않다. 여기서는 내부 시뮬레이션을 통해 ``eval`` 이 ``CircuitStateFn``\\ 들을 ``VectorStateFn``\\ 들로 변환한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3927
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "여기 다양한 매개변수에 해당하는 기댓값들 :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` 이 있다."

#: ../../tutorials/operators/01_operator_flow.ipynb:3980
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "``CircuitSampler`` 로 ``CircuitStateFn``\\ 들을 실행하기"

#: ../../tutorials/operators/01_operator_flow.ipynb:3982
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFn``\\ s into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule)."
msgstr "``CircuitSampler`` 는 연산자를 오가며, 양자 백엔드를 사용하는 ``DictStateFn`` 또는 ``VectorStateFn`` 으로 ``CircuitStateFn`` 을 결과 상태 함수의 근사치로 변환한다. ``CircuitStateFn`` 의 값을 근사하려면, 1) 상태 함수를 모든 위상 정보를 파기하는 탈분극 채널을 통해 보내야 하며, 2) 샘플 주파수들을 샘플링의 (보른 규칙을 따라 상태 함수의 **제곱** 을 샘플링하는 것과 동등한) 원래 확률이 아닌 주파수의 **제곱근** 으로 대체해야 한다."

#: ../../tutorials/operators/01_operator_flow.ipynb:4038
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "회로들이 회로 샘플링 확률들의 **제곱근** 을 갖는 사전형(dicts)으로 대체된다는 것에 유의하라. 변환 전후의 이 하위 표현식을 참고하라."


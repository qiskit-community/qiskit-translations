msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-02 21:04+0000\n"
"PO-Revision-Date: 2023-03-02 21:38\n"
"Last-Translator: \n"
"Language: ko\n"
"Language-Team: Korean\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/circuits/3_summary_of_quantum_operations.po\n"
"X-Crowdin-File-ID: 9118\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:10
msgid "This page was generated from `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."
msgstr "이 페이지는 `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__ 에서 생성되었다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr "양자 연산 요약"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:20
msgid "In this section we will go into the different operations that are available in Qiskit Terra. These are:"
msgstr "본 섹션에서는 Qiskit Terra에서 이용 가능한 여러 가지 연산들에 대하여 다룬다. 목록은 다음과 같다:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:22
msgid "Single-qubit quantum gates"
msgstr "단일 큐비트 양자 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:23
msgid "Multi-qubit quantum gates"
msgstr "다중 큐비트 양자 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:24
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3586
msgid "Measurements"
msgstr "측정"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:25
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3828
msgid "Reset"
msgstr "초기화 (Reset)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:26
msgid "Conditionals"
msgstr "조건"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:27
msgid "State initialization"
msgstr "상태 초기화"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:29
msgid "We will also show you how to use the three different simulators:"
msgstr "또한 세 가지 종류의 시뮬레이터를 사용하는 방법도 설명한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:31
msgid "unitary_simulator"
msgstr "unitary_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:32
msgid "qasm_simulator"
msgstr "qasm_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:33
msgid "statevector_simulator"
msgstr "statevector_simulator"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:73
msgid "Single Qubit Quantum states"
msgstr "단일 큐비트 양자 상태"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:75
msgid "A single qubit quantum state can be written as"
msgstr "단일 큐비트 양자 상태는 다음과 같이 기술할 수 있다"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:77
msgid "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"
msgstr "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:79
msgid "where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a measurement the probability of the bit being in :math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and :math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this is"
msgstr "여기서 :math:`\\alpha` 및 :math:`\\beta` 는 복소수이다. 측정에서 큐비트가 :math:`\\left|1\\right\\rangle` 에 있을 확률은 :math:`|\\alpha|^2` 이고 :math:`\\left|1\\right\\rangle` 은 :math:`|\\beta|^ 2`. 벡터로서 이것은"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:81
msgid "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."
msgstr "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:90
msgid "Note, due to the conservation of probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` and since global phase is undetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` we only require two real numbers to describe a single qubit quantum state."
msgstr "확률의 보존으로 인해 :math:`|\\alpha|^2+ |\\beta|^2 = 1` 이며 전역 위상이 감지되지 않기 때문에 :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` 단일 큐비트 양자 상태를 설명하기 위해 두 개의 실수만 필요하다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:92
msgid "A convenient representation is"
msgstr ":math:`0\\leq\\phi<2\\pi` 과 :math:`0\\leq\\theta\\leq\\pi` 때 다음과 같이 나타낼수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:94
msgid "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"
msgstr "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:96
msgid "where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq \\pi`. From this, it is clear that there is a one-to-one correspondence between qubit states (:math:`\\mathbb{C}^2`) and the points on the surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the Bloch sphere representation of a qubit state."
msgstr "여기서 :math:`0\\leq\\phi<2\\pi` 및 :math:`0\\leq\\theta\\leq\\pi` 이다. 물론 큐비트 상태 (:math:`\\mathbb{C}^2`)와 단위 구 표면의 점 (:math:`\\mathbb{R}^3`)은 일대일로 대응된다. 이를 큐비트 상태의 블로흐 구체 표현이라고 한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:98
msgid "Quantum gates/operations are usually represented as matrices. A gate which acts on a qubit is represented by a :math:`2\\times 2` unitary matrix :math:`U`. The action of the quantum gate is found by multiplying the matrix representing the gate with the vector which represents the quantum state."
msgstr "양자 게이트/연산은 일반적으로 행렬로 표현한다. 특히 큐비트에 작용하는 게이트는 :math:`2\\times2` 유니테리 행렬 :math:`U` 로 표현 된다. 그리고 양자 게이트의 작용은 양자 상태를 나타내는 벡터에 게이트를 나타내는 행렬을 곱함으로써 알 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:100
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"
msgstr "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:102
msgid "A general unitary must be able to take the :math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr "일반적으로 유니테리 상태에서는 :math:`\\left|0\\right\\rangle` 을 위의 상태로 만들 수 있어야 한다. 따라서 :math:`U` 는 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:104
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"
msgstr "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:112
msgid "where :math:`a` and :math:`b` are complex numbers constrained such that :math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and :math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where :math:`0\\leq \\lambda<2\\pi` giving"
msgstr "여기서 임의로 주어진 :math:`0\\leq\\theta\\leq\\pi` 와 :math:`0\\leq\\phi<2\\pi` 에 대해 :math:`a` 와 :math:`b` 는 :math:`U^\\dagger U=I` 를 만족하는 복소수이다. 이는 세가지 제약 조건을 제공하며 이를 만족하는 :math:`a` 와 :math:`b` 는 :math:`0\\leq\\lambda<2\\pi` 를 이용하여 :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` 와 :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` 로 표현할 수 있다. 따라서"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:114
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:165
msgid "U(\\theta, \\phi, \\lambda) =\n"
"    \\begin{pmatrix}\n"
"        \\cos\\left(\\frac{\\theta}{2}\\right)          & -e^{i\\lambda}\\sin\\left(\\frac{\\theta}{2}\\right) \\\\\n"
"        e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right) & e^{i(\\phi+\\lambda)}\\cos\\left(\\frac{\\theta}{2}\\right)\n"
"    \\end{pmatrix}"
msgstr "U(\\theta, \\phi, \\lambda) =\n"
"    \\begin{pmatrix}\n"
"        \\cos\\left(\\frac{\\theta}{2}\\right)          & -e^{i\\lambda}\\sin\\left(\\frac{\\theta}{2}\\right) \\\\\n"
"        e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right) & e^{i(\\phi+\\lambda)}\\cos\\left(\\frac{\\theta}{2}\\right)\n"
"    \\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:123
msgid "This is the most general form of a single qubit unitary."
msgstr "이는 단일 큐비트에 작용되는 유니터리의 가장 일반적인 형태이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:135
msgid "Single-Qubit Gates"
msgstr "단일 큐비트 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:137
msgid "The single-qubit gates available are: - U gate - P gate - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr "사용할 수 있는 단일 큐비트 게이트는 다음과 같다: - U 게이트 - P 게이트 - Identity 게이트 - Pauli 게이트 - Clifford 게이트 - :math:`C3` 게이트 - 표준 회전(Standard rotation) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:139
msgid "We have provided a backend: ``unitary_simulator`` to allow you to calculate the unitary matrices."
msgstr "우리는 이러한 유니터리 행렬 계산이 가능하도록 해 주는 백엔드: ``unitary_simulator`` 를 제공한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:161
msgid "U gate"
msgstr "U 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:163
msgid "In Qiskit we give you access to the general unitary using the :math:`u` gate, which has the following matrix form"
msgstr "Qiskit에서는 다음과 같은 행렬 형식을 가진 :math:`u` 게이트를 사용하여 일반 유니테리를 사용할 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:284
msgid "Note on U gate deprecation"
msgstr "U 게이트 사용중단에 대한 노트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:286
msgid "The QuantumCircuit methods :math:`u1`, :math:`u2` and :math:`u3` are now deprecated. Instead, the following replacements should be used."
msgstr "QuantumCircuit의 메서드들 중 :math:\"u1\", :math:\"u2\" 및 :math:\"u3\" 은 이제 더 이상 사용되지 않는다. 대신에 다음 메서드들을 사용한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:288
msgid ":math:`u1(\\lambda) = p(\\lambda) = u(0, 0, \\lambda)`"
msgstr ":math:`u1(\\lambda) = p(\\lambda) = u(0, 0, \\lambda)`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:290
msgid ":math:`u2(\\phi, \\lambda) = u(\\frac{\\pi}{2}, \\phi, \\lambda) = p(\\frac{\\pi}{2} + \\phi) \\cdot sx \\cdot p(\\frac{\\pi}{2} - \\lambda)`"
msgstr ":math:`u2(\\phi, \\lambda) = u(\\frac{\\pi}{2}, \\phi, \\lambda) = p(\\frac{\\pi}{2} + \\phi) \\cdot sx \\cdot p(\\frac{\\pi}{2} - \\lambda)`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:292
msgid ":math:`u3(\\theta, \\phi, \\lambda) = u(\\theta, \\phi, \\lambda) = p(\\phi + \\pi) \\cdot sx \\cdot p(\\theta + \\pi) \\cdot sx \\cdot p(\\lambda)`"
msgstr ":math:`u3(\\theta, \\phi, \\lambda) = u(\\theta, \\phi, \\lambda) = p(\\phi + \\pi) \\cdot sx \\cdot p(\\theta + \\pi) \\cdot sx \\cdot p(\\lambda)`"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:319
msgid "P gate"
msgstr "P 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:321
msgid "The :math:`p(\\lambda)= u(0, 0, \\lambda)` gate has the matrix form"
msgstr "게이트 :math:`p(\\lambda)= u(0, 0, \\lambda)` 는 다음과 같은 행렬로 표현된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:323
msgid "p(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"
msgstr "p(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:332
msgid "which is useful as it allows us to apply a quantum phase."
msgstr "이는 양자 위상을 만들어 주므로 유용하다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:441
msgid "Identity gate"
msgstr "항등(identity) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:443
msgid "The identity gate is :math:`Id = p(0)`."
msgstr "항등 게이트는 :math:`Id = p(0)` 이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:552
msgid "Pauli gates"
msgstr "파울리(Pauli) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:555
msgid ":math:`X`: bit-flip gate"
msgstr ":math:`X`: 비트 플립 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:557
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr "비트 플립 게이트 :math:`X` 는 다음과 같이 정의된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:559
msgid "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u(\\pi,0,\\pi)"
msgstr "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u(\\pi,0,\\pi)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:675
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ":math:`Y`: 비트와 위상 플립 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:677
msgid "The :math:`Y` gate is defined as:"
msgstr ":math:`Y` 게이트는 다음과 같이 정의된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:679
msgid "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u(\\pi,\\pi/2,\\pi/2)"
msgstr "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u(\\pi,\\pi/2,\\pi/2)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:795
msgid ":math:`Z`: phase-flip gate"
msgstr ":math:`Z`: 위상 플립 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:797
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr "위상 플립 게이트 :math:`Z` 는 다음과 같이 정의된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:799
msgid "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=p(\\pi)"
msgstr "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=p(\\pi)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:915
msgid "Clifford gates"
msgstr "클리포드 (Clifford) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:918
msgid "Hadamard gate"
msgstr "하다마드(Hadamard) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:920
msgid "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u(\\pi/2,0,\\pi)"
msgstr "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u(\\pi/2,0,\\pi)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1037
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr ":math:`S` (or, :math:`\\sqrt{Z}` 위상) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1039
msgid "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= p(\\pi/2)"
msgstr "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= p(\\pi/2)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1155
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr ":math:`S^{\\dagger}` (또는 :math:`\\sqrt{Z}` 위상의 켤레) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1157
msgid "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= p(-\\pi/2)"
msgstr "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= p(-\\pi/2)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1273
msgid ":math:`C3` gates"
msgstr ":math:`C3` 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1276
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr ":math:`T` (혹은, :math:`\\sqrt{S}` 위상) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1278
msgid "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= p(\\pi/4)"
msgstr "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= p(\\pi/4)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1394
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr ":math:`T^{\\dagger}` (혹은, :math:`\\sqrt{S}` 위상의 켤레) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1396
msgid "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= p(-\\pi/4)"
msgstr "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= p(-\\pi/4)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1512
msgid "Standard Rotations"
msgstr "표준 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1514
msgid "The standard rotation gates are those that define rotations around the Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr "표준 회전 게이트들은 파울리 :math:`P=\\{X,Y,Z\\}` 에 대응하는 블로흐 벡터 축을 기준으로한 회전을 정의하는 게이트다. 다음과 같이 정의되는데,"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1516
msgid "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"
msgstr "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1519
msgid "Rotation around X-axis"
msgstr "X축에 관한 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1521
msgid "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u(\\theta, -\\pi/2,\\pi/2)"
msgstr "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u(\\theta, -\\pi/2,\\pi/2)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1637
msgid "Rotation around Y-axis"
msgstr "Y축에 관한 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1639
msgid "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u(\\theta,0,0)"
msgstr "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u(\\theta,0,0)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1755
msgid "Rotation around Z-axis"
msgstr "Z축에 관한 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1757
msgid "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv p(\\phi)"
msgstr "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv p(\\phi)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1766
msgid "Note that here we have used an equivalent as it is different to :math:`p` by a global phase :math:`e^{-i \\phi/2}`."
msgstr ":math:`p` 과 전역 위상 :math:`e^{-i \\phi/2}` 의 차이로 인해 등가식을 사용했음을 참고한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1874
msgid "Note this is different due only to a global phase."
msgstr "이는 전역 위상 (Global Phase) 값만 다를 뿐이라는 사실을 주목하자."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1886
msgid "Multi-Qubit Gates"
msgstr "다중 큐비트 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1889
msgid "Mathematical Preliminaries"
msgstr "수학적 예비"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1891
msgid "The space of a quantum computer grows exponentially with the number of qubits. For :math:`n` qubits the complex vector space has dimension :math:`d=2^n`. To describe states of a multi-qubit system, the tensor product is used to “glue together” operators and basis vectors."
msgstr "양자 컴퓨터를 기술하는 공간의 차원은 큐비트의 개수가 증가함에 따라 지수적으로 증가한다. :math:`n` 큐비트를 기술하는 복소 벡터 공간은 :math:`d=2^n` 차원을 가지기 때문이다. 다중 큐비트 시스템의 상태를 표현할 때는 텐서 곱을 사용하여 연산자들이나 기저 벡터들 사이를 \"붙여줄\" 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1893
msgid "Let’s start by considering a 2-qubit system. Given two operators :math:`A` and :math:`B` that each act on one qubit, the joint operator :math:`A \\otimes B` acting on two qubits is"
msgstr "우선 두 개의 큐비트들로 구성된 시스템을 생각해 보자. 각 큐비트에 작용하는 두 개의 연산자 :math:`A` 와 :math:`B` 가 주어졌을 때 두 개의 큐비트에 동시에 작용하는 연합 연산자 :math:`A \\otimes B` 은 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1895
msgid "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"
msgstr "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1917
msgid "where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of :math:`A` and :math:`B`, respectively."
msgstr "여기서 :math:`A_{jk}` 와 :math:`B_{lm}` 는 각각 :math:`A` 와 :math:`B` 의 행렬 성분이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1919
msgid "Analogously, the basis vectors for the 2-qubit system are formed using the tensor product of basis vectors for a single qubit:"
msgstr "유사하게 두 큐비트 시스템의 기저 벡터들은 단일 큐비트의 기저 벡터들을 텐서 곱하여 형성된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1921
msgid "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"
msgstr "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1945
msgid "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."
msgstr "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1968
msgid "Note we’ve introduced a shorthand for the tensor product of basis vectors, wherein :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. The state of an :math:`n`-qubit system can be described using the :math:`n`-fold tensor product of single-qubit basis vectors. Notice that the basis vectors for a 2-qubit system are 4-dimensional; in general, the basis vectors of an :math:`n`-qubit system are :math:`2^{n}`-dimensional, as noted earlier."
msgstr "우리는 기저 벡터의 텐서 곱에서 :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` 를 :math:`\\left|00\\right\\rangle` 와 같이 씀으로써 간략한 표현을 도입하여 사용하였다. :math:`n` 큐비트 시스템의 상태는 단일 큐비트 기저 벡터들을 :math:`n` 번 텐서곱 하여 표현할 수 있다. 2 큐비트 시스템의 기저 벡터의 차원은 4차원이며 일반적으로 :math:`n` 큐비트 시스템의 기저 벡터의 차원은 :math:`2^{n}` 임을 주목하자."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1971
msgid "Basis vector ordering in Qiskit"
msgstr "Qiskit에 사용되는 기저 벡터의 순서"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1973
msgid "Within the physics community, the qubits of a multi-qubit systems are typically ordered with the first qubit on the left-most side of the tensor product and the last qubit on the right-most side. For instance, if the first qubit is in state :math:`\\left|0\\right\\rangle` and second is in state :math:`\\left|1\\right\\rangle`, their joint state would be :math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different ordering of the qubits, in which the qubits are represented from the most significant bit (MSB) on the left to the least significant bit (LSB) on the right (little-endian). This is similar to bitstring representation on classical computers, and enables easy conversion from bitstrings to integers after measurements are performed. For the example just given, the joint state would be represented as :math:`\\left|10\\right\\rangle`. Importantly, *this change in the representation of multi-qubit states affects the way multi-qubit gates are represented in Qiskit*, as discussed below."
msgstr "물리 커뮤니티 내에서, 다중 큐비트 시스템의 큐비트는 일반적으로 텐서 곱의 가장 왼쪽에 있는 첫 번째 큐비트와 가장 오른쪽에 있는 마지막 큐비트로 순서를 결정한다. 예를 들어, 첫 번째 큐비트가 상태 :math:`\\left|0\\right\\rangle` 이고 두 번째 큐비트가 :math:`\\left|1\\right\\rangle` 상태인 경우 결합 상태는 :math:`\\left|01\\right\\rangle` 로 정하는 것이 일반적이다. 하지만 Qiskit은 큐비트의 정렬 순서를 다르게 사용한다. 큐비트는 왼쪽의 최상위 비트(MSB)에서 오른쪽(리틀 엔디안)의 최하위 비트(LSB)로 표시된다. 이 방식은 기존 컴퓨터의 비트열 표현과 유사하기 때문에 측정 후 비트열을 정수로 쉽게 변환할 수 있다. 따라서 방금 주어진 예의 연합 상태는 :math:`\\left|10\\right\\rangle` 로 표시된다. 아주 중요하게, *다중 큐비트 상태 표현의 이런 차이점은 아래에서 살펴볼 바와 같이 Qiskit* 에서 다중 큐비트 게이트가 표현되는 방식에 영향을 미친다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1976
msgid "The representation used in Qiskit enumerates the basis vectors in increasing order of the integers they represent. For instance, the basis vectors for a 2-qubit system would be ordered as :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. Thinking of the basis vectors as bit strings, they encode the integers 0,1,2 and 3, respectively."
msgstr "Qiskit에서 사용하는 표현은 기저 벡터를 표현하는 숫자가 증가하는 순으로 숫자를 메긴다. 예를 들어 두 큐비트 시스템의 기저 벡터들은 :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle` 순으로 배열된다. 이때 기저 벡터에 대응하는 비트열을 살펴보면 각각 0,1,2,3이 인코딩 되어 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1979
msgid "Controlled operations on qubits"
msgstr "큐비트에 적용되는 조절 연산들"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1981
msgid "A common multi-qubit gate involves the application of a gate to one qubit, conditioned on the state of another qubit. For instance, we might want to flip the state of the second qubit when the first qubit is in :math:`\\left|0\\right\\rangle`. Such gates are known as *controlled gates*. The standard multi-qubit gates consist of two-qubit gates and three-qubit gates. The two-qubit gates are: - controlled Pauli gates - controlled Hadamard gate - controlled rotation gates - controlled phase gate - controlled u3 gate - swap gate"
msgstr "일반적인 다중 큐비트 게이트는 한 큐비트에 가하는 게이트나 다른 큐비트에 조건부로 작용하는 게이트나 그 응용을 모두 포함한다. 예를들어 첫번째 큐비트이 :math:`\\left|0\\right\\rangle` 일 때 두번째 큐비트가 플립되는 게이트를 고려하자. 이러한 게이트는 *제어 게이트* (controlled gates)로 알려져 있다. 표준 다중 큐비트 게이트는 두 큐비트 게이트와 세 큐비트 게이트로 구성되어 있는데 두 비트 게이트에는 -제어 파울리 게이트 (controlled Pauli gates) - 제어 하다마드 게이트 (controlled Hadamard gate) - 제어 회전 게이트 (controlled rotation gates) - 제어 위상 게이트 (controlled phase gate) - 제어 u3게이트 (controlled u3 gate) - 교환 게이트 (swap gate)가 있으며"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1984
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr "세 큐비트 게이트에는 - Toffoli gate - Fredkin gate가 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1996
msgid "Two-qubit gates"
msgstr "이중 큐비트 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1998
msgid "Most of the two-qubit gates are of the controlled type (the SWAP gate being the exception). In general, a controlled two-qubit gate :math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the second qubit when the state of the first qubit is in :math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix representation"
msgstr "대부분의 두 큐비트 게이트들은 다른 큐비트에 의해 조절되는 유형이다. (SWAP 게이트는 예외) 일반적으로 다른 큐비트에 의해 조절되는 두 큐비트 게이트 :math:`C_{U}` 는 첫번째 큐비트의 상태가 :math:`\\left|1\\right\\rangle` 일 때 단일 큐비트 유니터리 :math:`U` 를 두번째 큐비트에 가하는 식이다. 유니터리 :math:`U` 가 다음 행렬이라고 가정하자."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2000
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"
msgstr "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2002
msgid "We can work out the action of :math:`C_{U}` as follows. Recall that the basis vectors for a two-qubit system are ordered as :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the **control qubit** is **qubit 0** (which, according to Qiskit’s convention, is one the *right-hand* side of the tensor product). If the control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be applied to the **target** (qubit 1, on the *left-hand* side of the tensor product). Therefore, under the action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr "우리는 :math:`C_{U}` 가 어떻게 작용하는 다음과 같이 살펴볼 수 있다. 우선 두 큐비트 시스템의 기저 벡터는 :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle` 순으로 쓸 수 있다. **제어 큐비트** 는 **큐비트 0** 이라 가정하자(Qiskit 표기에 따르면 텐서곱 연산의 *오른쪽* 에 해당). 만약 제어 큐비트가 :math:`\\left|1\\right\\rangle` 이면 :math:`U`가 **표적 큐비트** 에 적용된다(큐비트 1, 텐서곱의 *왼쪽*). 그러므로 :math:`C_{U}` 가 작용할 때 기저 벡터들은 다음과 같이 변환된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2005
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."
msgstr "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2014
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr ":math:`C_{U}` 를 행렬로 나타내면 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2016
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2027
msgid "To work out these matrix elements, let"
msgstr "이러한 행렬 성분을 알아내려면,"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2029
msgid "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| m \\right\\rangle}\\right),\n\n"
msgstr "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| m \\right\\rangle}\\right),\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2031
msgid "compute the action of :math:`C_{U}` (given above), and compute the inner products."
msgstr "위에 주어진 :math:`C_{U}` 의 작용을 먼저 계산하고 내적을 계산한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2033
msgid "As shown in the examples below, this operation is implemented in Qiskit as ``cU(q[0],q[1])``."
msgstr "아래 예에서 볼 수 있듯이 이 연산은 Qiskit에서 ``cU(q[0],q[1])`` 로 구현되어 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2035
msgid "If **qubit 1 is the control and qubit 0 is the target**, then the basis vectors are transformed according to"
msgstr "만약 **큐비트 1이 제어 큐비트 그리고 큐비트 0이 표적 큐비트** 이라면, 기저 벡터는 다음과 같이 변환된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2037
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"
msgstr "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2046
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr "이는 :math:`C_{U}` 의 행렬 형태가 다음과 같음을 의미한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2048
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2079
msgid "Controlled Pauli Gates"
msgstr "제어 파울리 게이트(Controlled Pauli Gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2082
msgid "Controlled-X (or, Controlled-NOT) gate"
msgstr "Controlled-X (또는, Controlled-NOT) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2084
msgid "The Controlled-NOT gate flips the ``target`` qubit when the control qubit is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr "Controlled-NOT 게이트는 제어 큐비트의 상태가 :math:`\\left|1\\right\\rangle` 일 때 ``Target`` 큐비트를 반전시킨다. 만약 제어 큐비트가 MSB라면 (예를 들면, ``cx(q[1],q[0])``) 그 행렬은 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2086
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."
msgstr "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2097
msgid "However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), this gate is equivalent to the following matrix:"
msgstr "그러나 조절 큐비트가 LSB이면 (e.g. ``cx(q[0],q[1])``), 이 게이트는 다음 행렬과 동일하다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2099
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."
msgstr "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2231
msgid "Controlled :math:`Y` gate"
msgstr "제어 :math:`Y` 게이트 (Controlled Y Gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2233
msgid "Apply the :math:`Y` gate to the target qubit if the control qubit is the MSB"
msgstr "조절 큐비트이 MSB이면 :math:`Y` 게이트를 목표 큐비트에 적용한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2235
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"
msgstr "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2246
msgid "or when the LSB is the control"
msgstr "만약 조절 큐비트이 LSB이면 다음을 적용한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2248
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."
msgstr "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2380
msgid "Controlled :math:`Z` (or, controlled Phase-Flip) gate"
msgstr "Controlled :math:`Z` (위상 제어) 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2382
msgid "Similarly, the controlled Z gate flips the phase of the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks the same regardless of whether the MSB or LSB is the control qubit:"
msgstr "비슷하게, 위상 반전 게이트는 표적 큐비트의 상태가 :math:`\\left|1\\right\\rangle` 일 때 제어 큐비트의 위상을 뒤집어 준다. 제어 큐비트가 MSB인 경우나 LSB인 경우나 상관없이 행렬은 같은 모양이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2384
msgid "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"
msgstr "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2516
msgid "Controlled Hadamard gate"
msgstr "조절된 Hadamard 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2518
msgid "Apply :math:`H` gate to the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. Below is the case where the control is the LSB qubit."
msgstr "만약 제어 큐비트가 :math:`\\left|1\\right\\rangle` 이면 :math:`H` 를 타겟 큐비트에 적용한다. 아래는 제어 큐비트가 LSB 큐비트인 경우이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2520
msgid "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"
msgstr "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2652
msgid "Controlled rotation gates"
msgstr "회전 제어 게이트 (Controlled rotation gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2655
msgid "Controlled rotation around Z-axis"
msgstr "Z-축을 기준으로 한 회전 제어"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2657
msgid "Perform rotation around Z-axis on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "만약 조절 큐비트 (여기서는 LSB)가 :math:`\\left|1\\right\\rangle`인 경우 z-축을 중심으로 회전 변환을 실행한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2659
msgid "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"
msgstr "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2791
msgid "Controlled phase rotation"
msgstr "위상 제어 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2793
msgid "Perform a phase rotation if both qubits are in the :math:`\\left|11\\right\\rangle` state. The matrix looks the same regardless of whether the MSB or LSB is the control qubit."
msgstr "만약 두 큐비트가 모두 :math:`\\left|11\\right\\rangle` 상태에 있으면 위상 회전을 실시한다. 이 경우 조절 큐비트가 MSB나 LSB에 상관없이 행렬은 같은 형태이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2795
msgid "C_{p}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"
msgstr "C_{p}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2927
msgid "Controlled :math:`u` rotation"
msgstr "제어 :math:`u` 회전"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2929
msgid "Perform controlled-:math:`u` rotation on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2931
msgid "C_{u}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr "C_{u}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3063
msgid "SWAP gate"
msgstr "교환 게이트(SWAP gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3065
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr "SWAP 게이트는 두 큐비트의 상태를 서로 바꿔 준다. 이는 기저 벡터를 다음과 같이 변환한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3067
msgid "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"
msgstr "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3069
msgid "which gives a matrix representation of the form"
msgstr "이것은 다음의 행렬 표현식을 가진다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3071
msgid "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3203
msgid "Three-qubit gates"
msgstr "삼중 큐비트 게이트"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3205
msgid "There are two commonly-used three-qubit gates. For three qubits, the basis vectors are ordered as"
msgstr "일반적으로 사용되는 두 가지 삼중 큐비트 게이트가 있다. 세 큐비트의 경우 기저 벡터는 다음과 같이 정렬된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3207
msgid "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"
msgstr "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3209
msgid "which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. Again, Qiskit uses a representation in which the first qubit is on the right-most side of the tensor product and the third qubit is on the left-most side:"
msgstr "비트열 처럼 정수 :math:`0,1,2,\\cdots, 7` 를 나타낸다. 다시한번 말하지만 Qiskit은 첫번째 큐비트를 가장 오른쪽에 세번째 큐비트를 가장 왼쪽에 위치하는 표현을 사용한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3211
msgid "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"
msgstr "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3223
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr "토폴리(Toffoli) 게이트 (:math:`ccx` 게이트)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3225
msgid "The `Toffoli gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ flips the third qubit if the first two qubits (LSB) are both :math:`\\left|1\\right\\rangle`:"
msgstr "`토폴리 게이트 <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ 는 첫번째와 두번째 큐비트(LSB)이 모두 :math:`\\left|1\\right\\rangle` 일 때 세번째 큐비트을 플립한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3227
msgid "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"
msgstr "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3229
msgid "In matrix form, the Toffoli gate is"
msgstr "행렬식으로 표현한 토폴리 게이트는 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3231
msgid "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."
msgstr "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3397
msgid "Controlled swap gate (Fredkin Gate)"
msgstr "교환 제어 게이트(프레드킨 게이트)(Controlled swap gate, Fredkin gate)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3399
msgid "The `Fredkin gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, or the *controlled swap gate*, exchanges the second and third qubits if the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr "`프레드킨 게이트 <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__ 혹은 *교환 제어 게이트(controlled swap gate)* 는 첫번째(LSB) 큐비트이 :math:`\\left|1\\right\\rangle` 일 때 두번째와 세번째 큐비트를 교환한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3401
msgid "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"
msgstr "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3403
msgid "In matrix form, the Fredkin gate is"
msgstr "프레드킨 게이트를 행렬로 표현하면 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3405
msgid "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3561
msgid "Non-unitary operations"
msgstr "비 유니테리 연산들 (Non-unitary operations)"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3563
msgid "Now that we have gone through all the unitary operations in quantum circuits, we also have access to non-unitary operations. These include measurements, reset of qubits, and classical conditional operations."
msgstr "양자 회로에서 사용가능한 모든 유니터리 연산들을 살펴보았으니 이제 유니터리가 아닌 연산들을 살펴보도록 하자. 유니터리가 아닌 연산에는 측정, 큐비트의 reset, classical conditional 연산이 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3588
msgid "We don’t have access to all the information when we make a measurement in a quantum computer. The quantum state is projected onto the standard basis. Below are two examples showing a circuit that is prepared in a basis state and the quantum computer prepared in a superposition state."
msgstr "양자 컴퓨터에서 측정을 수행하여도 모든 정보를 얻을 수는 없다. 양자 상태는 표준 기저에 사영된다. 아래 두 예는 각각 양자상태들이 기저 상태 중 하나로 준비되거나 중첩 상태로 준비되는 회로를 보여준다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3702
msgid "The simulator predicts that 100 percent of the time the classical register returns 0."
msgstr "이 시뮬레이터는 100퍼센트 확률로 고전적인 레지스터의 값이 0 임을 예측한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3816
msgid "The simulator predicts that 50 percent of the time the classical register returns 0 or 1."
msgstr "이 시뮬레이터는 50퍼센트 확률로 고전적인 레지스터의 값이 0이거나 1임을 예측한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3830
msgid "It is also possible to ``reset`` qubits to the :math:`\\left|0\\right\\rangle` state in the middle of computation. Note that ``reset`` is not a Gate operation, since it is irreversible."
msgstr "계산하는 동안 큐비트들을 :math:`\\left|0\\right\\rangle` 상태로 ``재설정`` 하는 것도 가능하다. ``재설정`` 은 가역연산이 아니므로 게이트 연산이 아님을 주목하자."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4048
msgid "Here we see that for both of these circuits the simulator always predicts that the output is 100 percent in the 0 state."
msgstr "여기서 우리는 시뮬레이터가 두 회로 모두 결과값이 0 상태임을 100 퍼센트의 확률로 예측함을 알 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4060
msgid "Conditional operations"
msgstr "조건 연산자"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4062
msgid "It is also possible to do operations conditioned on the state of the classical register"
msgstr "고전적인 레지스터의 상태에 따라 연산을 하는 것도 가능하다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4144
msgid "Here the classical bit always takes the value 0 so the qubit state is always flipped."
msgstr "여기서 고전 비트의 값은 항상 0이라서 큐비트의 상태는 항상 플립된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4300
msgid "Here the classical bit by the first measurement is random but the conditional operation results in the qubit being deterministically put into :math:`\\left|1\\right\\rangle`."
msgstr "여기서 첫번째 측정에 따른 고전 비트는 무작위이지만 조건 연산의 결과 상태는 결정적으로 :math:`\\left|1\\right\\rangle` 이다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4312
msgid "Arbitrary initialization"
msgstr "임의 초기화"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4314
msgid "What if we want to initialize a qubit register to an arbitrary state? An arbitrary state for :math:`n` qubits may be specified by a vector of :math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals 1. For example, the following three-qubit state can be prepared:"
msgstr "큐비트 레지스터를 임의의 상태로 초기화 하고 싶다면 어떻게 하면 될까? :math:`n` 큐비트의 임의의 상태는 각 진폭을 절대값 해서 제곱한 값을 모두 더했을 때 1이 되는 :math:`2^n` 개의 진폭을 나타내는 숫자로 구성된 벡터로 표현할 수 있다. 예를 들어, 다음의 세 큐비트 상태는 이렇게 준비될 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4316
msgid "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"
msgstr "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4464
msgid "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ is useful to check whether two states are the same or not. For quantum (pure) states :math:`\\left|\\psi_1\\right\\rangle` and :math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ 는 두 상태가 같은지 확인하는데 유용하다. 두 pure 양자 상태 :math:`\\left|\\psi_1\\right\\rangle` 와 :math:`\\left|\\psi_2\\right\\rangle` 의 fidelity는 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4466
msgid "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4471
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr "두 상태가 동일할 때만 fidelity 값은 :math:`1` 이 된다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4518
msgid "Further details:"
msgstr "자세한 내용:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4520
msgid "How does the desired state get generated behind the scenes? There are multiple methods for doing this. Qiskit uses a `method proposed by Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to assume the quantum register to have started from our desired state, and construct a circuit that takes it to the :math:`\\left|00..0\\right\\rangle` state. The initialization circuit is then the reverse of such circuit."
msgstr "어떻게 원하는 상태가 준비될 수 있을까? 이를 수행할 수 있는 다양한 방법들이 있지만 Qiskit에서는 `Shende et al이 제안한 방법 <https://arxiv.org/abs/quant-ph/0406176>`__ 를 사용한다. 이 논문의 아이디어는 양자 레지스터가 애초에 원하는 상태로 시작했다고 가정한 다음 :math:`\\left|00..0\\right\\rangle` 상태로 변환하는 회로를 구성하는 것이다. 그리고 이 회로의 역변환을 하여 초기화 회로를 얻는다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4522
msgid "To take an arbitrary quantum state to the zero state in the computational basis, we perform an iterative procedure that disentangles qubits from the register one-by-one. We know that any arbitrary single-qubit state :math:`\\left|\\rho\\right\\rangle` can be taken to the :math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree rotation about the Z axis followed by a :math:`\\theta`-degree rotation about the Y axis:"
msgstr "우리는 임의의 양자 상태를 계산가능한 기저(computational basis)의 영 상태(zero state)로 만들고자 큐비트을 얽힘을 푸는 과정을 반복한다. 임의의 단일 큐비트 상태 :math:`\\left|\\rho\\right\\rangle` 는 Z축을 중심으로 회전하는 :math:`\\phi`-자유도 회전과 Y축을 중심으로 회전하는 :math:`\\theta`-자유도 회전을 연이어 수행하여 상태 :math:`\\left|0\\right\\rangle` 로 변환할 수 있다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4524
msgid "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"
msgstr "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4526
msgid "Since now we are dealing with :math:`n` qubits instead of just 1, we must factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr "우리가 지금 다루고 있는 큐비트은 한 개가 아닌 :math:`n` 개이므로 상태 벡터에서 가정 덜 중요한 비트(LSB)를 분리해 내고자 다음과 같이 성분 별로 묶어 분해 한다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4528
msgid "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"
msgstr "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4536
msgid "Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to :math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and :math:`\\theta` angles per the equation above. Doing this simultaneously on all states amounts to the following unitary, which disentangles the LSB:"
msgstr "이제 각 단일 큐비트 상태 :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` 는 적절한 각도 :math:`\\phi` and :math:`\\theta` 를 찾아내므로써 :math:`\\left|0\\right\\rangle` 로 변환할 수 있다. LSB의 얽힘을 풀어 나가는 이 과정을 모든 상태 동시에 수행하는 유니터리는 다음과 같다."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4538
msgid "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"
msgstr "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4548
msgid "Hence,"
msgstr "그러므로,"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4550
msgid "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"
msgstr "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4552
msgid "U can be implemented as a “quantum multiplexor” gate, since it is a block diagonal matrix. In the quantum multiplexor formalism, a block diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select qubits and :math:`n-s` data qubits. Depending on the state of the select qubits, the corresponding blocks are applied to the data qubits. A multiplexor of this kind can be implemented after recursive decomposition to primitive gates of cx, rz and ry."
msgstr "U는 블록 대각 행렬이므로 \"양자 멀티플렉서(quantum multiplexor)\" 게이트로 구현할 수 있다. 양자 멀티플렉서에서 크기가 :math:`2^n \\times 2^n`이며 :math:`2^s`개의 블록 행렬로 구성된 블록 대각 행렬은 선택 큐비트이 :math:`s`개이고 데이터 큐비트가 :math:`n-s`개인 멀티플렉서와 동일하다. 이때 선택 큐비트의 상태에 따라 데이터 큐비트에 적용되는 블록이 선택된다. 이러한 종류의 멀티플렉서는 기본게이트 cx, rz 그리고 ry를 이용하여 재귀적으로 분해한 형태로 구현할 수 있다."


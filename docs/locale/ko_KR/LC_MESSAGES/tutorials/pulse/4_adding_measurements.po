msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-10 19:20+0000\n"
"PO-Revision-Date: 2020-08-19 10:30\n"
"Last-Translator: \n"
"Language-Team: Korean\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/pulse/4_adding_measurements.po\n"
"X-Crowdin-File-ID: 9368\n"
"Language: ko_KR\n"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:10
msgid "This page was generated from `tutorials/pulse/4_adding_measurements.ipynb`__."
msgstr "이 페이지는 `tutorials/pulse/4_adding_measurements.ipynb`__에서 생성되었다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:9
msgid "Adding measurements to ``Schedule``\\ s"
msgstr "``Schedule``에 측정을 추가하기"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:11
msgid "Measurement is clearly a very important part of building a Pulse schedule -- this is required to get the results of our program execution! The powerful low-level control we are granted by Pulse gives us more freedom than ``QuantumCircuit``\\ s in specifying how the measurement should be done, enabling you to explore readout error mitigation. This power of course comes with responsibility: we have to understand how measurement works, and accomodate certain hardware constraints."
msgstr "측정은 명백히 펄스 스케줄을 작성하는 데 매우 중요한 부분이다 - 이것은 프로그램의 실행 결과를 얻기 위해 필요하다! 펄스가 부여한 강력한 저수준 제어는 우리에게 측정 방법을 구체화하는 데 있어서 ``QuantumCircuit` 보다 더 많은 자유를 주어 당신이 판독 에러 완화를 검토할 수 있게 해준다. 물론 이러한 권한은 책임을 동반한다: 우리는 측정이 어떻게 작동하는지 이해해야 하고 특정 하드웨어 제약조건을 수용해야 한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:13
msgid "On this page, we will explore in depth how to create measurements, using several different approaches of increasing complexity."
msgstr "이 페이지에서는 복잡성이 증가하는 여러 가지 접근 방식을 사용하여 측정을 생성하는 방법을 심층적으로 살펴보기로 한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:15
msgid "\\*\\*Note: Pulse allows you to receive raw, kerneled, and disciminated readout data (whereas circuits will only return discriminated data)."
msgstr "\\*\\*Note:   Pulse를 사용하면 원시, 커널 및 식별 된 판독 데이터를 수신 할 수 있다 (반면 회로는 식별 된 데이터만 반환한다)."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:18
msgid "Adding a backend-default measurement with ``measure``"
msgstr "\"측정값\" 을 사용하여 백엔드 기본 측정값을 추가한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:20
msgid "To add measurements as easily to ``Schedule``\\ s as to ``QuantumCircuit``\\ s, you just have to know which qubits you want to measure (below, qubits 0 and 1) and have a OpenPulse-enabled ``backend``:"
msgstr "``Schedule``에 ``QuantumCircuit``만큼 쉽게 측정을 추가하려면, 측정하려는 큐비트 (아래, 큐비트0 과 큐비트1) 와 OpenPulse가 활성화 된`` 백엔드 ''를 알아야한다:"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:28
msgid "The ``backend`` contains a default definition for measurement, which is tailored to the qubits you are measuring."
msgstr "``backend`` 에는 측정에 대한 기본 설정들이 있으며, 측정하는 큐비트에 맞게 조정할 수 있다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:31
msgid "Basic measurement pattern and ``measure_all``"
msgstr "기본적인 측정 패턴과 ``measure_all``"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:33
msgid "Let's use the default measurement feature to inspect a measurement and learn what each pulse does. Below, we use ``measure_all``, which measures all the qubits on the backend."
msgstr "기본 측정 기능을 사용하여 측정을 점검하고 각 펄스가 수행하는 작업에 대해 알아본다. 아래에서는 백엔드의 모든 큐비트를 측정하는 `measure_all``을 사용합다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:85
msgid "Each qubit has two channels related to readout, as we see above. These are the readout transmit ``MeasureChannel``\\ s, and the readout receive ``AcquireChannel``\\ s. In superconducting qubit architectures, qubits are coupled to readout resonators. The ``MeasureChannel`` and ``AcquireChannel``\\ s label signal lines which connect to the readout resonator. The coupling between the qubit and the readout resonator hybridizes their state, so when a stimulus pulse is sent to the readout resonantor, the reflected pulse is dependent on the state of the qubit. The acquisition \"pulse\" is truly a trigger specifying to the analog-to-digital converter (ADC) to begin collecting data, and for how long. That data is used to classify the qubit state."
msgstr "각 큐비트에는 위에서 보는 바와 같이 판독(읽고 쓰기) 와 관련된 두 개의 채널이 있다. 이들은 판독 요청 채널인 ``MeasureChannel``과, 판독을 수신하는 채널인``AcquireChannel``이다. 초전도 큐비트 아키텍처에서 큐비트는 판독 공명기에 결합된다. ``MeasureChannel``과 ``AcquireChannel`` 라벨 신호 라인은 판독 공명기에 연결된다. 큐비트와 판독 공명기의 결합은 그들의 상태를 혼합하므로, 자극 펄스가 판독 공진기로 전송될 때 반사 펄스는 큐비트의 상태에 따라 달라진다. 수집 \"pulse\"는 실제로 데이터 수집을 시작하기 위해 ADC(Analog-to-Digital Converter) 에 전달하는 트리거다. 그 데이터는 큐비트의 상태를 분류하는 데 사용된다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:89
msgid "Specifying classical memory slots"
msgstr "클래식 메모리 슬롯 지정"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:91
msgid "If you would like to specify where your measurement results go, there is an option for that in ``measure``, called ``qubit_mem_slots``. It takes a dictionary mapping qubit indices to classical memory slots. For example, if you want to measure qubit 0 into memory slot 1, you would do this:"
msgstr "측정 결과가 어디로 가는지를 지정하고자 하는 경우에는 ``qubit_mem_slots`` 이라고 하는 ``measure`` 값에 대한 옵션을 사용한다. 예를 들어, 메모리 슬롯 1에 큐비트 0의 측정 값을 삽입하려는 경우 다음을 수행한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:114
msgid "This would be equivalent to the circuit measurement ``circuit.measure(qubit_reg[0], classical_reg[1])``."
msgstr "이는 양자 회로 측정 ``circuit.measure(qubit_reg[0], classical_reg[1])``과 동일한 결과를 보인다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:126
msgid "Build a measurement sequence from pulses"
msgstr "펄스들로부터 측정 시퀀스 만들기"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:128
msgid "Rather than use the default measurements provided by the backend, we can also build the measurement sequence up as a basic Pulse schedule. The example below is similar to a typical measurement on IBM systems."
msgstr "백엔드에서 제공되는 기본 측정만 사용하기 보다 기본 펄스 스케줄로부터 측정 시퀀스를 만들 수 있다. 아래의 예제는 IBM 시스템에서 일반적으로 사용되는 측정과 비슷하다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:130
msgid "First, we'll build the measurement stimulus pulses for each of the qubits we want to measure. Below, we use a Gaussian square parametric pulse."
msgstr "첫째로 측정하고자 하는 각각의 큐비트의 측정 자극 펄스를 만들어야 한다. 아래에는 가우시안(Gaussian) 사각 파라메트릭 펄스를 사용하였다. "

#: ../../tutorials/pulse/4_adding_measurements.ipynb:160
msgid "Before we build the acquisition pulses, we need to understand the measurement map."
msgstr "획득(acquisition) 펄스를 만들기 전에 측정 맵을 이해해야 한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:163
msgid "Acquiring qubits: the measurement map ``meas_map``"
msgstr "획득 큐비트: 측정 맵 ``meas_map``"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:165
msgid "Due to control rack hardware constraints, some qubits may need to be acquired together. This can be the case for qubits whose readout channels are multiplexed. Any OpenPulse-enabled backend will provide a ``meas_map`` to notify the user of this."
msgstr "제어 랙 하드웨어 제약으로 인해 일부 큐비트를 함께 획득해야 할 수도 있다. 판독 채널이 멀티플렉스되는 큐비트의 경우가 이에 해당한다. OpenPulse를 지원하는 백엔드는 무엇이든 이를 사용자에게 알리기 위해 ``meas_map``을 제공한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:167
msgid "For instance, if we see this for a 5-qubit ``backend``"
msgstr "예를 들어, 5-큐비트 ``backend``의 경우에 다음을 본다면, "

#: ../../tutorials/pulse/4_adding_measurements.ipynb:175
msgid "then we know that all the qubits on this device must be acquired together. On the other hand, this output"
msgstr "그렇다면, 이 장치에 있는 모든 큐비트들이 한꺼번에 수집되어야 함을 알 수 있다. 반면에 다음의 결과는"

#: ../../tutorials/pulse/4_adding_measurements.ipynb:181
msgid "tells us that qubits 0, 1 and 2 can be acquired independently, but qubits 3 and 4 must be acquired together."
msgstr "큐비트 0, 1, 2는 독립적으로 수집될 수 있지만 큐비트 3 과 4는 반드시 함께 수집되어야 한다는 것을 말해 준다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:183
msgid "When building up a pulse schedule, be sure to add all the acquire pulses required by the backend you plan to run on. This is validated at assemble time."
msgstr "펄스 스케줄을 작성할 때에는, 실행하려는 백엔드에서 요구하는 필요한 모든 획득 펄스를 추가해야 한다. 이것은 어셈블 단계에서 검증된다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:185
msgid "Getting back to our example, let's imagine we plan to run on a backend with this measurement map: ``[[0, 1, 2]]``. Now we can build the acquisition pulses. This is done with the ``Acquire`` command, which takes only a duration. We specify the channels and memory slots to acquire on."
msgstr "예제로 다시 돌아가서, 다음의 측정 맵 ``[[0, 1, 2]]``을 가진 벡엔드를 실행하려고 한다고 가정하자. 이제 획득 펄스를 생성해야 한다. 이것은 지속 시간 값만을 가지는 ``Acquire`` 명령으로 행해진다. 여기에 수집에 쓰일 채널들과 메모리 슬롯을 설정해 준다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:208
msgid "Finally, we just combine the two parts together. Every instruction is on a different channel, so appending schedules the instructions at time 0. The ``measure_schedule`` can then be added to the end of any Pulse schedule to measure qubits 0 and 1 into classical memory slots 0 and 1."
msgstr "마지막으로 두 가지 부분을 합친다. 모든 명령어들은 각각의 다른 채널에 있으므로 시간 0에 실행될 명령어 스케줄을 추가한다. 그런 다음 큐비트 0과 1을 고전적인 메모리 슬롯 0과 1에 측정하기 위해 각각의 펄스 스케줄러의 끝부분에 ``measure_schedule``을 추가한다."

#: ../../tutorials/pulse/4_adding_measurements.ipynb:240
msgid "Next, check out how to `get system information from the backends <5_gathering_system_information.ipynb>`__."
msgstr "다음으로 `get system information from the backends <5_gathering_system_information.ipynb>`__를 통해 시스템 정보를 얻는 방법을 확인한다."


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 18:58+0000\n"
"PO-Revision-Date: 2021-06-23 07:27\n"
"Last-Translator: \n"
"Language-Team: Chinese Traditional\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/noise/6_repetition_code.po\n"
"X-Crowdin-File-ID: 9142\n"
"Language: zh_TW\n"

#: ../../tutorials/noise/6_repetition_code.ipynb:10
msgid "This page was generated from `tutorials/noise/6_repetition_code.ipynb`__."
msgstr "此頁面是從 `tutorials/noise/6_repelection_code.ipynb `__ 產生的。"

#: ../../tutorials/noise/6_repetition_code.ipynb:12
msgid "Run interactively in the `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/6_repetition_code.ipynb>`_."
msgstr "在 `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/6_repetition_code.ipynb>`_中互動執行。"

#: ../../tutorials/noise/6_repetition_code.ipynb:9
msgid "Repetition Codes"
msgstr "重複代碼"

#: ../../tutorials/noise/6_repetition_code.ipynb:21
msgid "Introduction"
msgstr "簡介"

#: ../../tutorials/noise/6_repetition_code.ipynb:23
msgid "In quantum error correction we take many noisy qubits (which we call *physical qubits*) and use them to store a smaller number of *logical qubits*. The error correction procedure is designed to detect and correct for the effects of noise. This makes the logical qubits much less noisy and more reliable than the physical ones from which they are built."
msgstr "在量子誤差修正中，我們採用了許多噪聲量子位元（我們稱之為 *實體量子位元* ），並使用它們來儲存較小的 *邏輯量子位元*。 該錯誤修正的程序是為了偵測及抵銷噪音的效應而設計的。 這使得邏輯量子位元比它們所建立的實體量子位元的噪音小得多，並且更可靠。(邏輯量子位元是基於實體量子位元而建造。)"

#: ../../tutorials/noise/6_repetition_code.ipynb:25
msgid "The repetition code is a simple example of quantum error correction, in which a logical *bit* is stored rather than a logical *qubit*. A given instance of the repetition code is defined by two numbers, which we call :math:`d` and :math:`T`."
msgstr "重複碼是量子誤差修正的一個簡單例子，其中是邏輯 *位元* 被儲存，而不是邏輯 *量子位元*。重複碼的一個實例是由兩個數字定義的，我們稱之為 :math:`d` 和 :math:`T`。"

#: ../../tutorials/noise/6_repetition_code.ipynb:27
msgid "The :math:`d` parameter determines how many physical qubits are used. The actual information about the logical bit is stored in :math:`d` qubits (which we’ll call *code qubits*). The encoding is done in a very simple way: to encode a ``0``, all these qubits are set in the state :math:`|0\\rangle`, to encode a ``1`` they are set to :math:`|1\\rangle`. To readout the value, you can just look at any qubit. To read it out in a way that protects against single qubit errors, you can read out all the qubits and take a majority vote."
msgstr "此參數 :math:`d` 決定被使用的實體量子位元數目。 邏輯位元的實際資訊會儲存在 :math:`d` 個量子位元內 （我們將之稱為 *代碼量子位元*）。 其編碼可以很簡單的方式完成：若要編一個 ``0``，我們可以將所有的量子位元設定在此狀態 :math:`|0\\rangle`，若要編一個 ``1``，我們可以將所有的量子位元設定在此狀態 :math:`|1\\rangle`。 若要重新讀取該數值，您只需查看任何一個量子位元。 如果要以防止量子位元誤差的方式來讀取該數值，您可以讀取所有量子位元並進行多數決。"

#: ../../tutorials/noise/6_repetition_code.ipynb:30
msgid "It is not only at readout that we can extract useful information that will help us correct errors. We can also extract information while the logical bit sits idle, or even while it is involved in computation."
msgstr "我們不僅可以在讀取的時候汲取能幫助我們修正誤差的有用資訊，還能在該邏輯位元閒置時汲取資訊，或甚至是在該邏輯位元正在運算的時候。"

#: ../../tutorials/noise/6_repetition_code.ipynb:32
msgid "Since this is an exercise in quantum error correction, we will do this in a way that would also work for logical *qubits*. Specifically, our method of extracting information about errors must not extract any information regarding the stored logical information. In the quantum case, this is required so that we do not disturb superposition states of the stored qubits."
msgstr "由於這是一個量子誤差修正的工作，我們將會以符合邏輯 *量子位元*的方式來做這一工作。 尤其，我們汲取關於誤差的資訊之方法不得汲取關於已經儲存的任何邏輯資訊。 在量子的情況下，這是必需的，因為這樣我們就不會干擾已經儲存的量子位元的疊加狀態。"

#: ../../tutorials/noise/6_repetition_code.ipynb:34
msgid "We will extract information over :math:`T` rounds of *syndrome measurements*. For the repetition code, these are based on the fact that all code qubits should be in the same state (all :math:`|0\\rangle` or all :math:`|1\\rangle`). Any departure from this is therefore a signature of error. Specifically, we imagine our :math:`d` code qubits sitting along a line. We will then perform a measurement on each pair of neighboring code qubits. This will tell us whether they are the same or different, without extracting any information on what their values are."
msgstr "我們將汲取 :math:`T' 輪 *症候群測量(syndrome measurements)* 的資訊。 對於其重複碼，這些是基於這樣一個所有代碼量子位元都應處於相同狀態（全部都在 :math:`|0\\rangle` 或在 :math:`|1\\rangle`）的事實。因此，任何與上述的偏離即為錯誤的跡象。想確切地說們，的們 :math:`d` 編碼塊，坐落於這一條直線上。 然後，我們將對每對相鄰碼群進行測量。 這會告訴我們，它們是否相同，而不需要汲取其值的任何資訊。"

#: ../../tutorials/noise/6_repetition_code.ipynb:37
msgid "The implementation of these measurements requires :math:`d-1` additional qubits, which we will call *link qubits* for the repetition code. By performing two CNOTs between the pair of code qubits and a corresponding link qubit, the required information (and only the required information) is placed on the link qubit and can then be measured."
msgstr "這些測量的實作需要 :math:`d-1` 個額外的量子位元，我們將這些額外的量子位元稱作 *連結量子位元 (link qubits)* 。 通過在相鄰編碼量子位元對和相應的結量子位元之間執行兩個 CNOTs ，需要的資訊（且僅需要此資訊）被放置在此結量子位元上，然後可以被測量。"

#: ../../tutorials/noise/6_repetition_code.ipynb:95
msgid "Here we provide tools for creating and testing repetition codes. The first thing we need to do is import them."
msgstr "在這裡，我們提供工具來建立和測試重複碼。 我們要做的第一件事就是輸入它們。"

#: ../../tutorials/noise/6_repetition_code.ipynb:119
msgid "Creating a repetition code"
msgstr "建立重複代碼"

#: ../../tutorials/noise/6_repetition_code.ipynb:121
msgid "The ``repetition_code`` class creates a code for given values of :math:`d` and :math:`T`."
msgstr "其 ``repetition_code`` 類別建立一個給定值為 :math:`d` 和 :math:`T`的程式代碼。"

#: ../../tutorials/noise/6_repetition_code.ipynb:144
msgid "With this we can inspect various properties of the code, such as the names of the qubit registers used for the code and ancilla qubits."
msgstr "透過此，我們可以檢查程式碼的各種特性，例如用於程式碼和輔助量子位元的量子位元暫存器的名稱。"

#: ../../tutorials/noise/6_repetition_code.ipynb:185
msgid "These registers are also attributes of the ``repetition_code`` object."
msgstr "這些暫存器也是 ``repetition_code`` 物件的的特性。"

#: ../../tutorials/noise/6_repetition_code.ipynb:226
msgid "You can also access the quantum circuits that implement the code. Two of these are produced: one for each of the two possible logical bit values."
msgstr "你也可以存取執行程式碼的量子電路。 會產生其中兩個：兩個可能的邏輯位元值各一個。"

#: ../../tutorials/noise/6_repetition_code.ipynb:479
msgid "Building a custom repetition code"
msgstr "建置自訂重複程式碼"

#: ../../tutorials/noise/6_repetition_code.ipynb:481
msgid "You can also implement measurement rounds and logical ``X`` gates yourself. For example, let’s set up a code with no syndrome measurement rounds."
msgstr "您也可以自行執行測量和邏輯 ``X``  閘。 例如，讓我們設立一個沒有症候群測量的程式碼。"

#: ../../tutorials/noise/6_repetition_code.ipynb:502
msgid "This does nothing but set up two circuits for the two logical encoded states. There are no syndrome measurement rounds, and no final readout."
msgstr "這只會為兩個邏輯編碼狀態設立兩個電路。 沒有症候群測量，也就沒有最終的讀出。"

#: ../../tutorials/noise/6_repetition_code.ipynb:601
msgid "We can add a round using the ``syndrome_measurement()`` method."
msgstr "我們可以使用 ``syndrome_measurement()`` 方法來新增一次測量。"

#: ../../tutorials/noise/6_repetition_code.ipynb:712
msgid "A logical ``X`` operation can be added using the ``x()`` method."
msgstr "我們可以使用 ``x()`` 方法來新增一步邏輯 ``X`` 操作 。"

#: ../../tutorials/noise/6_repetition_code.ipynb:823
msgid "This also has a ``logs`` kwarg, which is a list of the circuits for which ``X`` is applied. This is ``['0','1']`` by default."
msgstr "這也有 ``logs`` kwarg，它是已套用 ``X`` 的電路清單。 其預設為 ``['0','1']`` 。"

#: ../../tutorials/noise/6_repetition_code.ipynb:834
msgid "Final readout is then done with the ``readout()`` method."
msgstr "然後，最終的讀取可以被 ``readout()`` 的方法完成。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1012
msgid "Running a repetition code"
msgstr "執行一個重複程式碼"

#: ../../tutorials/noise/6_repetition_code.ipynb:1014
msgid "The code object produces the circuits required for the code. The user can then run them using any method they prefer, allowing full control over compilation, backends, noise models and so on."
msgstr "程式碼物件會產生程式碼所必需的電路。 然後，使用者可以使用他們偏好的任何方法來執行它們，從而對編譯的過程，後端、雜訊模型等有完整的控制。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1016
msgid "For example, here we run them without noise on the ``qasm_simulator``."
msgstr "例如，在這裡我們用 ``qasm_simulator`` 來執行沒有雜訊的程式碼。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1076
msgid "Here the strings from right to left represent the outputs of the syndrome measurement rounds, followed by the final measurement of the code qubits."
msgstr "從右到左的字串代表了症候群測量的輸出，接著是對程式碼量子位元的最終測量。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1078
msgid "These results need to be rewritten in a different form in order to be decoded. To do this we can use the ``process_results`` method of the code object."
msgstr "這些結果需要以不同的格式重新編寫，才能被解碼。 為了這樣做，我們可以使用程式碼物件的 `process_results`` 方法。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1119
msgid "The result is a dictionary whose keys are bit strings that represent outputs of the circuit, and the values represent the number of shots for which this output occurred."
msgstr "結果是一個字典，其索引鍵是代表電路的輸出的位元字串，且其值代表最後貢獻到其輸出的量測次數。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1121
msgid "The strings are not the direct output from the circuits. They have been processed to take the form that helps us correct errors. Here’s a short guided tour."
msgstr "這些字串不是該電路的直接輸出。 它們已被轉換成可以協助我們更正錯誤的形式。 以下是一個簡短的導覽。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1123
msgid "The ``0 0`` to the far left for the logical ``0`` result, and the ``1 1`` to the far left of the logical ``1``, are the logical readout. Any code qubit could be used for this readout, since they should (without errors) all be equal. So we could have just one result here, for one arbitrarily chosen code qubit. Or we could have :math:`d`, one for each qubit. Instead we have two, from the two qubits at either end of the line. This is because it works best with the decoder (which we’ll use later). In the absence of errors, these two values will always be equal."
msgstr "對應於邏輯結果 ``0``，在最左邊的 ``0 0``，以及對應於邏輯結果 ``1``，在最左邊的 ``1 1``，是邏輯讀出。 任何程式碼量子位元都可以用於此讀取，因為它們應該（沒有誤差）都是等價的。 因此，對於任意選擇的一個程式碼量子位元，我們在這裡只能得到一個結果。或者，我們可以有 :math: `d`個結果， 一個結果對應一個量子位元。 不同於上述，我們從線路兩端的兩個量子位中得到兩個結果，這是因為這樣的情況最適合解碼器的運行。 在沒有誤差的情況下，這兩個值永遠是等價的。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1126
msgid "The following ``0000`` is the :math:`d-1` results of the syndrome measurements for the first round.A ``0`` implies that the corresponding pair of qubits where the same, and ``1`` implies different. There are :math:`d-1` results because the line of :math:`d` code qubits has :math:`d-1` possible neighboring pairs. In the absence of errors, they will all be ``0``."
msgstr "下列 ``0000`` 是 :math:`d-1` 第一輪症候群測量(syndrome measurements)的結果。 ``0`` 表示對應的量子位元對是相同的，而 ``1`` 表示不同。 我們總共有 :math:`d-1` 個結果因為此擁有 :math:`d` 個程式碼量子位元的線會擁有 :math:`d-1` 個可能的相鄰對。在沒有誤差的情況下，它們都會是 ``0``。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1128
msgid "The ``0000`` that follows that is the syndrome change between the first and second rounds. It is therefore the bitwise ``OR`` of the syndrome measurement results from the second round with those from the first. In the absence of errors, they will all be ``0``."
msgstr "在其之後的 ``0000`` 是第一輪和第二輪之間的症候群變化。 因此，這是從第一輪到第二輪之間，症候群測量結果中的位元 ``OR``。 在沒有誤差的情況下，它們都將是 ``0``。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1130
msgid "Subsequent blocks follow the same formula, though the last requires some comment. This is not measured using the standard method (with a link qubit). Instead it is calculated from the final readout measurement of all code qubits. Again it is presented as a syndrome change, and will be all ``0`` in the absence of errors. This is the :math:`T+1`-th block of syndrome measurements since, as it is not done in the same way as the others, it is not counted among the :math:`T` syndrome measurement rounds."
msgstr "後續的區塊遵循相同的公式，即便其最後的區塊需要一些註解。 這不是使用標準方法（含連結量子位元）來進行測量，而是從所有程式碼量子位元的最終讀出測量中計算出來的。 它再次被呈現為症候群變化，且在沒有誤差的情況下將是全部是 ``0``。 這是第 :math:\"T+1\" 塊的綜合症測量，因為它沒有像其他方法那樣做，所以不會被計算進 :math:\"T\" 症候群量測的次數當中。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1133
msgid "**Example 1:** ``0 0  0110 0000 0000`` would represent a :math:`d=5`, :math:`T=2` repetition code with encoded ``0``. The syndrome shows that (most likely) the middle code qubit was flipped by an error before the first measurement round. This causes it to disagree with both neighboring code qubits for the rest of the circuit. This is shown by the syndrome in the first round, but the blocks for subsequent rounds do not report it as it no longer represents a change. Other sets of errors could also have caused this syndrome, but they would need to be more complex and so presumably less likely."
msgstr "**範例 1：``0 0  0110 0000 0000`` 將代表一個 :math:`d=5`， :math:`T=2` 的重複碼，編碼為 ``0``。 這種症候群顯示（很可能）在第一次測量回合之前，中間程式碼量子位元被誤差翻轉。 這會導致它不同於在此電路上其他的相鄰程式碼量子位元。 這在第一輪的症候群被顯示，但在後續回合則不會被顯示因為這對後續回合來說已經不再是個變更。 其他的誤差也可能造成這種症候群，但其他的誤差需更加複雜所以理論上不太可能發生。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1136
msgid "**Example 2:** ``0 0  0010 0010 0000`` would represent a :math:`d=5`, :math:`T=2` repetition code with encoded ``0``. Here one of the syndrome measurements reported a difference between two code qubits in the first round, leading to a ``1``. The next round did not see the same effect, and so resulted in a ``0``. However, since this disagreed with the previous result for the same syndrome measurement, and since we track syndrome changes, this change results in another ``1``. Subsequent rounds also do not detect anything, but this no longer represents a change and hence results in a ``0`` in the same position. Most likely the measurement result leading to the first ``1`` was an error."
msgstr "**範例 2：** ``0 0  0010 0010 0000`` 將代表一個 :math:`d=5`， :math:`T=2` 的重複碼，編碼為 ``0``。 這裡的一種症候群測量報告了在第一回合的兩個程式碼量子位元之間的差異，此差異產生了一個 ``1``。 在下一回合我們沒有看到同樣的效果，因此產生了一個 ``0``。 然而，由於這不符合先前相同的症候群測量所產生的結果，且因為我們追踪的是症候群的變化，這改變了另一個 ``1`` 中的結果。 後續的回合也不會偵測任何東西，但這不再代表變更，因此在相同位置中的結果是  ``0``。 最有可能導致第一個 ``1`` 的測量結果是一個錯誤。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1139
msgid "**Example 3:** ``0 1  0000 0001 0000`` would represent a :math:`d=5`, :math:`T=2` repetition code with encoded ``1``. A code qubit on the end of the line is flipped before the second round of syndrome measurements. This is detected by only a single syndrome measurement, because it is on the end of the line. For the same reason, it also disturbs one of the logical readouts."
msgstr "**範例 3：** ``0 1  0000 0001 0000`` 代表一個 :math:`d=5`， :math:`T=2` 的重複程式碼，編碼為 ``1``。 在第二回合症候群測量之前，在線末端的程式碼量子位元會先被翻轉。因為它在線的末端，所以它是被單一個綜合症測量所偵測。 出於同樣的原因，它也擾亂了其中一個邏輯讀出。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1141
msgid "Note that in all these examples, a single error causes exactly two characters in the string to change from the value it would have with no errors. This is, in fact, the reason why the logical output consists of both endpoints. It is a property that will be used by the decoder."
msgstr "請注意，在所有這些範例中，單一誤差會導致字串中準確地有兩個字元的數值改變(變得跟原本沒有誤差的數值不同)。 這事實上是邏輯輸出由兩個端點所組成的原因。 這個性質將會被解碼器所使用。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1152
msgid "To see the effects of noise, we need to specify a noise model. For example, let’s set up a simple noise model with gate and measurement errors."
msgstr "為了看到噪音的影響，我們需要指定一個噪音模型。 例如，讓我們設立一個簡單的噪音模型，其具有閘和測量誤差。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1197
msgid "This can then be run to generate noisy results. Let’s make a quick function to do this, and then run it."
msgstr "執行此模型可產生具有雜訊的結果。 讓我們做一個快速簡易的函數功能來完成這個動作，然後執行它。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1457
msgid "Here the non-noisy results are the most likely. The rest of the samples are distributed among other possibilities with non-trivial syndromes."
msgstr "在這裡不具有雜訊的結果是最有可能的。 其餘的樣本分布在其他可能的狀況，這些狀況具有比較複雜的症候群。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1469
msgid "Decoding a repetition code"
msgstr "解一個重複碼"

#: ../../tutorials/noise/6_repetition_code.ipynb:1471
msgid "Noisy results can change the logical value at readout, and so affect our ability to read out the logical qubit. This can be mitigated by looking at the syndrome values. These can tell us whether or not the logical values are most likely to have changed, and so allow us to correct for the errors. The process of analyzing the syndrome to correct for the errors is called ‘decoding’. We do this by building a decoding object for our code."
msgstr "具有雜訊的結果可以在讀出時改變邏輯值，從而影響我們讀出邏輯量子位元的能力。通過查看症狀值可以減緩這種影響。 這些症狀值可以告訴我們哪些邏輯值是否最有可能發生改變，因此允許我們更正錯誤。 對錯誤進行分析和處理的過程稱為‘decoding’.。 我們通過為我們的程式碼建立一個解碼物件來完成這一任務。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1492
msgid "This analyzes the code by seeing how different kinds of error change the output. With this information, along with a decoding algorithm, we can determine what the logical value is most likely to have been."
msgstr "這會透過查看不同類型的錯誤改變其輸出的方式來分析程式碼。 有了這些資訊，加上解碼演算法，我們就可以判斷該邏輯值最有可能是什麼了。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1494
msgid "For example, let’s use the ‘matching’ algorithm to decode, which is based on minimum weight perfect matching. This takes specific output strings as input. We’ll give it the simple example string ``'1 0  001 100 100'``, for a logical ``1`` that has suffered two errors."
msgstr "例如，讓我們使用 'matching' 演算法來解碼（以最小加權完美匹配為基礎）。 這會以特定的輸出字串作為輸入。 我們將提供一個簡單範例字串 ``'1 0  001 100 100'``，對於邏輯 ``1`` ，此字串有兩個錯誤。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1535
msgid "The output is what the logical part should have been. As you can see, the decoder correctly determined that the readout should have been of a logical ``1``."
msgstr "該邏輯部分先前應該要和該輸出相同。 如您所見，解碼器正確地判斷讀出先前應該要是邏輯的 ``1`` 。"

#: ../../tutorials/noise/6_repetition_code.ipynb:1546
msgid "When we take many samples, we can determine the probability with which the decoder is incorrect. This should decrease exponentially as the code size is increased, since the configurations of noise that fool the decoder become less likely. The probability of a logical error is calculated using the ``logical_prob()`` method. This runs matching by default, but other algorithms can be specified by the ``algorithm`` kwarg."
msgstr "當我們抽取很多樣本時，我們可以確定解碼器不正確的機率。 這應該會隨著程式碼大小的增加而指數下降，因此愚弄解碼器的雜訊的配置變得不太可能。 邏輯錯誤的機率是使用 ``logical_prob()`` 方法計算的。 此方法預設會執行 matching 演算法，但若要執行其他演算法，則可以通過 ``algorithm`` kwarg指定。"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 18:58+0000\n"
"PO-Revision-Date: 2021-06-17 07:23\n"
"Last-Translator: \n"
"Language-Team: Chinese Traditional\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/noise/4_randomized_benchmarking.po\n"
"X-Crowdin-File-ID: 9138\n"
"Language: zh_TW\n"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:10
msgid "This page was generated from `tutorials/noise/4_randomized_benchmarking.ipynb`__."
msgstr "此頁面是從 `tutorials/noise/4_randomized_benchmarking.ipynb`__ 產生的。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:12
msgid "Run interactively in the `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/4_randomized_benchmarking.ipynb>`_."
msgstr "在 `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/4_randomized_benchmarking.ipynb>`_中互動執行。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:9
msgid "Randomized Benchmarking"
msgstr "設立隨機化基準"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:12
msgid "Introduction"
msgstr "簡介"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:14
msgid "**Randomization benchmarking (RB)** is a well-known technique to measure average gate performance by running sequences of random Clifford gates that should return the qubits to the initial state. Qiskit Ignis has tools to generate one- and two-qubit Clifford gate sequences simultaneously."
msgstr "**隨機化基準（ RB）** 是一種眾所周知的方法，可通過執行隨機克利福閘的序列來測量平均閘效能，這些序列會將量子位元返回到初始狀態。 Qiskit Ignis 有工具可以同時產生一個和兩個量子位元的Clifford 的閘序列。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:16
msgid "This notebook gives an example for how to use the ``ignis.verification.randomized_benchmarking`` module. This particular example shows how to run 2-qubit randomized benchmarking (RB) simultaneous with 1-qubit RB. There are also examples on how to use some of the companion functions for predicting RB fidelity."
msgstr "此記事本提供了如何使用 ` `ignis.verification.randomized_benchmarking`` 模組的範例。 此特定範例顯示如何與 1-qubit RB 同時執行 2-qubit 隨機化基準（RB）。 也有一些例子說明如何使用一些伴隨函數來預測 RB 的保真度。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:49
msgid "1) Select the Parameters of the RB Run"
msgstr "1）選取 RB 執行的參數"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:51
msgid "First, we need to choose the following parameters:"
msgstr "首先，我們需要選擇以下參數："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:53
msgid "**nseeds:** The number of seeds. For each seed you will get a separate list of output circuits in rb_circs."
msgstr "**nseeds:** 種子數。 對於每一個種子，您將取得 rb_circs 中個別輸出電路清單。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:54
msgid "**length_vector:** The length vector of Clifford lengths. Must be in ascending order. RB sequences of increasing length grow on top of the previous sequences."
msgstr "**length_vector：** Clifford 長度向量的長度必須是以遞增順序排列。 增加長度的 RB 序列以前序列為基礎增長。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:55
msgid "**rb_pattern:** A list of the form [[i,j],[k],…] which will make simultaneous RB sequences where Qi,Qj are a 2-qubit RB sequence and Qk is a 1-qubit sequence, etc. The number of qubits is the sum of the entries. For ‘regular’ RB the qubit_pattern is just [[0]],[[0,1]]."
msgstr "**rb_pattern：** 為一個以 [[i, j], [k],...] 格式的清單，此清單將同時生成 RB 序列，其中Qi和Qj是二量子位元 RB序列，Qk是一量子位元序列，等。量子位元的數目是輸入項目的總和。 對於 '常規' RB 而言， 其qubit_pattern 即為 [[0]]，[[0，1]]。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:56
msgid "**length_multiplier:** If this is an array it scales each rb_sequence by the multiplier."
msgstr "** length_multiplier: ** 如果這是一個陣列，其將對每一個 rb_sequence 乘以一個乘數。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:57
msgid "**seed_offset:** What to start the seeds at (e.g. if we want to add more seeds later)."
msgstr ""

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:58
msgid "**align_cliffs:** If true adds a barrier across all qubits in rb_pattern after each set of cliffords."
msgstr "**align_cliffs:** 如果為真，則在每組 Cliffords 之後，在 rb_pattern 中的所有量子位元都會新增一個屏障。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:60
msgid "In this example we have 3 qubits Q0,Q1,Q2. We are running 2Q RB (on qubits Q0,Q2) and 1Q RB (on qubit Q1) simultaneously, where there are twice as many 1Q Clifford gates."
msgstr "在此範例中，我們有 3 個量子位元Q0，Q1，Q2。 我們同時執行 2Q RB （位於量子位元 Q0、Q2 ）和 1Q RB （在量子位元Q1 上），其中有兩倍多的 1Q Clifford閘。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:92
msgid "2) Generate the RB sequences"
msgstr "2）產生 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:94
msgid "We generate RB sequences. We start with a small example (so it doesn’t take too long to run)."
msgstr "我們生成RB序列。 我們從一個小例子開始（如此才不會花太多時間來執行）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:96
msgid "In order to generate the RB sequences **rb_circs**, which is a list of lists of quantum circuits, we run the function ``rb.randomized_benchmarking_seq``."
msgstr "為了產生 RB 序列 **rb_cris**，我們運行了 ` ``rb.randomized_benchmarking_seq`` 函數。(**rb_circs**是一個清單，此清單的每個元素各自為一個量子電路清單。)"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:98
msgid "This function returns:"
msgstr "此函數傳回："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:100
msgid "**rb_circs:** A list of lists of circuits for the rb sequences (separate list for each seed)."
msgstr "**rb_circs：** ˊ對於rb 序列，一個元素為電路清單的清單（每一個種子的個別清單）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:101
msgid "**xdata:** The Clifford lengths (with multiplier if applicable)."
msgstr "**xdata:** Clifford 長度（適用時具有乘數）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:127
msgid "As an example, we print the circuit corresponding to the first RB sequence:"
msgstr "舉例，我們列印對應於第一個 RB 序列的電路："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:218
msgid "Look at the Unitary for 1 Circuit"
msgstr "請看此相對於一個電路的Unitary矩陣 (一個Unitary矩陣代表了一個RB電路)"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:229
msgid "The Unitary representing each RB circuit should be the identity (with a global phase), since we multiply random Clifford elements, including a computed reversal gate. We simulate this using an Aer unitary simulator."
msgstr "代表每個 RB 電路的Unitary矩陣是單位矩陣（具有全局相位），因為我們乘以隨機的Clifford元素，包括計算出的反轉閘。 我們用一個 Aer 幺正模擬器來模擬。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:301
msgid "Define the noise model"
msgstr "定義雜訊模型"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:312
msgid "We define a noise model for the simulator. To simulate decay, we add depolarizing error probabilities to the CNOT and U gates."
msgstr "我們為此模擬器定義了一個噪音模型。 為了模擬衰變，我們在 CNOT 和 U 閘上增加了去極化誤差概率。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:339
msgid "3) Execute the RB sequences on Aer simulator"
msgstr "3）在 Aer 模擬器上執行 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:341
msgid "We can execute the RB sequences either using a Qiskit Aer Simulator (with some noise model) or using an IBMQ provider, and obtain a list of results, ``result_list``."
msgstr "我們可以使用 Qiskit Aer Simulator （具有某種雜訊模型）或使用 一個 IBMQ provider 以執行 RB 序列，並取得結果清單 ``result_list``。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:415
msgid "4) Fit the RB results and calculate the gate fidelity"
msgstr "4）擬合其RB 結果並計算其閘的保真度"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:418
msgid "Get statistics about the survival probabilities"
msgstr "取得存活機率的統計資料"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:420
msgid "The results in **result_list** should fit to an exponentially decaying function :math:`A \\cdot \\alpha ^ m + B`, where :math:`m` is the Clifford length."
msgstr "**result_list** 中的結果應可被指數衰減函數 :math:`A \\cdot \\alpha ^ m + B`擬合，其中 :math:`m` 是Clifford的長度。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:422
msgid "From :math:`\\alpha` we can calculate the **Error per Clifford (EPC)**:"
msgstr "從:math:`\\alpha` 我們可以計算**Error per Clifford (EPC)**："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:424
msgid "EPC = \\frac{2^n-1}{2^n} (1-\\alpha)\n\n"
msgstr ""

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:426
msgid "(where :math:`n=nQ` is the number of qubits)."
msgstr "（其中 :math:`n=nQ` 是量子位元的數目）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:449
msgid "Plot After 1 Seed"
msgstr "在一個種子之後的圖表"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:491
msgid "Plot with the Rest of the Seeds"
msgstr "對應於剩餘種子的圖表"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:493
msgid "The plot is being updated after each seed."
msgstr "在每一個種子之後，該圖都會被更新。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:547
msgid "Add more shots to the data"
msgstr "增加量測次數並將結果添加至原有的數據"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:652
msgid "Predicted Gate Fidelity"
msgstr "預測的閘保真度"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:663
msgid "From the known depolarizing errors on the simulation we can predict the **fidelity**. First we need to count the number of **gates per Clifford**."
msgstr "可以根據模擬中已知的去極化誤差來預測 **fidelity**。 首先，我們需要計算 **gates per Clifford**的數量。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:665
msgid "The function **gates_per_clifford** takes a list of transpiled RB circuits and outputs the number of basis gates in each circuit."
msgstr "此函數 **gates_per_clifford** 輸入轉譯RB 電路的清單並輸出每一個電路中的基底閘數。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:716
msgid "The function **calculate_2q_epc** gives measured errors in the basis gates that were used to construct the Clifford. It assumes that the error in the underlying gates is depolarizing. It outputs the error per a 2-qubit Clifford."
msgstr "此函數 **calculate_2q_epc** 會給出基底閘中用來建構 Clifford的測量誤差。 它假設基底閘中的錯誤是去極化的。 它會輸出一個二量子位元的Clifford 誤差。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:718
msgid "The input to this function is: - **gate_per_cliff:** dictionary of gate per Clifford. - **epg_2q:** EPG estimated by error model. - **qubit_pair:** index of two qubits to calculate EPC. - **list_epgs_1q:** list of single qubit EPGs of qubit listed in ``qubit_pair``. - **two_qubit_name:** name of two qubit gate in ``basis gates`` (default is ``cx``)."
msgstr "該函數的輸入是： - **gate_per_cliff:** 一個包含 gate per Clifford 的字典。 - **epg_2q:** 誤差模型估計的 EPG。 - **qubit_pair:** 用於計算 EPC 的 2 個量子位元的索引。 - **list_epgs_1q:** `` qubit_pair`` 中列出的量子位元的單個量子位元 EPG 清單。 - **two_qubit_name:**``basic gates`` 中的兩個量子位元閘的名稱（預設為``cx``）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:769
msgid "Run an RB Sequence with T1,T2 Errors"
msgstr "以 T1、T2 誤差執行 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:771
msgid "We now choose RB sequences that contain only 2-qubit Cliffords."
msgstr "我們現在選擇只含有兩個量子位元Cliffords 的RB序列。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:773
msgid "We execute these sequences as before, but with a noise model extended with T1/T2 thermal relaxation error, and fit the exponentially decaying curve."
msgstr "我們像以前一樣執行這些序列，但額外考慮進一個具有 T1/T2 熱弛緩誤差的噪音模型，並使用指數衰減曲線進行擬合。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:900
msgid "We count again the number of **gates per Clifford** as before, and calculate the **two-qubit Clifford gate error**, using the predicted primitive gate errors from the coherence limit."
msgstr "我們如同之前一樣再次計算**gates per Clifford** 並使用從同調性極限所預測出的原始閘誤差來計算 **two-qubit Clifford gate error**。"


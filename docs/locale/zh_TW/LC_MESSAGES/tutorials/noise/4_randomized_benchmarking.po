msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-05 21:02+0000\n"
"PO-Revision-Date: 2022-01-05 22:39\n"
"Last-Translator: \n"
"Language-Team: Chinese Traditional\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/noise/4_randomized_benchmarking.po\n"
"X-Crowdin-File-ID: 9138\n"
"Language: zh_TW\n"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:10
msgid "This page was generated from `tutorials/noise/4_randomized_benchmarking.ipynb`__."
msgstr "此頁面是從 `tutorials/noise/4_randomized_benchmarking.ipynb`__ 產生的。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:9
msgid "Randomized Benchmarking"
msgstr "設立隨機化基準"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:12
msgid "Introduction"
msgstr "簡介"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:14
msgid "**Randomization benchmarking (RB)** is a well-known technique to measure average gate performance by running sequences of random Clifford gates that should return the qubits to the initial state. Qiskit Ignis has tools to generate one- and two-qubit Clifford gate sequences simultaneously."
msgstr "**Randomization benchmarking (RB)** 是一種眾所周知的方法，可通過執行隨機Clifford閘的序列來測量平均閘效能，這些序列會將量子位元返回到初始狀態。 Qiskit Ignis 有工具可以同時產生一個和兩個量子位元的 Clifford 的閘序列。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:16
msgid "This notebook gives an example for how to use the ``ignis.verification.randomized_benchmarking`` module. This particular example shows how to run 2-qubit randomized benchmarking (RB) simultaneous with 1-qubit RB. There are also examples on how to use some of the companion functions for predicting RB fidelity."
msgstr "此筆記本提供了如何使用 ``ignis.verification.randomized_benchmarking`` 模組的範例。 此特定範例顯示如何與單量子位元 RB 同時執行雙量子位元 RB。 也有一些例子說明如何使用一些伴隨函數來預測 RB 的保真度。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:49
msgid "1) Select the Parameters of the RB Run"
msgstr "1）選取 RB 執行的參數"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:51
msgid "First, we need to choose the following parameters:"
msgstr "首先，我們需要選擇以下參數："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:53
msgid "**nseeds:** The number of seeds. For each seed you will get a separate list of output circuits in rb_circs."
msgstr "**nseeds:** 種子數。 對於每一個種子，您將取得 rb_circs 中個別輸出電路清單。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:54
msgid "**length_vector:** The length vector of Clifford lengths. Must be in ascending order. RB sequences of increasing length grow on top of the previous sequences."
msgstr "**length_vector：** Clifford 長度向量的長度必須是以遞增順序排列。 增加長度的 RB 序列以前序列為基礎增長。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:55
msgid "**rb_pattern:** A list of the form [[i,j],[k],…] which will make simultaneous RB sequences where Qi,Qj are a 2-qubit RB sequence and Qk is a 1-qubit sequence, etc. The number of qubits is the sum of the entries. For ‘regular’ RB the qubit_pattern is just [[0]],[[0,1]]."
msgstr "**rb_pattern:** 為一個以 [[i, j], [k],...] 格式的清單，此清單將同時生成 RB 序列，其中 Qi 和 Qj 是二量子位元 RB 序列，Qk 是一量子位元序列等。量子位元的數目是輸入項目的總和。 對於 ‘regular’ RB 而言， 其 qubit_pattern 即為 [[0]],[[0,1]]。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:56
msgid "**length_multiplier:** If this is an array it scales each rb_sequence by the multiplier."
msgstr "**length_multiplier:** 如果這是一個陣列，其將對每一個 rb_sequence 乘以一個乘數。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:57
msgid "**seed_offset:** What to start the seeds at (e.g. if we want to add more seeds later)."
msgstr "**seed_offset:** 種子起始位置（例如，如果稍後要新增更多種子）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:58
msgid "**align_cliffs:** If true adds a barrier across all qubits in rb_pattern after each set of cliffords."
msgstr "**align_cliffs:** 如果為真，則在 rb_pattern 中所有量子位元的每組 Cliffords 之後，都會新增一個屏障。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:60
msgid "In this example we have 3 qubits Q0,Q1,Q2. We are running 2Q RB (on qubits Q0,Q2) and 1Q RB (on qubit Q1) simultaneously, where there are twice as many 1Q Clifford gates."
msgstr "在此範例中，我們有 3 個量子位元 Q0，Q1，Q2。 我們同時執行 2Q RB （在量子位元 Q0、Q2 上）和 1Q RB （在量子位元 Q1 上），其中有兩倍多的 1Q Clifford閘。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:92
msgid "2) Generate the RB sequences"
msgstr "2）產生其 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:94
msgid "We generate RB sequences. We start with a small example (so it doesn’t take too long to run)."
msgstr "我們產生 RB 序列。 我們從一個小例子開始（如此才不會花太多時間來執行）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:96
msgid "In order to generate the RB sequences **rb_circs**, which is a list of lists of quantum circuits, we run the function ``rb.randomized_benchmarking_seq``."
msgstr "為了產生 RB 序列 **rb_cris**，我們運行了 ` ``rb.randomized_benchmarking_seq`` 函數。(**rb_circs**是一個清單，此清單的每個元素各自為一個量子電路清單。)"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:98
msgid "This function returns:"
msgstr "此函數傳回："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:100
msgid "**rb_circs:** A list of lists of circuits for the rb sequences (separate list for each seed)."
msgstr "**rb_circs:** 對於序列，一個元素為電路清單的清單（每一個種子的個別清單）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:101
msgid "**xdata:** The Clifford lengths (with multiplier if applicable)."
msgstr "**xdata:** Clifford 長度（適用時具有乘數）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:127
msgid "As an example, we print the circuit corresponding to the first RB sequence:"
msgstr "舉例，我們列印對應於第一個 RB 序列的電路："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:247
msgid "Look at the Unitary for 1 Circuit"
msgstr "請看此相對於一個電路的么正矩陣"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:258
msgid "The Unitary representing each RB circuit should be the identity (with a global phase), since we multiply random Clifford elements, including a computed reversal gate. We simulate this using an Aer unitary simulator."
msgstr "因為我們乘以隨機的 Clifford 元素及其對應的反轉閘，故每個 RB 電路的么正矩陣應是單位矩陣（帶有全局相位）。我們用一個 Aer 幺正模擬器來模擬這個情況。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:341
msgid "Define the noise model"
msgstr "定義雜訊模型"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:352
msgid "We define a noise model for the simulator. To simulate decay, we add depolarizing error probabilities to the CNOT and U gates."
msgstr "我們為此模擬器定義了一個雜訊模型。 為了模擬衰變，我們在 CNOT 和 U 閘上增加了去極化誤差機率。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:379
msgid "3) Execute the RB sequences on Aer simulator"
msgstr "3）在 Aer 模擬器上執行 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:381
msgid "We can execute the RB sequences either using a Qiskit Aer Simulator (with some noise model) or using an IBMQ provider, and obtain a list of results, ``result_list``."
msgstr "我們可以使用 具有某種雜訊模型的Qiskit Aer Simulator或使用 一個 IBMQ provider 以執行 RB 序列，並取得結果清單 ``result_list``。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:469
msgid "4) Fit the RB results and calculate the gate fidelity"
msgstr "4）擬合其 RB 結果並計算其閘的保真度"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:472
msgid "Get statistics about the survival probabilities"
msgstr "取得存活機率的統計資料"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:474
msgid "The results in **result_list** should fit to an exponentially decaying function :math:`A \\cdot \\alpha ^ m + B`, where :math:`m` is the Clifford length."
msgstr "**result_list** 中的結果應可被指數衰減函數 :math:`A \\cdot \\alpha ^ m + B` 擬合，其中 :math:`m` 是 Clifford 的長度。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:476
msgid "From :math:`\\alpha` we can calculate the **Error per Clifford (EPC)**:"
msgstr "從 :math:`\\alpha` 我們可以計算其 **Error per Clifford (EPC)**："

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:478
msgid "EPC = \\frac{2^n-1}{2^n} (1-\\alpha)\n\n"
msgstr ""

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:480
msgid "(where :math:`n=nQ` is the number of qubits)."
msgstr "（其中 :math:`n=nQ` 是量子位元的數目）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:503
msgid "Plot After 1 Seed"
msgstr "在執行一次種子之後的圖表"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:545
msgid "Plot with the Rest of the Seeds"
msgstr "對應於剩餘次數種子的圖表"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:547
msgid "The plot is being updated after each seed."
msgstr "在每執行一次種子之後，該圖都會被更新。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:601
msgid "Add more shots to the data"
msgstr "增加量測次數並將結果添加至原有的數據"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:720
msgid "Predicted Gate Fidelity"
msgstr "預測的閘保真度"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:731
msgid "From the known depolarizing errors on the simulation we can predict the **fidelity**. First we need to count the number of **gates per Clifford**."
msgstr "可以根據模擬中已知的去極化錯誤來預測 **fidelity**。 首先，我們需要計算 **gates per Clifford** 的數量。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:733
msgid "The function **gates_per_clifford** takes a list of transpiled RB circuits and outputs the number of basis gates in each circuit."
msgstr "此函數 **gates_per_clifford** 輸入轉譯 RB 電路的清單並輸出每一個電路中的基底閘之數量。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:791
msgid "The function **calculate_2q_epc** gives measured errors in the basis gates that were used to construct the Clifford. It assumes that the error in the underlying gates is depolarizing. It outputs the error per a 2-qubit Clifford."
msgstr "此函數 **calculate_2q_epc** 會給出基底閘中用來建構 Clifford 的測量誤差。 它假設基底閘中的誤差是去極化的，並會針對每一個二量子位元的 Clifford 輸出對應的誤差。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:793
msgid "The input to this function is: - **gate_per_cliff:** dictionary of gate per Clifford. - **epg_2q:** EPG estimated by error model. - **qubit_pair:** index of two qubits to calculate EPC. - **list_epgs_1q:** list of single qubit EPGs of qubit listed in ``qubit_pair``. - **two_qubit_name:** name of two qubit gate in ``basis gates`` (default is ``cx``)."
msgstr "該函數的輸入是： - **gate_per_cliff:** 一個包含 gate per Clifford 的字典。 - **epg_2q:** 誤差模型估計的 EPG。 - **qubit_pair:** 用於計算 EPC 的 2 個量子位元的索引。 - **list_epgs_1q:** `` qubit_pair`` 中列出的量子位元的單個量子位元 EPG 清單。 - **two_qubit_name:**``basic gates`` 中的兩個量子位元閘的名稱（預設為``cx``）。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:848
msgid "Run an RB Sequence with T1,T2 Errors"
msgstr "以 T1、T2 錯誤執行 RB 序列"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:850
msgid "We now choose RB sequences that contain only 2-qubit Cliffords."
msgstr "我們現在選擇只含有兩個量子位元 Cliffords 的 RB 序列。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:852
msgid "We execute these sequences as before, but with a noise model extended with T1/T2 thermal relaxation error, and fit the exponentially decaying curve."
msgstr "我們像之前一樣執行這些序列，但額外考慮進一個具有 T1/T2 熱弛緩誤差的雜訊模型，並使用指數衰減曲線進行擬合。"

#: ../../tutorials/noise/4_randomized_benchmarking.ipynb:993
msgid "We count again the number of **gates per Clifford** as before, and calculate the **two-qubit Clifford gate error**, using the predicted primitive gate errors from the coherence limit."
msgstr "我們如同之前一樣再次計算 **gates per Clifford** 並使用從同調性極限所預測出的原始閘誤差來計算 **two-qubit Clifford gate error**。"


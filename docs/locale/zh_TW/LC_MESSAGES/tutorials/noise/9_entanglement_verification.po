msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-17 18:35+0000\n"
"PO-Revision-Date: 2021-06-22 05:05\n"
"Last-Translator: \n"
"Language-Team: Chinese Traditional\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/noise/9_entanglement_verification.po\n"
"X-Crowdin-File-ID: 9380\n"
"Language: zh_TW\n"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:10
msgid "This page was generated from `tutorials/noise/9_entanglement_verification.ipynb`__."
msgstr "此頁面是從 `tutorials/noise/9_entanglement_verification.ipynb`__ 產生的。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:12
msgid "Run interactively in the `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/9_entanglement_verification.ipynb>`_."
msgstr "在 `IBM Quantum lab <https://quantum-computing.ibm.com/jupyter/tutorial/noise/9_entanglement_verification.ipynb>`_中互動執行。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:9
msgid "Entanglement Verification"
msgstr "糾纏驗證"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:12
msgid "Introduction to the GHZ state"
msgstr "GHZ 狀態簡介"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:14
msgid "**The Greenberger-Horne-Zeilinger (GHZ)** State is a :math:`n`-qubit entangled state best defined by the following state vector:"
msgstr "**The Greenberger-Horne-Zeilinger (GHZ)** 狀態是一個 :math:`n`-qubit 糾纏態。此糾纏態可被以下狀態向量最完美的定義:"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:16
msgid "|{\\rm GHZ} \\rangle = \\frac{|0 \\rangle ^{\\otimes n} + |1 \\rangle ^{\\otimes n}}{\\sqrt{2}} , n > 2\n\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:18
msgid "Characterization of the GHZ state is very useful in assessing multi-qubit interactions, whose robustness is key to developing large scale quantum computers."
msgstr "GHZ 狀態的測量對評估多量子位元互動很有幫助，它的穩健性是開發大規模量子計算機的關鍵。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:21
msgid "Characterizing a quantum state"
msgstr "測量一個量子態"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:23
msgid "Any mixed quantum state can be identified by a density matrix, defined as :math:`\\rho = \\sum_{i} p_i |\\psi_{i} \\rangle \\langle \\psi_{i}|`, where :math:`|\\psi_{i} \\rangle` are the pure quantum states forming the mixture and :math:`0 < p_i \\le 1`, :math:`\\sum_{i} p_i = 1` are the classical probabilities to be in state :math:`|\\psi_{i} \\rangle`. We denote the pure density matrix of an ideal GHZ State by :math:`\\rho_{p} \\equiv |{\\rm GHZ} \\rangle \\langle {\\rm GHZ}|`. We want to see how close this matrix is to the density matrix of a GHZ State as produced in an experiment, :math:`\\rho_{T}`. One method to quantify this similarity is to calculate the fidelity between the states, :math:`F(\\rho_{p},\\rho_{T})`"
msgstr "任何混合量子態都可以通過定義為 :math:`\\rho = \\sum_{i} p_i |\\psi_{i} \\rangle \\langle \\psi_{i}|`的密度矩陣來識別，其中 :math:`|\\psi_{i} \\rangle` 是用來形成混合態的純態，而 :math:`0 < p_i \\le 1`, :math:`\\sum_{i} p_i = 1` 是處於狀態 :math:`|\\psi_{i} \\rangle`的經典概率。 我們將理想的GHZ態的純密度矩陣表示為:math:`\\rho_{p} \\equiv |{\\rm GHZ} \\rangle \\langle {\\rm GHZ}|`。 我們想要查看此密度矩陣和實驗產生的 GHZ狀態密度矩陣 :math:`\\rho_{T}`之間距離多遠。有一種方法可以藉由計算其狀態之間的保真度 :math:`F(\\rho_{p},\\rho_{T})`，以量化此相似性。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:26
msgid "F = \\Big[ Tr \\sqrt{\\sqrt{\\rho_{p}}\\rho_{T}\\sqrt{\\rho_{p}}} \\Big] ^{2}\n\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:28
msgid "The aim of this tutorial is two-fold: we will explore ways in which we can characterize the GHZ state, and ways in which we can use Ignis’ error mitigation tools to increase readout fidelity, regardless of characterization method"
msgstr "本教程的目的有兩方面：我們將探索測量 GHZ 狀態的方式，以及可以利用 Ignis 的錯誤緩解工具以增加讀出保真度的方式，不論其測量方法。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:30
msgid "Before we go further, let us import everything we will need from basic Qiskit:"
msgstr "在我們進一步之前，讓我們從基本的 Qiskit 匯入我們將需要的所有東西："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:63
msgid "The next two functions are from ignis. The first is for the general error mitigation technique, and the second is specifically for quantum tomography"
msgstr "接下來的兩個功能來自 ignis。 第一個是針對一般的錯誤緩解技術，而第二個是專門用於量子斷層掃描。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:86
msgid "The following import from the ``entanglement`` package contains information needed to create, parallelize and analyze GHZ State circuits"
msgstr "以下從``entanglement`` 套件匯入的項目包含建立、平行化及分析 GHZ 狀態電路所需的資訊"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:110
msgid "Preparing a GHZ State"
msgstr "準備一個 GHZ 狀態"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:112
msgid "Let us first go over how to prepare a GHZ State:"
msgstr "讓我們先一起來看如何準備一個 GHZ 狀態："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:114
msgid "Say we have a system of :math:`n` qubits, all prepared in the :math:`|0\\rangle` state:"
msgstr "假設我們有一個 :math:`n` 量子位元的系統，這些:math:`n` 個量子位元都被準備在 :math:`|0\\rangle`狀態中："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:116
msgid "|\\psi \\rangle = |00...0\\rangle\n\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:118
msgid "We apply a Hadamard gate to the first qubit: :math:`|0\\rangle \\longrightarrow \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)`. Our state now looks like:"
msgstr "我們將 Hadamard 閘套用至第一個量子位元： :math:`|0\\rangle \\longrightarrow \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)`。 我們現在的狀態看起來如下："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:120
msgid "|\\psi \\rangle = \\frac{|00...0\\rangle + |10...0\\rangle}{\\sqrt{2}}\n\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:122
msgid "Applying on this state a sequence of :math:`n-1` CNOT gate between the :math:`n^{th}` and :math:`(n+1)^{th}` qubits for :math:`n = 0 \\ldots n-1` leaves the :math:`n+1` qubit at :math:`|0\\rangle` if the :math:`n^{th}` is in :math:`|0\\rangle`, and at :math:`|1\\rangle` if the :math:`n^{th}` is in :math:`|1\\rangle`, thus creating the GHZ State:"
msgstr "把一個在第:math:`n^{th}` 和第 :math:`(n+1)^{th}` 對應於:math:`n = 0 \\ldots n-1`的量子位元之間的 :math:`n-1`CNOT閘 的序列套用到此狀態上，如果第:math:`n^{th}` 是處於 :math:`|0\\rangle`則使得第:math:`n+1`個量子位元處於:math:`|0\\rangle`，如果第:math:`n^{th}` 是處於 :math:`|1\\rangle`則使得第:math:`n+1`個量子位元處於:math:`|1\\rangle`。如此我們則可以建立一個 GHZ 態。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:124
msgid "|GHZ \\rangle = \\frac{|00...0\\rangle + |11...1\\rangle}{\\sqrt{2}} \\equiv \\frac{|0 \\rangle ^{\\otimes n} + |1 \\rangle ^{\\otimes n}}{\\sqrt{2}}\n\n"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:126
msgid "The following function creates this “linear” circuit that can measure the GHZ state:"
msgstr "以下函數會建立可以測量 GHZ 狀態的這個“線性”電路："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:203
msgid "Characterization, Part I"
msgstr "測量，第一部分"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:206
msgid "Multiple Quantum Coherence (MQC)"
msgstr "多重量子相干（MQC）"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:208
msgid "Multiple Quantum Coherence (MQC) works by taking the preliminary preparation of an :math:`n` qubit GHZ State, and rotating each of the qubit states around the z axis by a phase :math:`\\phi`. After that, we apply a X gate, i.e., a :math:`\\pi` pulse around the x axis. Then, we apply the inverse of the operations we originally applied to get the GHZ state. In an ideal situation the final state is :math:`|\\psi \\rangle = \\frac{|0 \\rangle ^{\\otimes n} + e^{i n \\phi}|1 \\rangle ^{\\otimes n}}{\\sqrt{2}}`. We can ideally observe the phase collected by projecting :math:`|\\psi \\rangle` onto the state :math:`|0 \\rangle ^{\\otimes n}`. This technique is reminiscent of an echo sequence, and has been shown to substantially improve the fidelity during readout."
msgstr "多重量子相干(MQC) 通過以下方式來執行。首先準備 :math:`n` 量子位元 GHZ 狀態並把每個量子位狀態以 z 軸為軸旋轉相位 :math:`\\phi` 。 接著，我們套用一個 X 閘，也就是一個以 x 軸旋轉 ​:math:`\\pi` 的脈衝。然後，我們採取相反於原先用來獲得 GHZ 狀態的操作。 理想情況下，其最終狀態是 :math:`|\\psi \\rangle = \\frac{|0 \\rangle ^{\\otimes n} + e^{i n \\phi}|1 \\rangle ^{\\otimes n}}{\\sqrt{2}}`。 我們可以理想地觀察通過將 :math:`|\\psi \\rangle` 投影到狀態 :math:`|0 \\rangle ^{\\otimes n}` 所上獲得的相位。此方法讓人想起迴聲序列，並且已被證明可以顯著改善讀取時的保真度。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:211
msgid "The function below creates a linear MQC circuit. As with every circuit from here on, you can change the ``full_measurement`` argument to toggle between full measurement of all qubits or measurement of only the control qubit. Full measurement yields the most accurate results, but for more than 7 qubits, it is recommended to set it to false, and observe only the oscillations between the ``'0'`` and ``'1'`` states."
msgstr "以下函數會建立一個線性 MQC 電路。 與這裡的每一個電路一樣，您可以變更 ``full_measurement`` 選項，以在完整測量所有量子位元或僅測量控制量子位元之間切換。 完整的測量會產生最精確的結果，但如果是超過 7 個量子位元的情況，建議將它設為 false ，並只觀察 ``'0'`` 與 ``'1'`` 狀態之間的震盪。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:286
msgid "After running experiments on this MQC circuit, we can pick a state to observe oscillations as we sweep :math:`\\phi` from :math:`0` to :math:`2 \\pi`. Our signal in theory should follow :math:`S(\\phi) = \\frac{1}{2}(1+\\cos(n \\phi))`. We then perform a Discrete Fourier Transform (DFT: :math:`I_{v}=(1/N)|\\sum_{\\phi}e^{iv\\phi}S(\\phi)`) to extract the Fidelity of the state, defined by the bounds :math:`2\\sqrt{I_{n}} \\leq F \\leq \\sqrt{I_{0}/2}+ \\sqrt{I_{n}}`; if desired, an actual value for the fidelity can be obtained: :math:`F = \\frac{1}{2}(P_{00...0}+P_{11...1})+\\sqrt{I_{n}})` (arXiv:1905.05720)."
msgstr "在這個MQC電路上做完實驗後，可以選擇一個狀態來觀察當我們把角度:math:`\\phi`從 :math:`0`掃到 :math:`2 \\pi`的震盪。 理論上，我們的訊號應該遵循 :math:`S(\\phi) = \\frac{1}{2}(1+\\cos(n \\phi))`。 然後我們執行一個離散傅立葉變換(DFT: :math:`I_{v}=(1/N)|\\sum_{\\phi}e^{iv\\phi}S(\\phi)`) 以汲取該狀態被邊界條件所定義的保真度:math:`2\\sqrt{I_{n}} \\leq F \\leq \\sqrt{I_{0}/2}+ \\sqrt{I_{n}}`; 想要的話，我們也可以獲得一個保真度的實際值 :math:`F = \\frac{1}{2}(P_{00...0}+P_{11...1})+\\sqrt{I_{n}})` (arXiv:1905.05720)。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:299
msgid "Parity Oscillations"
msgstr "宇稱震盪"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:301
msgid "The next method we use to characterize the GHZ state is parity oscillations. After preparing a GHZ state, we apply a combination of rotations about the x and y axes to create various superposition states as a function of :math:`\\phi`: :math:`U(\\phi) = \\otimes_{j}^{N} e^{i\\frac{\\pi}{4}(\\cos(\\phi)\\sigma_{x}^{j}+\\sin(\\phi)\\sigma_{y}^{j})}`. We then measure the expectation value :math:`\\langle \\otimes_{j}^{N} \\sigma_{z}^{j} \\rangle_{\\phi}` as a function of :math:`\\phi`, which in theory should lead to parity oscillations between 1 and -1."
msgstr "用於測量 GHZ 狀態的下一種方法是宇稱震盪。 準備好一個 GHZ 狀態後，我們套用一個以x 軸和 y 軸的旋轉組合以創建各種疊加狀態，該疊加狀態是一個函數，其自變數為 :math:`\\phi`: :math:`U(\\phi) = \\otimes_{j}^{N} e^{i\\frac{\\pi}{4}(\\cos(\\phi)\\sigma_{x}^{j}+\\sin(\\phi)\\sigma_{y}^{j})}`。我們接著測量期望值:math:`\\langle \\otimes_{j}^{N} \\sigma_{z}^{j} \\rangle_{\\phi}`，此期望值是一個函數，其自變數為 :math:`\\phi`，這在理論上應該會導致 1 和 -1 之間的宇稱震盪。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:304
msgid "The following function generates a circuit which is the Parity Oscillation equivalent of the MQC circuit given above"
msgstr "以下的函數會產生一個等效於上述 MQC 電路的宇稱震盪電路。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:353
msgid "We can obtain fidelity for parity oscillations :math:`S_{\\phi}` from :math:`F = \\frac{1}{2}(P_{00...0}+P_{11...1}+C)`, where :math:`C`, the coherence is defined as :math:`2\\sqrt{I_{n}}`, following the same convention for the DFT as with the MQC method."
msgstr "從 :math:`F = \\frac{1}{2}(P_{00...0}+P_{11...1}+C)` 我們可以得到宇稱震盪的保真度 :math:`S_{\\phi}`，其中 :math:`C`是相干，其定義為:math:`2\\sqrt{I_{n}}`，遵循和在 MQC 方法中 DFT 的相同表達式。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:365
msgid "Tomography"
msgstr "斷層掃描"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:367
msgid "Tomography measures the density matrix by producing many nominally identical states and measuring the state instances in different bases. The ideal result of a GHZ state is four equal density matrix elements at the 4 corners of the tensor-product basis, with all other elements vanishing. Although the fidelity can be readily calculated by this method, the method is slow (requires exponential number of measurements in n), and takes prohibitively long times if n is larger than 7 or so. Nevertheless, we will show below how to perform this method as it is relevant for small numbers of qubits."
msgstr "斷層掃描通過產生許多名義上相同的狀態並在不同基底中測量不同的狀態實例，以測量密度矩陣。 GHZ 狀態的理想結果是在張量積的四個角落的密度矩陣元素彼此相同，而所有其他元素消失不見。 雖然這種方法可以很容易地計算保真度，但此方法是緩慢 (需要指數數量級的 n 次量測)，並且如果 n 大於 7 左右，則該方法需要長到難以實現的時間來運行。 不過，我們會在下面演示如何執行此方法，因為它在少量的量子位元情況下還是可行的。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:380
msgid "Parallelizing circuits"
msgstr "並行化電路"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:382
msgid "The above “linear” circuits are good to perform simulations, but what do we do when we use real devices, where the system can have an arbitrary topology and various errors? We are specifically targeting real hardware here, not just Aer simulation. One technique to reduce real-hardware effects is to parallelize the CNOT gates and thus create a shorter-depth circuit. This can be hugely beneficial efficiency wise, and fidelity wise. The class ``BConfig`` from the module ``parallelize`` does exactly this."
msgstr "上面的“線性”電路非常適合運行模擬，但當我們使用真實器件時，由於每個系統具有一個任意的拓撲(toplogy) 並且會發生各種錯誤，我們該怎麼辦？ 我們的目標是真正的硬體，而不僅僅是 Aer 模擬。 減少實際硬件影響的一種方法是通過並行化 CNOT 閘來創建較淺層的電路。 這在效率和保真度方面都是非常有益的。 ``parallelize``模組中的`BConfig`` 類別即可完成上述的任務。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:385
msgid "First we must configure the optimal backend we want to use. We will consider a simulation backend, ``'ibmq_qasm_simulator'``, disguised as a real device, ``'ibmq_16_melbourne'`` by using a the mock backend ``'FakeMelbourne'``"
msgstr "首先，我們必須配置我們想要使用的最佳後端。 我們將考慮透過一個仿效後端``'FakeMelbourne'``將一個模擬後端 ``'ibmq_qasm_simulator'``偽裝成一個真實器件``'ibmq_16_melbourne'``。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:409
msgid "Using the ``noise`` module, we can now define a noise model from ``'ibmq_16_melbourne'`` to “assign” to ``'ibmq_qasm_simulator'``."
msgstr "通過使用此 ``噪音`` 模組，我們現在可以在 ``'ibmq_16_melbourne'`` 中定義一個噪音模型並將之“指派(assign)”到``'ibmq_qasm_simulator'``。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:432
msgid "And there we have it. From now on, in the tutorial, when using a real device, not a simulation, just take out every mention and assignment of ``noise_model`` and ``coupling_map``, and assign the real device to ``backend``. The simulator used from now on is no substitute for running a real device."
msgstr "好的現在我們擁有它了。 從現在開始，在此教程中當我們使用真實器件而非模擬時，請刪除對 ``noise_model`` 和 ``couple_map`` 的所有提及(mention) 和指派(assignment)，並將真實器件指派(assign) 給 ``backend``。 從現在開始使用的模擬器，無法替代執行真實器件。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:443
msgid "``BConfig`` lays the blueprint for creating parallelized circuits. Let us initialize an object taking in the real device we just defined, and name it ``protocirc``. All of our experiments will use it:"
msgstr "``BConfig`` 為建立平行化電路勾勒其藍圖。 讓我們初始化一個物件(此物件會把我們剛才定義的真實器件作為輸入)，並將其命名為 ``protocirc``。我們的所有實驗都將會使用它："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:465
msgid "Error Mitigation"
msgstr "錯誤緩解"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:467
msgid "Qiskit Ignis provides very accurate tools to take raw data and return calibrated data. This is done by getting the raw data, in the form of a vector :math:`v_{raw}` and getting a calibration matrix :math:`A`. The output is then the solution to the optimization problem: :math:`argmin_{v_{cal}} ||Av_{cal}-v_{raw}||^{2}`"
msgstr "Qiskit Ignis 為輸入原始數據和輸出校準過的數據提供了非常準確的工具。 這是通過取得向量 :math:`v_{raw}` 形式原始數據，以及取得一個校正矩陣 :math:`A`。 則其輸出會是一個最佳化問題的解: :math:`argmin_{v_{cal}} ||Av_{cal}-v_{raw}||^{2}`"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:479
msgid "Experiment Time"
msgstr "實驗時間"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:482
msgid "Preliminary Steps"
msgstr "初步步驟"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:484
msgid "The probabilities of measuring :math:`|0\\rangle ^{\\otimes n}` and :math:`|1\\rangle^{\\otimes n}` in the GHZ state are important in calculating fidelity. For this, we need to run the following test"
msgstr "在 GHZ 狀態中，測量 :math:`|0\\rangle ^{\\otimes n}` 和 :math:`|1\\rangle^{\\otimes n}`的機率在計算保真度時非常重要。 為此，我們需要執行以下測試"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:495
msgid "We begin by defining standard execution parameters:"
msgstr "我們首先定義標準執行參數："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:845
msgid "Now with error mitigation:"
msgstr "現在，在有錯誤緩解的情況下："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:975
msgid "We will load these values in a dictionary for assessing fidelity later on:"
msgstr "我們將把這些值載入到一個字典中，以便稍後評估保真度："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:997
msgid "Part 1 : MQC"
msgstr "第一部分：MQC"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:999
msgid "We now retrieve a parallelized MQC circuit for the n qubit device"
msgstr ""

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1057
msgid "We now execute the MQC experiment:"
msgstr "我們現在執行該 MQC 實驗："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1100
msgid "Now we will plot the amount of counts measured for :math:`|0 \\rangle ^{\\otimes n}` as a function of phase. It is important to note that when using a parametrized circuit like the one here, the method ``get_counts()`` accepts an **index** and not a **circuit**. In any other type of experiment, ``get_counts()`` accepts a **circuit**."
msgstr "現在，我們將繪製出函數 y(x)，其 y 軸為 :math:`|0 \\rangle ^{\\otimes n}` 測量的計數量，x軸為相位。 請務必注意，當使用類似此參數化的電路時，該方法 ``get_counts()`` 接受一個 **索引(index)** ，而不是 **電路(circuit) **。 在任何其他類型的實驗中， ``get_counts()`` 接受一個 **電路 **。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1131
msgid "Now we get started on error mitigation. We create an identical quantum register and use complete_meas_cal from Ignis, to create circuits for calibrated measurements to be executed, and a calibration matrix."
msgstr "現在，我們開始進行錯誤緩解。 我們建立一個相同的量子暫存器，並使用 Ignis 的 complete_meas_cal ，來建立一個用來執行校正測量的電路，以及一個校正矩陣。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1197
msgid "Finally, we have our error mitigated results:"
msgstr "最後，我們得到了錯誤緩解過後的結果。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1218
msgid "We can see how the error mitigated results yield a far greater fidelity than the raw data"
msgstr "我們可以看到錯誤緩解過後的結果產生的保真度遠大於用原始資料對應的保真度。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1333
msgid "We now plot the DFT and compare the heights of the peaks to give bounds for the fidelity"
msgstr "我們現在繪製其 DFT ，並比較峰值的高度來為保真度設定界限。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1344
msgid "Statistical bootstrapping has found that the error on these measurements is at most 1.5% (arXiv 1905.05720), so these result fall within error bounds, despite the fidelity being slightly higher than the upper bound, and show how error mitigation dramatically increases fidelity"
msgstr "通過統計自助抽樣法我們發現這些測量的錯誤最多為 1.5% (arXiv 1905.05720)，所以即使保真度略高於上限，這些結果也在錯誤範圍內。這些結果也顯示錯誤緩解顯著提高了保真度。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1356
msgid "Part 2: Parity Oscillation"
msgstr "第 2 部分：宇稱震盪"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1358
msgid "We now retrieve a parallelized Parity Oscillation circuit for the n qubit device, and run experiments in the same fashion as we did in MQC."
msgstr "我們現在檢索一個對應於 n 量子位元器件的平行化宇稱震盪電路(Parity Oscillation circuit)，並與我們在 MQC中所做的一樣執行實驗。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1449
msgid "Now we construct the :math:`\\otimes _{j}^{N} \\sigma_z^{j}` matrix for instruction, although this is already taken into account in the following method, ``entanglement.analysis.composite_pauli_z_expvalue()``:"
msgstr "現在我們建構 :math:`\\otimes _{j}^{N} \\sigma_z^{j}`以作指示，雖然已在以下方法中考量過：``entanglement.analysis.composite_pauli_z_expvalue()``:"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1472
msgid "Now we want to make sure that our list of counts is correctly ordered so that it coincides with the states of the :math:`\\otimes _{j}^{N} \\sigma_z^{j}`, so that calculating :math:`\\langle \\otimes _{j}^{N} \\sigma_z^{j} \\rangle` will be as simple as taking the dot product of this ordered list with the diagonal of :math:`\\otimes _{j}^{N} \\sigma_z^{j}`. The ``composite_pauli_z_expvalue`` function does just that; it takes a circuit and appropriately orders the state vector counts. We can plot this dot product as a function of :math:`\\phi` to observe parity oscillations."
msgstr "現在我們想要確保計數清單是被正確地排序以匹配以下狀態：:math:`\\otimes _{j}^{N} \\sigma_z^{j}`。 如此一來，計算 :math:`\\langle \\otimes _{j}^{N} \\sigma_z^{j} \\rangle` 會變得和取此有序清單和 :math:`\\otimes _{j}^{N} \\sigma_z^{j}`對角線的內積一樣簡單。\n"
"此``composite_pauli_z_expvalue`` 函數即可完成上述工作。此函數輸入一個電路並合適地排序狀態向量的計數。我們可以以:math:`\\phi`為自變量繪製出這個內積的函數，以觀察宇稱震盪。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1523
msgid "Now for standard error mitigation:"
msgstr "現在，對於標準錯誤緩解："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1618
msgid "We can see how error mitigation dramatically improves our measurement (much more so in PO than in MQC). Let us quantify this using the same DFT method we used in MQC, and calculating the actual fidelities:"
msgstr "我們可以看到錯誤緩解顯著改善了我們的測量（在PO的情況比在MQC更加顯著 ）。 讓我們對此進行量化並使用 MQC 中使用的相同 DFT 方法計算實際保真度。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1696
msgid "As we see, the raw fidelity is much lower than what is achieved with MQC, but the error mitigated result is about the same."
msgstr "如我們所見，其原始保真度遠低於 MQC 所達成的效果，但錯誤緩解的結果則是差不多相同的。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1708
msgid "Part 3: Tomography"
msgstr "第3部分: 斷層掃描"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1710
msgid "The first step in this experiment to just pass a simple GHZ state with *no* measurements. Also, the circuit cannot be transpiled; the ``transpiled`` argument in the ``getGHZChecker()`` method can be turned on and off as is shown"
msgstr "此實驗中的第一個步驟，只是要傳遞一個簡單的 GHZ 狀態與該狀態耦合在一起的 *no* 測量。 此外，該電路不能被轉譯；在 ``getGHZChecker()`` 方法中的 ``transpiled`` 選項可以被開啟和關閉，如所示:"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1745
msgid "We now pass a simulated backend from ``Aer`` to get theoretical statevector counts"
msgstr "我們現在從 ``Aer`` 傳遞一個模擬的後端，以取得理論狀態向量計數。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1788
msgid "This following code runs tomography experiments on the circuit we defined first, which is then compared to the theoretical statevector to generate a density matrix"
msgstr "以下程式碼是在我們最先定義的電路上進行斷層掃描實驗，然後與理論狀態向量比較以生成一個密度矩陣。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1840
msgid "From here we can get the fidelity, although this method is not as fool proof as the one we will get to eventually:"
msgstr "從這裡我可以獲得其保真度，雖然此方法不如我們最後會討論到的方法防呆。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1861
msgid "…And now for error mitigation…"
msgstr "…而現在對於錯誤緩解…"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1939
msgid "Now, using ``qiskit.visualization``, we can plot the raw density matrix, real, and imaginary parts being on separate plots,…"
msgstr "現在，使用 ``qiskit.visualization``，我們可以將原始密度矩陣、實數、和虛數部分繪製在個別圖形上，…"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:1978
msgid "And also the error mitigated density matrix,…"
msgstr "並且經過錯誤緩解的密度矩陣，…"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2017
msgid "The actual density matrices can be obtained using the ``fit()`` method. Once we have the density matrix, we can compute the fidelity, which is nothing but half the sum of the four corners of the density matrix; the following method helps us:"
msgstr "可以使用 ``fit()`` 方法取得實際的密度矩陣。 一旦我們擁有該密度矩陣，我們就可以計算出其保真度，此保真度可由密度矩陣四個角總和的一半簡單地被計算出；以下的方法幫助我們："

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2091
msgid "As we see, the raw fidelity is much lower than what is achieved with either MQC or Parity Oscillations, but the error mitigated result is about the same."
msgstr "如我們所見，原始保真度比 MQC 或 Parity Oscillations可以達到的保真度都要低得多，但世其誤差緩解過後的結果是差不多的。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2093
msgid "**A note on tomography**"
msgstr "** 關於斷層掃描的說明 **"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2095
msgid "Do not perform quantum tomography with >5 qubits"
msgstr "不要使用超過5個量子位元來執行量子斷層掃描"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2107
msgid "Conclusion"
msgstr "結論"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2109
msgid "In conclusion, we see that without error mitigation, MQC is the superior method for characterizing the GHZ state. However, with error mitigation, all methods can, at least for a small number of qubits, achieve a much greater fidelity, and all near the same value. To get more accurate results, aside from using a real device, it is worth increasing the number of shots four to eight-fold. It may be worth comparing how the parallelized circuits used in this notebook perform fidelity-wise versus linearized circuits."
msgstr "結論是，我們看到在沒有錯誤緩解的情況下， MQC 是測量 GHZ 狀態的優越方法。 然而在有錯誤緩解的情況下，所有方法都可以達到了更高的保真度並且都接近相同值，至少對於只有少量的量子位元的情況是如此。 為了取得更準確的結果，除了使用真實的器件之外，將測量次數增加 4 到 8 倍是值得的。以保真度來衡量比較此筆記本中所使用的並行化電路與線性化電路可能是值得的。"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2122
msgid "External collaborators"
msgstr "外部合作者"

#: ../../tutorials/noise/9_entanglement_verification.ipynb:2124
msgid "Rohith Karur"
msgstr "Rohith Karur"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-16 11:25+0000\n"
"PO-Revision-Date: 2023-03-16 11:59\n"
"Last-Translator: \n"
"Language: zh\n"
"Language-Team: Chinese Traditional\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/circuits/3_summary_of_quantum_operations.po\n"
"X-Crowdin-File-ID: 9118\n"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:10
msgid "This page was generated from `tutorials/circuits/3_summary_of_quantum_operations.ipynb`__."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:9
msgid "Summary of Quantum Operations"
msgstr "量子操作摘要"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:20
msgid "In this section we will go into the different operations that are available in Qiskit Terra. These are:"
msgstr "本節我們將介紹 Qiskit Terra 提供不同的操作，包括："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:22
msgid "Single-qubit quantum gates"
msgstr "單量子閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:23
msgid "Multi-qubit quantum gates"
msgstr "多量子閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:24
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3586
msgid "Measurements"
msgstr "測量"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:25
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3828
msgid "Reset"
msgstr "重置"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:26
msgid "Conditionals"
msgstr "條件"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:27
msgid "State initialization"
msgstr "量子態初始化"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:29
msgid "We will also show you how to use the three different simulators:"
msgstr "我們也會向您展示如何使用三種不同的模擬器："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:31
msgid "unitary_simulator"
msgstr "unitary_模擬器"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:32
msgid "qasm_simulator"
msgstr "qasm_模擬器"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:33
msgid "statevector_simulator"
msgstr "statevector_模擬器"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:73
msgid "Single Qubit Quantum states"
msgstr "單量子位元量子態"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:75
msgid "A single qubit quantum state can be written as"
msgstr "單一量子態可以寫成"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:77
msgid "\\left|\\psi\\right\\rangle = \\alpha\\left|0\\right\\rangle + \\beta \\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:79
msgid "where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a measurement the probability of the bit being in :math:`\\left|0\\right\\rangle` is :math:`|\\alpha|^2` and :math:`\\left|1\\right\\rangle` is :math:`|\\beta|^2`. As a vector this is"
msgstr "其中 :math:`\\alpha` 和 :math:`\\beta` 是複數。測量後量子態處於 :math:`\\left|0\\right\\rangle` 的機率是 :math:`|\\alpha|^2`，處於 :math:`\\left|1\\right\\rangle` 的機率則為 :math:`|\\beta|^2`。寫成向量的型式則為："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:81
msgid "\\left|\\psi\\right\\rangle =\n"
"\\begin{pmatrix}\n"
"\\alpha \\\\\n"
"\\beta\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:90
msgid "Note, due to the conservation of probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` and since global phase is undetectable :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle` we only require two real numbers to describe a single qubit quantum state."
msgstr "另外，因為各事件的機率加總會是 :math:`|\\alpha|^2+ |\\beta|^2 = 1` 且共同相位測量不到 :math:`\\left|\\psi\\right\\rangle := e^{i\\delta} \\left|\\psi\\right\\rangle`，因此我們只需要兩個實數來描述單量子位元的量子態。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:92
msgid "A convenient representation is"
msgstr "一種比較方便的表示方法是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:94
msgid "\\left|\\psi\\right\\rangle = \\cos(\\theta/2)\\left|0\\right\\rangle + \\sin(\\theta/2)e^{i\\phi}\\left|1\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:96
msgid "where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq \\pi`. From this, it is clear that there is a one-to-one correspondence between qubit states (:math:`\\mathbb{C}^2`) and the points on the surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the Bloch sphere representation of a qubit state."
msgstr "其中 :math:`0\\leq \\phi < 2\\pi` 和 :math:`0\\leq \\theta \\leq \\pi`。從前面的表示法可以得知量子態(:math:`\\mathbb{C}^2`)能一一對應到單位球表面上的點(:math:`\\mathbb{R}^3`)，這被稱為量子態的布洛赫球面表示法。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:98
msgid "Quantum gates/operations are usually represented as matrices. A gate which acts on a qubit is represented by a :math:`2\\times 2` unitary matrix :math:`U`. The action of the quantum gate is found by multiplying the matrix representing the gate with the vector which represents the quantum state."
msgstr "量子閘/操作我們通常會用矩陣做表示；對量子位元做操作的量子邏輯閘可以用 :math:`2\\times 2` 的么正矩陣 :math:`U` 做表示；量子邏輯閘對量子位元操作則是代表量子邏輯閘的矩陣與代表量子態的向量相乘。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:100
msgid "\\left|\\psi'\\right\\rangle = U\\left|\\psi\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:102
msgid "A general unitary must be able to take the :math:`\\left|0\\right\\rangle` to the above state. That is"
msgstr "一般么正必須能夠將:math:`\\left|0\\right\\rangle` 用到上述狀態。 就是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:104
msgid "U = \\begin{pmatrix}\n"
"\\cos(\\theta/2) & a \\\\\n"
"e^{i\\phi}\\sin(\\theta/2) & b\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:112
msgid "where :math:`a` and :math:`b` are complex numbers constrained such that :math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and :math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where :math:`0\\leq \\lambda<2\\pi` giving"
msgstr "其中 :math:`a` 和 :math:`b` 是複數且在 :math:`0\\leq\\theta\\leq\\pi` 與 :math:`0\\leq \\phi<2\\pi` 這個範圍內，以下條件一定會成立： :math:`U^\\dagger U = I`。滿足這個條件需要三個限制，像是 :math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` 與 :math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)`，其中 :math:`0\\leq \\lambda<2\\pi`，如此 U 可以重新表示為："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:114
#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:165
msgid "U(\\theta, \\phi, \\lambda) =\n"
"    \\begin{pmatrix}\n"
"        \\cos\\left(\\frac{\\theta}{2}\\right)          & -e^{i\\lambda}\\sin\\left(\\frac{\\theta}{2}\\right) \\\\\n"
"        e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right) & e^{i(\\phi+\\lambda)}\\cos\\left(\\frac{\\theta}{2}\\right)\n"
"    \\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:123
msgid "This is the most general form of a single qubit unitary."
msgstr "這是一個單量子位元最一般的形式。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:135
msgid "Single-Qubit Gates"
msgstr "單量子位元閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:137
msgid "The single-qubit gates available are: - U gate - P gate - Identity gate - Pauli gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:139
msgid "We have provided a backend: ``unitary_simulator`` to allow you to calculate the unitary matrices."
msgstr "我們提供了一個後端： ``unitary_模擬器`` ，可讓您計算么正矩陣。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:161
msgid "U gate"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:163
msgid "In Qiskit we give you access to the general unitary using the :math:`u` gate, which has the following matrix form"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:284
msgid "Note on U gate deprecation"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:286
msgid "The QuantumCircuit methods :math:`u1`, :math:`u2` and :math:`u3` are now deprecated. Instead, the following replacements should be used."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:288
msgid ":math:`u1(\\lambda) = p(\\lambda) = u(0, 0, \\lambda)`"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:290
msgid ":math:`u2(\\phi, \\lambda) = u(\\frac{\\pi}{2}, \\phi, \\lambda) = p(\\frac{\\pi}{2} + \\phi) \\cdot sx \\cdot p(\\frac{\\pi}{2} - \\lambda)`"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:292
msgid ":math:`u3(\\theta, \\phi, \\lambda) = u(\\theta, \\phi, \\lambda) = p(\\phi + \\pi) \\cdot sx \\cdot p(\\theta + \\pi) \\cdot sx \\cdot p(\\lambda)`"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:319
msgid "P gate"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:321
msgid "The :math:`p(\\lambda)= u(0, 0, \\lambda)` gate has the matrix form"
msgstr ":math:`p(\\lambda)= u(0, 0, \\lambda)` 閘有矩陣型式"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:323
msgid "p(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"
msgstr "p(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 \\\\\n"
"0 & e^{i \\lambda}\n"
"\\end{pmatrix},"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:332
msgid "which is useful as it allows us to apply a quantum phase."
msgstr "這很有用因為它能讓我們應用量子相位"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:441
msgid "Identity gate"
msgstr "單位閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:443
msgid "The identity gate is :math:`Id = p(0)`."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:552
msgid "Pauli gates"
msgstr "Pauli 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:555
msgid ":math:`X`: bit-flip gate"
msgstr ":math:`X`：位元翻轉閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:557
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr "位元翻轉閘 :math:`X` 定義為："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:559
msgid "X   =\n"
"\\begin{pmatrix}\n"
"0 & 1\\\\\n"
"1 & 0\n"
"\\end{pmatrix}= u(\\pi,0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:675
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ":math:`Y`：位元和相位翻轉閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:677
msgid "The :math:`Y` gate is defined as:"
msgstr ":math:`Y` 閘被定義為："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:679
msgid "Y  =\n"
"\\begin{pmatrix}\n"
"0 & -i\\\\\n"
"i & 0\n"
"\\end{pmatrix}=u(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:795
msgid ":math:`Z`: phase-flip gate"
msgstr ":math:`Z`：相位翻轉閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:797
msgid "The phase-flip gate :math:`Z` is defined as:"
msgstr "相位翻轉閘 :math:`Z' 被定義為："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:799
msgid "Z =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -1\n"
"\\end{pmatrix}=p(\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:915
msgid "Clifford gates"
msgstr "Clifford 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:918
msgid "Hadamard gate"
msgstr "Hadamard 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:920
msgid "H =\n"
"\\frac{1}{\\sqrt{2}}\n"
"\\begin{pmatrix}\n"
"1 & 1\\\\\n"
"1 & -1\n"
"\\end{pmatrix}= u(\\pi/2,0,\\pi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1037
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr ":math:`S` （或 :math:`\\sqrt{Z}` 相位）閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1039
msgid "S =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & i\n"
"\\end{pmatrix}= p(\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1155
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr ":math:`S^{\\dagger}` （或 :math:`\\sqrt{Z}` 的共軛之相位）閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1157
msgid "S^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & -i\n"
"\\end{pmatrix}= p(-\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1273
msgid ":math:`C3` gates"
msgstr ":math:`C3` 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1276
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr ":math:`T` （或， :math:`\\sqrt{S}` 相位）閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1278
msgid "T =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{i \\pi/4}\n"
"\\end{pmatrix}= p(\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1394
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr ":math:`T^{\\dagger}` （或，共軛 of :math:`\\sqrt{S}` 相位）閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1396
msgid "T^{\\dagger} =\n"
"\\begin{pmatrix}\n"
"1 & 0\\\\\n"
"0 & e^{-i \\pi/4}\n"
"\\end{pmatrix}= p(-\\pi/4)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1512
msgid "Standard Rotations"
msgstr "標準旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1514
msgid "The standard rotation gates are those that define rotations around the Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr "標準旋轉閘被定義為在 Paulis :math:`P=\\{X，Y，Z\\``中旋轉。它們定義為"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1516
msgid "R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i \\sin(\\theta/2)P\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1519
msgid "Rotation around X-axis"
msgstr "繞 X 軸旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1521
msgid "R_x(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\\n"
"-i\\sin(\\theta/2) & \\cos(\\theta/2)\n"
"\\end{pmatrix} = u(\\theta, -\\pi/2,\\pi/2)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1637
msgid "Rotation around Y-axis"
msgstr "繞 Y 軸旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1639
msgid "R_y(\\theta) =\n"
"\\begin{pmatrix}\n"
"\\cos(\\theta/2) & - \\sin(\\theta/2)\\\\\n"
"\\sin(\\theta/2) & \\cos(\\theta/2).\n"
"\\end{pmatrix} =u(\\theta,0,0)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1755
msgid "Rotation around Z-axis"
msgstr "繞 Z 軸旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1757
msgid "R_z(\\phi) =\n"
"\\begin{pmatrix}\n"
"e^{-i \\phi/2} & 0 \\\\\n"
"0 & e^{i \\phi/2}\n"
"\\end{pmatrix}\\equiv p(\\phi)"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1766
msgid "Note that here we have used an equivalent as it is different to :math:`p` by a global phase :math:`e^{-i \\phi/2}`."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1874
msgid "Note this is different due only to a global phase."
msgstr "備註，這與球相位不同。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1886
msgid "Multi-Qubit Gates"
msgstr "多量子位元閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1889
msgid "Mathematical Preliminaries"
msgstr "數學序言"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1891
msgid "The space of a quantum computer grows exponentially with the number of qubits. For :math:`n` qubits the complex vector space has dimension :math:`d=2^n`. To describe states of a multi-qubit system, the tensor product is used to \"glue together\" operators and basis vectors."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1893
msgid "Let's start by considering a 2-qubit system. Given two operators :math:`A` and :math:`B` that each act on one qubit, the joint operator :math:`A \\otimes B` acting on two qubits is"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1895
msgid "\\begin{equation}\n"
"    A\\otimes B =\n"
"    \\begin{pmatrix}\n"
"        A_{00} \\begin{pmatrix}\n"
"            B_{00} & B_{01} \\\\\n"
"            B_{10} & B_{11}\n"
"        \\end{pmatrix} & A_{01}  \\begin{pmatrix}\n"
"                B_{00} & B_{01} \\\\\n"
"                B_{10} & B_{11}\n"
"            \\end{pmatrix} \\\\\n"
"        A_{10}  \\begin{pmatrix}\n"
"                    B_{00} & B_{01} \\\\\n"
"                    B_{10} & B_{11}\n"
"                \\end{pmatrix} & A_{11}  \\begin{pmatrix}\n"
"                            B_{00} & B_{01} \\\\\n"
"                            B_{10} & B_{11}\n"
"                        \\end{pmatrix}\n"
"    \\end{pmatrix},\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1917
msgid "where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of :math:`A` and :math:`B`, respectively."
msgstr "個別是:math:`A_{jk}` 和 :math:`B_{lm}`，而這兩個是 :math:`A` 和 :math:`B`矩陣的元素。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1919
msgid "Analogously, the basis vectors for the 2-qubit system are formed using the tensor product of basis vectors for a single qubit:"
msgstr "類似地，雙量子位元系統的基底向量可以藉由單量子位元的基底向量張量積得到："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1921
msgid "\\begin{equation}\\begin{split}\n"
"    \\left|{00}\\right\\rangle &= \\begin{pmatrix}\n"
"        1 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix} \\\\\n"
"        0 \\begin{pmatrix}\n"
"            1  \\\\\n"
"            0\n"
"        \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~\\left|{01}\\right\\rangle = \\begin{pmatrix}\n"
"    1 \\begin{pmatrix}\n"
"    0 \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\\end{split}\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1945
msgid "\\begin{equation}\\begin{split}\\left|{10}\\right\\rangle = \\begin{pmatrix}\n"
"    0\\begin{pmatrix}\n"
"    1  \\\\\n"
"    0\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    1 \\\\\n"
"    0\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   \\left|{11}\\right\\rangle = \\begin{pmatrix}\n"
"    0 \\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix} \\\\\n"
"    1\\begin{pmatrix}\n"
"    0  \\\\\n"
"    1\n"
"    \\end{pmatrix}\n"
"    \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\1 \\end{pmatrix}\\end{split}\n"
"\\end{equation}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1968
msgid "Note we've introduced a shorthand for the tensor product of basis vectors, wherein :math:`\\left|0\\right\\rangle \\otimes \\left|0\\right\\rangle` is written as :math:`\\left|00\\right\\rangle`. The state of an :math:`n`-qubit system can be described using the :math:`n`-fold tensor product of single-qubit basis vectors. Notice that the basis vectors for a 2-qubit system are 4-dimensional; in general, the basis vectors of an :math:`n`-qubit system are :math:`2^{n}`-dimensional, as noted earlier."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1971
msgid "Basis vector ordering in Qiskit"
msgstr "Qiskit 中的基底向量排序"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1973
msgid "Within the physics community, the qubits of a multi-qubit systems are typically ordered with the first qubit on the left-most side of the tensor product and the last qubit on the right-most side. For instance, if the first qubit is in state :math:`\\left|0\\right\\rangle` and second is in state :math:`\\left|1\\right\\rangle`, their joint state would be :math:`\\left|01\\right\\rangle`. Qiskit uses a slightly different ordering of the qubits, in which the qubits are represented from the most significant bit (MSB) on the left to the least significant bit (LSB) on the right (little-endian). This is similar to bitstring representation on classical computers, and enables easy conversion from bitstrings to integers after measurements are performed. For the example just given, the joint state would be represented as :math:`\\left|10\\right\\rangle`. Importantly, *this change in the representation of multi-qubit states affects the way multi-qubit gates are represented in Qiskit*, as discussed below."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1976
msgid "The representation used in Qiskit enumerates the basis vectors in increasing order of the integers they represent. For instance, the basis vectors for a 2-qubit system would be ordered as :math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, and :math:`\\left|11\\right\\rangle`. Thinking of the basis vectors as bit strings, they encode the integers 0,1,2 and 3, respectively."
msgstr "Qiskit 中使用的表示法按照它們所表示的整數以升冪排序列出基底向量。例如，一個雙量子位元系統的基底向量會按照:math:`\\left|00\\right\\rangle`, :math:`\\left|01\\right\\rangle`, :math:`\\left|10\\right\\rangle`, 和 :math:`\\left|11\\right\\rangle`。將基底向量視為位串，並分別將每個向量編碼為整數 0、1、2 和 3。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1979
msgid "Controlled operations on qubits"
msgstr "量子位元的受控操作"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1981
msgid "A common multi-qubit gate involves the application of a gate to one qubit, conditioned on the state of another qubit. For instance, we might want to flip the state of the second qubit when the first qubit is in :math:`\\left|0\\right\\rangle`. Such gates are known as *controlled gates*. The standard multi-qubit gates consist of two-qubit gates and three-qubit gates. The two-qubit gates are: - controlled Pauli gates - controlled Hadamard gate - controlled rotation gates - controlled phase gate - controlled u3 gate - swap gate"
msgstr "一個常見的多量子閘涉及到一個單量子閘的應用，條件是在另一個量子態的狀態。 例如，當第一個量子位元於:math:`\\left|0\\right\\rangle`時，我們可能想要翻轉第二個量子位元的狀態。 這類閘被稱為 *控制閘*。 標準的多量子閘由雙量子閘和三量子閘組成。 雙量子閘是： - 控制Pauli閘 - 控制Hadamard閘-控制旋轉閘 - 控相位閘-控制u3 閘-swap閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1984
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr "三量子位元閘有： - Toffoli 閘 - Fredkin 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1996
msgid "Two-qubit gates"
msgstr "雙量子閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:1998
msgid "Most of the two-qubit gates are of the controlled type (the SWAP gate being the exception). In general, a controlled two-qubit gate :math:`C_{U}` acts to apply the single-qubit unitary :math:`U` to the second qubit when the state of the first qubit is in :math:`\\left|1\\right\\rangle`. Suppose :math:`U` has a matrix representation"
msgstr "大部分的雙量子閘都是受控制的型態（ SWAP 閘是例外）。 一般而言，被控制的雙量子位元閘 :math:`C_{U}` 在第一個量子位元的狀態為:math:`\\left|1\\right\\rangle`時，將么正的單量子位元 :math:`U ` 應用至第二個量子位元。 假設 :math:`U` 有矩陣表示法"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2000
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2002
msgid "We can work out the action of :math:`C_{U}` as follows. Recall that the basis vectors for a two-qubit system are ordered as :math:`\\left|00\\right\\rangle, \\left|01\\right\\rangle, \\left|10\\right\\rangle, \\left|11\\right\\rangle`. Suppose the **control qubit** is **qubit 0** (which, according to Qiskit's convention, is one the *right-hand* side of the tensor product). If the control qubit is in :math:`\\left|1\\right\\rangle`, :math:`U` should be applied to the **target** (qubit 1, on the *left-hand* side of the tensor product). Therefore, under the action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2005
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{U\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"\\end{align*}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2014
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr "在矩陣形式中， :math:`C_{U}` 的作用是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2016
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0 & 0 \\\\\n"
"    0 & u_{00} & 0 & u_{01} \\\\\n"
"    0 & 0 & 1 & 0 \\\\\n"
"    0 & u_{10} &0 & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2027
msgid "To work out these matrix elements, let"
msgstr "若要編制這些矩陣元素，請"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2029
msgid "C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\left\\langle j \\right|} \\otimes \\underset{\\text{qubit}~0}{\\left\\langle k \\right|}\\right) C_{U} \\left(\\underset{\\text{qubit}~1}{\\left| l \\right\\rangle} \\otimes \\underset{\\text{qubit}~0}{\\left| m \\right\\rangle}\\right),\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2031
msgid "compute the action of :math:`C_{U}` (given above), and compute the inner products."
msgstr "計算 :math:`C_{U}` （在上面給出）的作用，並計算內積。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2033
msgid "As shown in the examples below, this operation is implemented in Qiskit as ``cU(q[0],q[1])``."
msgstr "如下列範例所示，此操作在 Qiskit 中作用為 ``cU(q[0],q[1])``。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2035
msgid "If **qubit 1 is the control and qubit 0 is the target**, then the basis vectors are transformed according to"
msgstr "如果**qubit1是被控制，而qubit0是目標**，那基底向量會被轉換，根據"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2037
msgid "\\begin{align*}\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|0\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|0\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|0\\right\\rangle}\\\\\n"
"C_{U}: \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{\\left|1\\right\\rangle} &\\rightarrow \\underset{\\text{qubit}~1}{\\left|1\\right\\rangle}\\otimes \\underset{\\text{qubit}~0}{U\\left|1\\right\\rangle}\\\\\n"
"\\end{align*},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2046
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr "其矩陣形式為 :math:`C_{U}` 是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2048
msgid "\\begin{equation}\n"
"    C_U = \\begin{pmatrix}\n"
"    1 & 0 & 0  & 0 \\\\\n"
"    0 & 1 & 0 & 0 \\\\\n"
"    0 & 0 & u_{00} & u_{01} \\\\\n"
"    0 & 0 & u_{10} & u_{11}\n"
"        \\end{pmatrix}.\n"
"\\end{equation}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2079
msgid "Controlled Pauli Gates"
msgstr "受控 Pauli 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2082
msgid "Controlled-X (or, Controlled-NOT) gate"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2084
msgid "The Controlled-NOT gate flips the ``target`` qubit when the control qubit is in the state :math:`\\left|1\\right\\rangle`. If we take the MSB as the control qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2086
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2097
msgid "However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), this gate is equivalent to the following matrix:"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2099
msgid "C_X =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2231
msgid "Controlled :math:`Y` gate"
msgstr "Controlled :math:`Y`閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2233
msgid "Apply the :math:`Y` gate to the target qubit if the control qubit is the MSB"
msgstr "如果控制閘是 MSB ，請將 :math:`Y` 閘套用至目標量子位元"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2235
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & i & 0\n"
"\\end{pmatrix},"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2246
msgid "or when the LSB is the control"
msgstr "或者當 LSB 是控制的時候"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2248
msgid "C_Y =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & -i\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & i & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2380
msgid "Controlled :math:`Z` (or, controlled Phase-Flip) gate"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2382
msgid "Similarly, the controlled Z gate flips the phase of the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. The matrix looks the same regardless of whether the MSB or LSB is the control qubit:"
msgstr "同樣地，如果控制量子位元是:math:`\\left|1\\right\\rangle`，則受控的 Z 閘會翻轉目標量子位元的相位。 不論 MSB 或 LSB 是否為控制量子位元，矩陣看起來都是一樣的："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2384
msgid "C_Z =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & -1\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2516
msgid "Controlled Hadamard gate"
msgstr "受控 Hadamard 閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2518
msgid "Apply :math:`H` gate to the target qubit if the control qubit is :math:`\\left|1\\right\\rangle`. Below is the case where the control is the LSB qubit."
msgstr "如果控制量子位元是 :math:`\\left|1\\right\\rangle`，請將 :math:`H ` 閘套用至目標量子位元。 以下是控制量子位元為 LSB 量子位元的情況。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2520
msgid "C_H =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}} & 0 & \\frac{1}{\\sqrt{2}}\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & \\frac{1}{\\sqrt{2}}  & 0& -\\frac{1}{\\sqrt{2}}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2652
msgid "Controlled rotation gates"
msgstr "受控旋轉閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2655
msgid "Controlled rotation around Z-axis"
msgstr "繞 Z 軸受控的旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2657
msgid "Perform rotation around Z-axis on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr "如果控制量子位元（這裡 LSB）是:math:`\\left|1\\right\\rangle` ，則在目標量子位元上執行繞 Z 軸的旋轉。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2659
msgid "C_{Rz}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i\\lambda/2} & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda/2}\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2791
msgid "Controlled phase rotation"
msgstr "受控的相位旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2793
msgid "Perform a phase rotation if both qubits are in the :math:`\\left|11\\right\\rangle` state. The matrix looks the same regardless of whether the MSB or LSB is the control qubit."
msgstr "如果兩個量子位元都在 :math:`\\left|11\\right\\rangle`狀態，則執行相位旋轉。 不論 MSB 或 LSB 是否為控制量子位元，矩陣看起來都是一樣的。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2795
msgid "C_{p}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"
msgstr "C_{p}(\\lambda) =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & e^{i\\lambda}\n"
"\\end{pmatrix}"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2927
msgid "Controlled :math:`u` rotation"
msgstr "Controlled :math:`u` 旋轉"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2929
msgid "Perform controlled-:math:`u` rotation on the target qubit if the control qubit (here LSB) is :math:`\\left|1\\right\\rangle`."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:2931
msgid "C_{u}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."
msgstr "C_{u}(\\theta, \\phi, \\lambda) \\equiv\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & -e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2)\n"
"\\end{pmatrix}."

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3063
msgid "SWAP gate"
msgstr "SWAP閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3065
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr "SWAP 閘交換兩個量子位元。 它會將基底向量轉換為"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3067
msgid "\\left|00\\right\\rangle \\rightarrow \\left|00\\right\\rangle~,~\\left|01\\right\\rangle \\rightarrow \\left|10\\right\\rangle~,~\\left|10\\right\\rangle \\rightarrow \\left|01\\right\\rangle~,~\\left|11\\right\\rangle \\rightarrow \\left|11\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3069
msgid "which gives a matrix representation of the form"
msgstr "這給出了一種形式的矩陣表示"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3071
msgid "\\mathrm{SWAP} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0\\\\\n"
"0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3203
msgid "Three-qubit gates"
msgstr "三量子位元閘"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3205
msgid "There are two commonly-used three-qubit gates. For three qubits, the basis vectors are ordered as"
msgstr "有兩個常用的三量子閘。 對於 3 個量子位元，基礎向量被排序為"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3207
msgid "\\left|000\\right\\rangle, \\left|001\\right\\rangle, \\left|010\\right\\rangle, \\left|011\\right\\rangle, \\left|100\\right\\rangle, \\left|101\\right\\rangle, \\left|110\\right\\rangle, \\left|111\\right\\rangle,\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3209
msgid "which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. Again, Qiskit uses a representation in which the first qubit is on the right-most side of the tensor product and the third qubit is on the left-most side:"
msgstr "其中，作為位元字串，代表整數:math:`0,1,2,\\cdots, 7`。 同樣， Qiskit 採用了在張量積的最右邊的第一個量子位元的表示法，而第三個量子位元則是在最左側："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3211
msgid "\\left|abc\\right\\rangle : \\underset{\\text{qubit 2}}{\\left|a\\right\\rangle}\\otimes \\underset{\\text{qubit 1}}{\\left|b\\right\\rangle}\\otimes \\underset{\\text{qubit 0}}{\\left|c\\right\\rangle}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3223
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr "Toffoli 閘（:math:`ccx` 閘）"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3225
msgid "The `Toffoli gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ flips the third qubit if the first two qubits (LSB) are both :math:`\\left|1\\right\\rangle`:"
msgstr "\"Toffoli 閘 <https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__ 如果前兩個量子位元（LSB）都是:math:`\\left|1\\right\\rangle`，則會翻轉第三個量子位元："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3227
msgid "\\left|abc\\right\\rangle \\rightarrow \\left|bc\\oplus a\\right\\rangle \\otimes \\left|b\\right\\rangle \\otimes \\left|c\\right\\rangle.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3229
msgid "In matrix form, the Toffoli gate is"
msgstr "在矩陣形式中，Toffoli 閘是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3231
msgid "C_{CX} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3397
msgid "Controlled swap gate (Fredkin Gate)"
msgstr "控制的swap閘（ Fredkin 閘）"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3399
msgid "The `Fredkin gate <https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__, or the *controlled swap gate*, exchanges the second and third qubits if the first qubit (LSB) is :math:`\\left|1\\right\\rangle`:"
msgstr "如果第一個量子位元（LSB）是:math:`\\left|1\\right\\rangle`，則 ' Fredkin 閘<https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__ 或 *控制的swap閘* 交換第二個和第三個量子位元："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3401
msgid "\\left|abc\\right\\rangle \\rightarrow \\begin{cases} \\left|bac\\right\\rangle~~\\text{if}~c=1 \\cr \\left|abc\\right\\rangle~~\\text{if}~c=0 \\end{cases}.\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3403
msgid "In matrix form, the Fredkin gate is"
msgstr "以矩陣形式，Fredkin 閘是"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3405
msgid "C_{\\mathrm{SWAP}} =\n"
"\\begin{pmatrix}\n"
"1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n"
"0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\n"
"\\end{pmatrix}."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3561
msgid "Non-unitary operations"
msgstr "非么正操作"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3563
msgid "Now that we have gone through all the unitary operations in quantum circuits, we also have access to non-unitary operations. These include measurements, reset of qubits, and classical conditional operations."
msgstr "現在，我們已經通過了量子電路中的所有么正操作，我們也可以使用非么正操作。 這些包括測量、重置量子位元和古典條件操作。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3588
msgid "We don't have access to all the information when we make a measurement in a quantum computer. The quantum state is projected onto the standard basis. Below are two examples showing a circuit that is prepared in a basis state and the quantum computer prepared in a superposition state."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3702
msgid "The simulator predicts that 100 percent of the time the classical register returns 0."
msgstr "模擬器預測古典寄存器返回 0 的概率為 100%。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3816
msgid "The simulator predicts that 50 percent of the time the classical register returns 0 or 1."
msgstr "模擬器預測，古典暫存器傳回 0 或 1的機率為 50 % 。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:3830
msgid "It is also possible to ``reset`` qubits to the :math:`\\left|0\\right\\rangle` state in the middle of computation. Note that ``reset`` is not a Gate operation, since it is irreversible."
msgstr "可以在計算過程中將量子位元“重置”到 :math:`\\left|0\\right\\rangle` 狀態。備註，這裡的“reset”不是閘操作，因為它是不可逆的。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4048
msgid "Here we see that for both of these circuits the simulator always predicts that the output is 100 percent in the 0 state."
msgstr "在這裡您可以看到，在兩個電路中，模擬器總是預測輸出為 0 狀態是 100% 的概率。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4060
msgid "Conditional operations"
msgstr "條件運算子"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4062
msgid "It is also possible to do operations conditioned on the state of the classical register"
msgstr "也可以在古典暫存器的狀態下進行操作"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4144
msgid "Here the classical bit always takes the value 0 so the qubit state is always flipped."
msgstr "在這裡，古典位元的值一律採用0 ，因此量子位元的狀態一律會翻轉。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4300
msgid "Here the classical bit by the first measurement is random but the conditional operation results in the qubit being deterministically put into :math:`\\left|1\\right\\rangle`."
msgstr "在這裡，第一項測量的古典位元是隨機的，但條件式操作結果被確定為 :math:`\\left|1\\right\\rangle`。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4312
msgid "Arbitrary initialization"
msgstr "任意起始設定"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4314
msgid "What if we want to initialize a qubit register to an arbitrary state? An arbitrary state for :math:`n` qubits may be specified by a vector of :math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals 1. For example, the following three-qubit state can be prepared:"
msgstr "那如果我們想要使一個量子位元暫存器初始化成任意狀態呢?任意狀態為:math:`n` 量子位元可能被向量:math:`2^n`幅度所指定，而此向量的幅度範數平方總和為1。例如，可以準備以下三量子位元狀態:"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4316
msgid "\\left|\\psi\\right\\rangle = \\frac{i}{4}\\left|000\\right\\rangle + \\frac{1}{\\sqrt{8}}\\left|001\\right\\rangle + \\frac{1+i}{4}\\left|010\\right\\rangle + \\frac{1+2i}{\\sqrt{8}}\\left|101\\right\\rangle + \\frac{1}{4}\\left|110\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4464
msgid "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ is useful to check whether two states are the same or not. For quantum (pure) states :math:`\\left|\\psi_1\\right\\rangle` and :math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr "`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`可以很好去檢查兩個狀態是否相同。對於量子(純)狀態:math:`\\left|\\psi_1\\right\\rangle`ˋ和:math:`\\left|\\psi_2\\right\\rangle`，\n"
"其保真度為"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4466
msgid "F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right) = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4471
msgid "The fidelity is equal to :math:`1` if and only if two states are equal."
msgstr "如果僅在兩個狀態相等時，保真度等於 :math:`1` 。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4518
msgid "Further details:"
msgstr "更多詳情"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4520
msgid "How does the desired state get generated behind the scenes? There are multiple methods for doing this. Qiskit uses a `method proposed by Shende et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to assume the quantum register to have started from our desired state, and construct a circuit that takes it to the :math:`\\left|00..0\\right\\rangle` state. The initialization circuit is then the reverse of such circuit."
msgstr "在場景背後要如何產生想要的狀態？ 有多種方法可以這樣做。 Qiskit 採用了 Shende et al <https://arxiv.org/abs/quant-ph/0406176>` 提出的方法。這裡的想法是假設量子暫存器是從我們想要的狀態開始的，並建構一個電路，將它帶至 :math:`\\left|00..0\\right\\rangle` 狀態。 該初始化電路則是該電路的反向。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4522
msgid "To take an arbitrary quantum state to the zero state in the computational basis, we perform an iterative procedure that disentangles qubits from the register one-by-one. We know that any arbitrary single-qubit state :math:`\\left|\\rho\\right\\rangle` can be taken to the :math:`\\left|0\\right\\rangle` state using a :math:`\\phi`-degree rotation about the Z axis followed by a :math:`\\theta`-degree rotation about the Y axis:"
msgstr "我們採取反覆步驟將寄存器中的量子位元一一解開，以將任何量子狀態帶到計算基礎的零狀態。我們知道任何一個單量子位元狀態：:math:`\\left|\\rho\\right\\rangle`是：:math:`\\phi`繞 Z 軸旋轉度數和：:math:`\\theta`繞 Y 軸：你可以得到:math:`\\left|0\\right\\rangle` 使用度數旋轉的狀態。"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4524
msgid "R_y(-\\theta)R_z(-\\phi)\\left|\\rho\\right\\rangle = re^{it}\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4526
msgid "Since now we are dealing with :math:`n` qubits instead of just 1, we must factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr "現在我們處理的是 :math:`n` 量子位元，而不是單量子位元，我們必須將狀態向量分解，以分離最不重要的位元（ LSB ）："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4528
msgid "\\begin{align*}\n"
" \\left|\\psi\\right\\rangle =& \\alpha_{0_0}\\left|00..00\\right\\rangle + \\alpha_{0_1}\\left|00..01\\right\\rangle + \\alpha_{1_0}\\left|00..10\\right\\rangle + \\alpha_{1_1}\\left|00..11\\right\\rangle + ... \\\\&+ \\alpha_{(2^{n-1}-1)_0}\\left|11..10\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|11..11\\right\\rangle \\\\\n"
"=& \\left|00..0\\right\\rangle (\\alpha_{0_0}\\left|0\\right\\rangle + \\alpha_{0_1}\\left|1\\right\\rangle) + \\left|00..1\\right\\rangle (\\alpha_{1_0}\\left|0\\right\\rangle + \\alpha_{1_1}\\left|1\\right\\rangle) + ... \\\\&+ \\left|11..1\\right\\rangle (\\alpha_{(2^{n-1}-1)_0}(\\left|0\\right\\rangle + \\alpha_{(2^{n-1}-1)_1}\\left|1\\right\\rangle) \\\\\n"
"=& \\left|00..0\\right\\rangle\\left|\\rho_0\\right\\rangle + \\left|00..1\\right\\rangle\\left|\\rho_1\\right\\rangle + ... + \\left|11..1\\right\\rangle\\left|\\rho_{2^{n-1}-1}\\right\\rangle\n"
"\\end{align*}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4536
msgid "Now each of the single-qubit states :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle` can be taken to :math:`\\left|0\\right\\rangle` by finding appropriate :math:`\\phi` and :math:`\\theta` angles per the equation above. Doing this simultaneously on all states amounts to the following unitary, which disentangles the LSB:"
msgstr "其中每1個量子位元狀態 :math:`\\left|\\rho_0\\right\\rangle, ..., \\left|\\rho_{2^{n-1}-1}\\right\\rangle`是你可以從 :math:`\\left|0\\right\\rangle`通過找到合適的角度:math:`\\phi` 和 :math:`\\theta` 得到，根據上述公式。在所有狀態下同時執行此操作可讓么正矩陣解開LSB："

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4538
msgid "U = \\begin{pmatrix}\n"
"R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\\n"
"& R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\\n"
"& . & & &\\\\\n"
"& & . & &\\\\\n"
"& & & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1})\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4548
msgid "Hence,"
msgstr "所以，"

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4550
msgid "U\\left|\\psi\\right\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\ . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes\\left|0\\right\\rangle\n\n"
msgstr ""

#: ../../tutorials/circuits/3_summary_of_quantum_operations.ipynb:4552
msgid "U can be implemented as a \"quantum multiplexor\" gate, since it is a block diagonal matrix. In the quantum multiplexor formalism, a block diagonal matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` blocks, is equivalent to a multiplexor with :math:`s` select qubits and :math:`n-s` data qubits. Depending on the state of the select qubits, the corresponding blocks are applied to the data qubits. A multiplexor of this kind can be implemented after recursive decomposition to primitive gates of cx, rz and ry."
msgstr ""


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-02 21:04+0000\n"
"PO-Revision-Date: 2023-03-02 21:47\n"
"Last-Translator: \n"
"Language: ta\n"
"Language-Team: Tamil\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ta\n"
"X-Crowdin-File: /master/docs/locale/en/LC_MESSAGES/tutorials/operators/01_operator_flow.po\n"
"X-Crowdin-File-ID: 9472\n"

#: ../../tutorials/operators/01_operator_flow.ipynb:10
msgid "This page was generated from `tutorials/operators/01_operator_flow.ipynb`__."
msgstr "இந்தப் பக்கம் `tutorials/operators/01_operator_flow.ipynb`__ லிருந்து உருவாக்கப்பட்டது."

#: ../../tutorials/operators/01_operator_flow.ipynb:9
msgid "Operator Flow"
msgstr "ஆபரேட்டர் ஓட்டம்"

#: ../../tutorials/operators/01_operator_flow.ipynb:21
msgid "Introduction"
msgstr "முன்னுரை"

#: ../../tutorials/operators/01_operator_flow.ipynb:23
msgid "Qiskit provides classes representing states and operators and sums, tensor products, and compositions thereof. These algebraic constructs allow us to build expressions representing operators."
msgstr "Qiskit நிலைகள் மற்றும் ஆபரேட்டர்கள் மற்றும் தொகைகள், டென்சர் ப்ராடக்ட்கள் மற்றும் அதன் கலவைகளை குறிக்கும் வகுப்புகளை வழங்குகிறது. இந்த இயற்கணித கட்டமைப்புகள் ஆபரேட்டர்களைக் குறிக்கும் வெளிப்பாடுகளை உருவாக்க எங்களை அனுமதிக்கின்றன."

#: ../../tutorials/operators/01_operator_flow.ipynb:25
msgid "We introduce expressions by building them from Pauli operators. In subsequent sections we explore in more detail operators and states, how they are represented, and what we can do with them. In the last section we construct a state, evolve it with a Hamiltonian, and compute expectation values of an observable."
msgstr "Pauli ஆபரேட்டர்களிடமிருந்து அவற்றை உருவாக்குவதன் மூலம் வெளிப்பாடுகளை அறிமுகப்படுத்துகிறோம். அடுத்தடுத்த பிரிவுகளில், ஆபரேட்டர்கள் மற்றும் நிலைகள், அவை எவ்வாறு குறிப்பிடப்படுகின்றன, அவற்றுடன் நாம் என்ன செய்ய முடியும் என்பதை விரிவாக ஆராய்வோம். கடைசி பிரிவில் நாம் ஒரு நிலையை உருவாக்குகிறோம், அதை ஒரு ஹாமில்டோனியனுடன் உருவாக்குகிறோம், மேலும் கவனிக்கத்தக்க எதிர்பார்ப்பு மதிப்புகளைக் கணக்கிடுகிறோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:28
msgid "Pauli operators, sums, compositions, and tensor products"
msgstr "Pauli ஆபரேட்டர்கள், தொகைகள், கலவை மற்றும் டென்சர் ப்ராடக்ட்கள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:30
msgid "The most important base operators are the Pauli operators. The Pauli operators are represented like this."
msgstr "மிக முக்கியமான அடிப்படை ஆபரேட்டர்கள் Pauli ஆபரேட்டர்கள். Pauli ஆபரேட்டர்கள் இதுபோன்று குறிப்பிடப்படுகிறார்கள்."

#: ../../tutorials/operators/01_operator_flow.ipynb:76
msgid "These operators may also carry a coefficient."
msgstr "இந்த ஆபரேட்டர்கள் ஒரு குணகத்தையும் கொண்டு செல்லக்கூடும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:125
msgid "These coefficients allow the operators to be used as terms in a sum."
msgstr "இந்த குணகங்கள் ஆபரேட்டர்களை ஒரு தொகையாக சொற்களாகப் பயன்படுத்த அனுமதிக்கின்றன."

#: ../../tutorials/operators/01_operator_flow.ipynb:173
msgid "Tensor products are denoted with a caret, like this."
msgstr "டென்சர் ப்ராடக்ட்கள் இது போன்ற ஒரு caret உடன் குறிக்கப்படுகின்றன."

#: ../../tutorials/operators/01_operator_flow.ipynb:218
msgid "Composition is denoted by the ``@`` symbol."
msgstr "கலவை என்பது ``@`` சின்னத்தால் குறிக்கப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:263
msgid "In the preceding two examples, the tensor product and composition of Pauli operators were immediately reduced to the equivalent (possibly multi-qubit) Pauli operator. If we tensor or compose more complicated objects, the result is objects representing the unevaluated operations. That is, algebraic expressions."
msgstr "முந்தைய இரண்டு எடுத்துக்காட்டுகளில், Pauli ஆபரேட்டர்களின் டென்சர் ப்ராடக்ட் மற்றும் கலவை உடனடியாக சமமான (சாத்தியமான பல-கியூபிட்) Pauli ஆபரேட்டராக குறைக்கப்பட்டது. நாம் மிகவும் சிக்கலான ஆப்ஜெக்ட்களை டென்சர் செய்தால் அல்லது உருவாக்கினால், இதன் விளைவு மதிப்பிடப்படாத செயல்பாடுகளைக் குறிக்கும் ஆப்ஜெக்ட்கள். அதாவது, இயற்கணித வெளிப்பாடுகள்."

#: ../../tutorials/operators/01_operator_flow.ipynb:274
msgid "For example, composing two sums gives"
msgstr "உதாரணமாக, இரண்டு தொகைகளை உருவாக்கினால், இவ்வாறு அளிக்கும்"

#: ../../tutorials/operators/01_operator_flow.ipynb:328
msgid "And tensoring two sums gives"
msgstr "மற்றும் இரண்டு தொகைகளை டென்சார் செய்வது, இப்படியாகும்"

#: ../../tutorials/operators/01_operator_flow.ipynb:382
msgid "Let’s take a closer look at the types introduced above. First the Pauli operators."
msgstr "மேலே அறிமுகப்படுத்தப்பட்ட வகைகளை உற்று நோக்கலாம். முதலில் Pauli ஆபரேட்டர்கள்."

#: ../../tutorials/operators/01_operator_flow.ipynb:428
msgid "Each Pauli operator is an instance of ``PauliOp``, which wraps an instance of ``qiskit.quantum_info.Pauli``, and adds a coefficient ``coeff``. In general, a ``PauliOp`` represents a weighted tensor product of Pauli operators."
msgstr "ஒவ்வொரு Pauli ஆபரேட்டரும் ``PauliOp`` இன் ஒரு எடுத்துக்காட்டு, இது ``qiskit.quantum_info.Pauli`` இன் ஒரு நிகழ்வை மடக்கி, ஒரு குணகம் ``coeff`` ஐ சேர்க்கிறது. பொதுவாக, ``PauliOp`` என்பது Pauli ஆபரேட்டர்களின் எடையுள்ள டென்சர் ப்ராடக்ட்டைக் குறிக்கிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:474
msgid "For the encoding of the Pauli operators as pairs of Boolean values, see the documentation for ``qiskit.quantum_info.Pauli``."
msgstr "Pauli ஆபரேட்டர்களை பூலியன் மதிப்புகளின் ஜோடிகளாக குறியாக்க, ``qiskit.quantum_info.Pauli`` க்கான ஆவணங்களைக் காண்க."

#: ../../tutorials/operators/01_operator_flow.ipynb:476
msgid "All of the objects representing operators, whether as “primitive”s such as ``PauliOp``, or algebraic expressions carry a coefficient"
msgstr "ஆபரேட்டர்களைக் குறிக்கும் அனைத்து ஆப்ஜெக்ட்களும், ``PauliOp`` போன்ற \"பழமையானவை\", அல்லது இயற்கணித வெளிப்பாடுகள் ஒரு குணகத்தைக் கொண்டுள்ளன"

#: ../../tutorials/operators/01_operator_flow.ipynb:530
msgid "In the following we take a broader and deeper look at Qiskit’s operators, states, and the building blocks of quantum algorithms."
msgstr "பின்வருவனவற்றில் Qiskit இன் ஆபரேட்டர்கள், நிலைகள் மற்றும் குவாண்டம் வழிமுறைகளின் கட்டுமானத் தொகுதிகள் குறித்து நாம் விரிவாகவும் ஆழமாகவும் பார்க்கிறோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:542
msgid "Part I: State Functions and Measurements"
msgstr "பகுதி I: நிலை செயல்பாடுகள் மற்றும் அளவீடுகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:544
msgid "Quantum states are represented by subclasses of the class ``StateFn``. There are four representations of quantum states: ``DictStateFn`` is a sparse representation in the computational basis, backed by a ``dict``. ``VectorStateFn`` is a dense representation in the computational basis backed by a numpy array. ``CircuitStateFn`` is backed by a circuit and represents the state obtained by executing the circuit on the all-zero computational-basis state. ``OperatorStateFn`` represents mixed states via a density matrix. (As we will see later, ``OperatorStateFn`` is also used to represent observables.)"
msgstr "குவாண்டம் நிலைகள் ``StateFn`` வகுப்பின் துணைப்பிரிவுகளால் குறிப்பிடப்படுகின்றன. குவாண்டம் நிலைகளின் நான்கு பிரதிநிதித்துவங்கள் உள்ளன: ``DicStateFn`` என்பது கணக்கீட்டு அடிப்படையில் ஒரு சிதறிய பிரதிநிதித்துவமாகும், இது ``dict`` ஆல் ஆதரிக்கப்படுகிறது. ``VectorStateFn`` என்பது கணக்கீட்டு அடிப்படையில் அடர்த்தியான பிரதிநிதித்துவமாகும். ``CircuitStateFn`` ஒரு சர்க்யூட் மூலம் ஆதரிக்கப்படுகிறது மற்றும் அனைத்து பூஜ்ஜிய கணக்கீட்டு அடிப்படையிலான நிலையில் சர்க்யூட்டை இயக்குவதன் மூலம் பெறப்பட்ட நிலையை குறிக்கிறது. ``OperatorStateFn`` என்பது டென்சிட்டி மேட்ரிக்ஸ் வழியாக கலப்பு நிலைகளைக் குறிக்கிறது. (பின்னர் பார்ப்போம், அவதானிப்புகளைக் குறிக்க ``OperatorStateFn`` பயன்படுத்தப்படுகிறது.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:547
msgid "Several ``StateFn`` instances are provided for convenience. For example ``Zero, One, Plus, Minus``."
msgstr "பல ``StateFn`` நிகழ்வுகள் வசதிக்காக வழங்கப்படுகின்றன. உதாரணத்திற்கு ``Zero, One, Plus, Minus``."

#: ../../tutorials/operators/01_operator_flow.ipynb:569
msgid "``Zero`` and ``One`` represent the quantum states :math:`|0\\rangle` and :math:`|1\\rangle`. They are represented via ``DictStateFn``."
msgstr "``Zero`` மற்றும் ``One`` குவாண்டம் நிலைகளைக் குறிக்கும் :math:`|0\\rangle` மற்றும் :math:`|1\\rangle`. அவை ``DictStateFn`` வழியாக குறிப்பிடப்படுகின்றன."

#: ../../tutorials/operators/01_operator_flow.ipynb:614
msgid "``Plus`` and ``Minus``, representing states :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` and :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` are represented via circuits. ``H`` is a synonym for ``Plus``."
msgstr "``Plus`` மற்றும் ``Minus``, நிலைகளை குறிக்கும் :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` மற்றும் :math:`(|0\\rangle - |1\\rangle)/\\sqrt{2}` சர்க்யூட்கள் வழியாக குறிப்பிடப்படுகின்றன. ``H`` என்பது ``Plus`` என்பதற்கு ஒரு பொருளாகும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:683
msgid "Indexing into quantum states is done with the ``eval`` method. These examples return the coefficients of the ``0`` and ``1`` basis states. (Below, we will see that the ``eval`` method is used for other computations, as well.)"
msgstr "குவாண்டம் நிலைகளுக்குள் இடைவெளி ``eval`` முறையுடன் செய்யப்படுகிறது. இந்த உதாரணங்கள் ``0`` மற்றும் ``1`` அடிப்படை நிலைகளின் கோட்பாடு திரும்பும். (கீழே, நாம் அதைப் பார்ப்போம் ``eval`` \n"
"முறை மற்ற கணக்கீடுகளுக்கும் பயன்படுத்தப்படுகிறது.)"

#: ../../tutorials/operators/01_operator_flow.ipynb:744
msgid "The dual vector of a quantum state, that is the *bra* corresponding to a *ket* is obtained via the ``adjoint`` method. The ``StateFn`` carries a flag ``is_measurement``, which is ``False`` if the object is a ket and ``True`` if it is a bra."
msgstr "ஒரு குவாண்டம் நிலையில் இரட்டை திசையன், அதாவது *ket* உடன் தொடர்புடைய *bra* என்பது ``adjoint`` முறை மூலம் பெறப்படுகிறது. ``StateFn`` ஒரு flag ``is_measurement`` கொண்டு செல்கிறது, இது ஆப்ஜெக்ட் ஒரு ket ஆக இருந்தால் ``False`` மற்றும் அது bra வாக இருந்தால் ``True``."

#: ../../tutorials/operators/01_operator_flow.ipynb:755
msgid "Here, we construct :math:`\\langle 1 |`."
msgstr "இங்கே, நாங்கள் கட்டமைக்கிறோம் :math:`\\langle 1 |`."

#: ../../tutorials/operators/01_operator_flow.ipynb:801
msgid "For convenience, one may obtain the dual vector with a tilde, like this"
msgstr "வசதிக்காக, ஒருவர் இரட்டை திசையனை ஒரு tilde உடன் பெறலாம், இது போல"

#: ../../tutorials/operators/01_operator_flow.ipynb:848
msgid "Algebraic operations and predicates"
msgstr "இயற்கணித செயல்பாடுகள் மற்றும் கணிப்புகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:850
msgid "Many algebraic operations and predicates between ``StateFn``\\ s are supported, including:"
msgstr "பல இயற்கணித செயல்பாடுகள் மற்றும் ``StateFn``\\ களுக்கு இடையே உள்ள கணிப்புகள் துணைபுரிகின்றன, இதில் அடங்கும்:"

#: ../../tutorials/operators/01_operator_flow.ipynb:852
msgid "``+`` - addition"
msgstr "``+`` - கூட்டல்"

#: ../../tutorials/operators/01_operator_flow.ipynb:853
msgid "``-`` - subtraction, negation (scalar multiplication by -1)"
msgstr "``-`` - கழித்தல், மறுப்பு (ஸ்கேலார் பெருக்கல் -1)"

#: ../../tutorials/operators/01_operator_flow.ipynb:854
msgid "``*`` - scalar multiplication"
msgstr "``*`` - அளவிடல் பெருக்கல்"

#: ../../tutorials/operators/01_operator_flow.ipynb:855
msgid "``/`` - scalar division"
msgstr "``/`` - அளவிடல் வகுத்தல்"

#: ../../tutorials/operators/01_operator_flow.ipynb:856
msgid "``@`` - composition"
msgstr "``@`` - தொகுத்தல்"

#: ../../tutorials/operators/01_operator_flow.ipynb:857
msgid "``^`` - tensor product or tensor power (tensor with self n times)"
msgstr "``^`` - டென்சர் தயாரிப்பு அல்லது டென்சர் பவர் (செல்ஃப் n முறைகளுடன் கூடிய டென்சர்)"

#: ../../tutorials/operators/01_operator_flow.ipynb:858
msgid "``**`` - composition power (compose with self n times)"
msgstr "``**`` - தொகுத்தல் சக்தி (தன்னுடன் n முறை எழுதவும்)"

#: ../../tutorials/operators/01_operator_flow.ipynb:859
msgid "``==`` - equality"
msgstr "``==`` - சமநிலை"

#: ../../tutorials/operators/01_operator_flow.ipynb:860
msgid "``~`` - adjoint, alternating between a State Function and Measurement"
msgstr "``~`` - ஒரு நிலை செயல்பாடு மற்றும் அளவீட்டுக்கு இடையில் மாறி"

#: ../../tutorials/operators/01_operator_flow.ipynb:862
msgid "Be very aware that these operators obey the `Python rules for operator precedence <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, which might not be what you expect mathematically. For example, ``I^X + X^I`` will actually be parsed as ``I ^ (X + X) ^ I == 2 * (I^X^I)`` because Python evaluates ``+`` before ``^``. In these cases, you can use the methods (``.tensor()``, etc) or parentheses."
msgstr "இந்த ஆபரேட்டர்கள் `ஆபரேட்டர் முன்னுரிமைக்கான பைதான் விதிகளுக்குக் கீழ்ப்படிகிறார்கள் என்பதை கவனத்தில் கொள்ளவும் <https://docs.python.org/3/reference/expressions.html#operator-precedence>`__, இது நீங்கள் கணித ரீதியாக எதிர்பார்க்கவில்லை. எடுத்துக்காட்டாக, ``I^X + X^I`` உண்மையில் ``I ^ (X + X) ^ I == 2 * (I^X^I)`` என அலசப்படும், ஏனெனில் பைதான் ``+`` ஐ மதிப்பிடுகிறது. ``^`` க்கு முன். இந்த சந்தர்ப்பங்களில், நீங்கள் முறைகள் (``.tensor()``, etc) அல்லது அடைப்புக்குறிகளைப் பயன்படுத்தலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:873
msgid "``StateFn``\\ s carry a coefficient. This allows us to multiply states by a scalar, and so to construct sums."
msgstr "``StateFn``\\ கள் ஒரு குணகத்தைக் கொண்டு செல்கின்றன. இது நிலைகளை ஒரு அளவுகோலால் பெருக்க அனுமதிக்கிறது, மேலும் தொகைகளை உருவாக்குகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:884
msgid "Here, we construct :math:`(2 + 3i)|0\\rangle`."
msgstr "இங்கே, நாங்கள் :math:`(2 + 3i)|0\\rangle` கட்டமைக்கிறோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:930
msgid "Here, we see that adding two ``DictStateFn``\\ s returns an object of the same type. We construct :math:`|0\\rangle + |1\\rangle`."
msgstr "இங்கே, இரண்டைச் சேர்ப்பதைக் காண்கிறோம் ``DictStateFn``\\ s அதே வகை ஒரு ஆப்ஜெக்ட்டை வழங்குகிறது. நாங்கள் :math:`|0\\rangle + |1\\rangle` கட்டமைக்கிறோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:975
msgid "Note that you must normalize states by hand. For example, to construct :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}`, we write"
msgstr "நீங்கள் கையால் நிலைகளை இயல்பாக்க வேண்டும் என்பதை நினைவில் கொள்க. உதாரணமாக, :math:`(|0\\rangle + |1\\rangle)/\\sqrt{2}` கட்டமைக்க, நாம் இவ்வாறு எழுதுகிறோம்"

#: ../../tutorials/operators/01_operator_flow.ipynb:1023
msgid "In other cases, the result is a symbolic representation of a sum. For example, here is a representation of :math:`|+\\rangle + |-\\rangle`."
msgstr "மற்ற சந்தர்ப்பங்களில், இதன் விளைவாக ஒரு தொகையின் குறியீட்டு பிரதிநிதித்துவம் ஆகும். எடுத்துக்காட்டாக, இங்கே ஒரு பிரதிநிதித்துவம் உள்ளது :math:`|+\\rangle + |-\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1101
msgid "The composition operator is used to perform an inner product, which by default is held in an unevaluated form. Here is a representation of :math:`\\langle 1 | 1 \\rangle`."
msgstr "கலவை ஆபரேட்டர் ஒரு உள் தயாரிப்பைச் செய்யப் பயன்படுகிறது, இது இயல்பாகவே மதிப்பிடப்படாத வடிவத்தில் வைக்கப்படுகிறது. இங்கே ஒரு பிரதிநிதித்துவம் :math:`\\langle 1 | 1 \\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1155
msgid "Note that the ``is_measurement`` flag causes the (bra) state ``~One`` to be printed ``DictMeasurement``."
msgstr "``is_measurement`` flag (bra) நிலையை ``~One`` ஐ ``DictMeasurement`` என அச்சிட காரணமாகிறது என்பதை நினைவில் கொள்க."

#: ../../tutorials/operators/01_operator_flow.ipynb:1166
msgid "Symbolic expressions may be evaluated with the ``eval`` method."
msgstr "குறியீட்டு வெளிப்பாடுகள் ``eval`` முறை மூலம் மதிப்பீடு செய்யப்படலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:1247
msgid "Here is :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."
msgstr "இங்கே :math:`\\langle - | 1 \\rangle = \\langle (\\langle 0| - \\langle 1|)/\\sqrt{2} | 1\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1293
msgid "The composition operator ``@`` is equivalent to calling the ``compose`` method."
msgstr "கலவை ஆபரேட்டர் ``@`` என்று அழைப்பதற்கு சமம் ``compose`` \n"
"முறை."

#: ../../tutorials/operators/01_operator_flow.ipynb:1347
msgid "Inner products may also be computed using the ``eval`` method directly, without constructing a ``ComposedOp``."
msgstr "``ComposedOp`` ஐ உருவாக்காமல், நேரடியாக ``eval`` முறையைப் பயன்படுத்தி உள் தயாரிப்புகளையும் கணக்கிடலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:1393
msgid "Symbolic tensor products are constructed as follows. Here is :math:`|0\\rangle \\otimes |+\\rangle`."
msgstr "குறியீட்டு டென்சர் ப்ராடக்ட்கள் பின்வருமாறு கட்டப்பட்டுள்ளன. இங்கே :math:`|0\\rangle \\otimes |+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1459
msgid "This may be represented as a simple (not compound) ``CircuitStateFn``."
msgstr "இது ஒரு எளிய (கலவை அல்ல) ``CircuitStateFn`` என குறிப்பிடப்படலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:1522
msgid "Tensor powers are constructed using the caret ``^`` as follows. Here are :math:`600 (|11111\\rangle + |00000\\rangle)`, and :math:`|10\\rangle^{\\otimes 3}`."
msgstr "பின்வருமாறு ``^`` என்ற caret பயன்படுத்தி டென்சர் அதிகாரங்கள் கட்டமைக்கப்படுகின்றன. இங்கே உள்ளவை :math:`600 (|11111\\rangle + |00000\\rangle)`, மற்றும் :math:`|10\\rangle^{\\otimes 3}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:1571
msgid "The method ``to_matrix_op`` converts to ``VectorStateFn``."
msgstr "``to_matrix_op`` முறை ``VectorStateFn`` க்கு மாற்றுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:1672
msgid "Constructing a StateFn is easy. The ``StateFn`` class also serves as a factory, and can take any applicable primitive in its constructor and return the correct StateFn subclass. Currently the following primitives can be passed into the constructor, listed alongside the ``StateFn`` subclass they produce:"
msgstr "StateFn அமைப்பது எளிதானது. ``StateFn`` வர்க்கம் ஒரு தொழிற்சாலையாகவும் செயல்படுகிறது, மேலும் அதன் கட்டமைப்பாளருக்கு பொருந்தக்கூடிய எந்தவொரு primitives சையும் எடுத்து சரியான StateFn துணைப்பிரிவை திருப்பித் தரலாம். தற்போது பின்வரும் primitives களை constructor ருக்கு அனுப்பலாம், அதனுடன் பட்டியலிடப்பட்டுள்ளது ``StateFn`` தயாரிக்கும் துணைப்பிரிவு:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1674
msgid "str (equal to some basis bitstring) -> DictStateFn"
msgstr "str (சில அடிப்படை பிட்ஸ்ட்ரிங்கிற்கு சமம்) -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1675
msgid "dict -> DictStateFn"
msgstr "dict -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1676
msgid "Qiskit Result object -> DictStateFn"
msgstr "Qiskit Result object -> DictStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1677
msgid "list -> VectorStateFn"
msgstr "list -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1678
msgid "np.ndarray -> VectorStateFn"
msgstr "np.ndarray -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1679
msgid "Statevector -> VectorStateFn"
msgstr "Statevector -> VectorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1680
msgid "QuantumCircuit -> CircuitStateFn"
msgstr "QuantumCircuit -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1681
msgid "Instruction -> CircuitStateFn"
msgstr "Instruction -> CircuitStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1682
msgid "OperatorBase -> OperatorStateFn"
msgstr "OperatorBase - > OperatorStateFn"

#: ../../tutorials/operators/01_operator_flow.ipynb:1764
msgid "Part II: ``PrimitiveOp``\\ s"
msgstr "பகுதி II: ``PrimitiveOp``\\ s"

#: ../../tutorials/operators/01_operator_flow.ipynb:1766
msgid "The basic Operators are subclasses of ``PrimitiveOp``. Just like ``StateFn``, ``PrimitiveOp`` is also a factory for creating the correct type of ``PrimitiveOp`` for a given primitive. Currently, the following primitives can be passed into the constructor, listed alongside the ``PrimitiveOp`` subclass they produce:"
msgstr "அடிப்படை ஆபரேட்டர்கள் ``PrimitiveOp`` இன் துணைப்பிரிவுகள். ``StateFn`` போலவே, ``PrimitiveOp`` என்பது ஒரு குறிப்பிட்ட பழமையானவருக்கு சரியான வகை ``PrimitiveOp`` ஐ உருவாக்குவதற்கான ஒரு தொழிற்சாலையாகும். தற்போது, ​​பின்வரும் பழமையானவைகளை அவர்கள் உருவாக்கும் ``PrimitiveOp`` துணைப்பிரிவுடன் பட்டியலிடப்பட்ட கன்ஸ்ட்ரக்டருக்கு அனுப்பலாம்:"

#: ../../tutorials/operators/01_operator_flow.ipynb:1768
msgid "Terra’s Pauli -> PauliOp"
msgstr "Terra’s Pauli -> PauliOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1769
msgid "Instruction -> CircuitOp"
msgstr "Instruction -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1770
msgid "QuantumCircuit -> CircuitOp"
msgstr "QuantumCircuit -> CircuitOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1771
msgid "2d List -> MatrixOp"
msgstr "2d List -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1772
msgid "np.ndarray -> MatrixOp"
msgstr "np.ndarray -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1773
msgid "spmatrix -> MatrixOp"
msgstr "spmatrix -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1774
msgid "Terra’s quantum_info.Operator -> MatrixOp"
msgstr "Terra’s quantum_info.Operator -> MatrixOp"

#: ../../tutorials/operators/01_operator_flow.ipynb:1796
msgid "Matrix elements"
msgstr "மேட்ரிக்ஸ் உறுப்புகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:1807
msgid "The ``eval`` method returns a column from an operator. For example, the Pauli :math:`X` operator is represented by a ``PauliOp``. Asking for a column returns an instance of the sparse representation, a ``DictStateFn``."
msgstr "``eval`` முறை ஒரு ஆபரேட்டரிடமிருந்து ஒரு நெடுவரிசையைத் தருகிறது. எடுத்துக்காட்டாக, Pauli :math:`X` ஆபரேட்டர் ``PauliOp`` ஆல் குறிப்பிடப்படுகிறது. ஒரு நெடுவரிசையைக் கேட்பது சிதறிய பிரதிநிதித்துவத்தின் ஒரு உதாரணத்தை அளிக்கிறது, ``DictStateFn``."

#: ../../tutorials/operators/01_operator_flow.ipynb:1887
msgid "It follows that indexing into an operator, that is obtaining a matrix element, is performed with two calls to the ``eval`` method."
msgstr "ஒரு மேட்ரிக்ஸ் உறுப்பைப் பெறும் ஒரு ஆபரேட்டரில் குறியீட்டு முறை ``eval`` முறைக்கு இரண்டு அழைப்புகளுடன் செய்யப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:1898
msgid "We have :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)`. And the matrix element :math:`\\left\\{X \\right\\}_{0,1}` is"
msgstr "நம்மிடம் :math:`X = \\left(\\begin{matrix} 0 & 1 \\\\  1 & 0  \\end{matrix} \\right)` உள்ளது. மற்றும் மேட்ரிக்ஸ் உறுப்பு :math:`\\left\\{X \\right\\}_{0,1}` ஆனது"

#: ../../tutorials/operators/01_operator_flow.ipynb:1944
msgid "Here is an example using the two qubit operator ``CX``, the controlled ``X``, which is represented by a circuit."
msgstr "இரண்டு கியூபிட் ஆபரேட்டரைப் பயன்படுத்தி ஒரு எடுத்துக்காட்டு இங்கே ``CX``, கட்டுப்படுத்தப்பட்ட ``X``, இது ஒரு சர்க்யூட் மூலம் குறிக்கப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:2088
msgid "Applying an operator to a state vector"
msgstr "ஒரு நிலை திசையனுக்கு ஒரு ஆபரேட்டரைப் பயன்படுத்துதல்"

#: ../../tutorials/operators/01_operator_flow.ipynb:2099
msgid "Applying an operator to a state vector may be done with the ``compose`` method (equivalently, ``@`` operator). Here is a representation of :math:`X | 1 \\rangle = |0\\rangle`."
msgstr "ஒரு நிலை திசையனுக்கு ஒரு ஆபரேட்டரைப் பயன்படுத்துவது ``compose`` முறை மூலம் செய்யப்படலாம் (equivalently, ``@`` operator). இங்கே ஒரு பிரதிநிதித்துவம் :math:`X | 1 \\rangle = |0\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2153
msgid "A simpler representation, the ``DictStateFn`` representation of :math:`|0\\rangle`, is obtained with ``eval``."
msgstr "ஒரு எளிய பிரதிநிதித்துவம், ``DictStateFn`` பிரதிநிதித்துவம் :math:`|0\\rangle`, ``eval`` உடன் பெறப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:2199
msgid "The intermediate ``ComposedOp`` step may be avoided by using ``eval`` directly."
msgstr "``eval`` ஐ நேரடியாகப் பயன்படுத்துவதன் மூலம் இடைநிலை ``ComposedOp`` வழியைத் தவிர்க்கப்படலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2245
msgid "Composition and tensor products of operators are effected with ``@`` and ``^``. Here are some examples."
msgstr "ஆபரேட்டர்கள் கலவை மற்றும் டென்சர் தயாரிப்பு ``@`` மற்றும் ``^``. இங்கே சில உதாரணங்கள்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2449
msgid "Part III: ``ListOp`` and subclasses"
msgstr "பகுதி III: ``ListOp`` மற்றும் துணைப்பிரிவுகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:2461
msgid "``ListOp``"
msgstr "``ListOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2463
msgid "``ListOp`` is a container for effectively vectorizing operations over a list of operators and states."
msgstr "``ListOp`` என்பது ஆபரேட்டர்கள் மற்றும் நிலைகளின் பட்டியலில் செயல்பாடுகளை திறம்பட திசையமைப்பதற்கான ஒரு கொள்கலன்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2537
msgid "For example, the composition above is distributed over the lists (``ListOp``) using the simplification method ``reduce``."
msgstr "எடுத்துக்காட்டாக, மேலே உள்ள கலவையை ``reduce`` என்னும் எளிமைப்படுத்தும் முறையைப் பயன்படுத்தி பட்டியல்களில் (``ListOp``) விநியோகிக்கப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:2646
msgid "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"
msgstr "``ListOp``\\ s: ``SummedOp``, ``ComposedOp``, ``TensoredOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2648
msgid "``ListOp``, introduced above, is useful for vectorizing operations. But, it also serves as the superclass for list-like composite classes. If you’ve already played around with the above, you’ll notice that you can easily perform operations between ``OperatorBase``\\ s which we may not know how to perform efficiently in general (or simply haven’t implemented an efficient procedure for yet), such as addition between ``CircuitOp``\\ s. In those cases, you may receive a ``ListOp`` result (or subclass thereof) from your operation representing the lazy execution of the operation. For example, if you attempt to add together a ``DictStateFn`` and a ``CircuitStateFn``, you’ll receive a ``SummedOp`` representing the sum of the two. This composite State function still has a working ``eval`` (but may need to perform a non-scalable computation under the hood, such as converting both to vectors)."
msgstr "மேலே அறிமுகப்படுத்தப்பட்ட ``ListOp``, திசையன் செயல்பாடுகளுக்கு பயனுள்ளதாக இருக்கும். ஆனால், இது பட்டியல் போன்ற கலப்பு வகுப்புகளுக்கான சூப்பர் கிளாஸாகவும் செயல்படுகிறது. நீங்கள் ஏற்கனவே மேற்கூறியவற்றைக் கொண்டு விளையாடியிருந்தால், ``OperatorBase``\\ s இடையே நீங்கள் எளிதாக செயல்பாடுகளைச் செய்ய முடியும் என்பதை நீங்கள் கவனிப்பீர்கள், இது பொதுவாக திறமையாக எவ்வாறு செயல்படுவது என்று எங்களுக்குத் தெரியாது (அல்லது திறமையான நடைமுறையை செயல்படுத்தவில்லை இன்னும்), ``CircuitOp``\\ s இடையே சேர்த்தல் போன்றவை. அந்த சந்தர்ப்பங்களில், செயல்பாட்டின் சோம்பேறி செயல்பாட்டைக் குறிக்கும் உங்கள் செயல்பாட்டிலிருந்து ``ListOp`` முடிவை (அல்லது அதன் துணைப்பிரிவு) பெறலாம். எடுத்துக்காட்டாக, நீங்கள் ஒரு ``DictStateFn`` மற்றும் ``CircuitStateFn`` ஆகியவற்றைச் சேர்க்க முயற்சித்தால், இரண்டின் கூட்டுத்தொகையைக் குறிக்கும் ``SummedOp`` பெறுவீர்கள். இந்த கலப்பு நிலை செயல்பாடு இன்னும் செயல்படும் ``eval`` ஐக் கொண்டுள்ளது (ஆனால் இரண்டையும் திசையன்களாக மாற்றுவது போன்ற ஹூடின் கீழ் அளவிட முடியாத கணக்கீட்டைச் செய்ய வேண்டியிருக்கலாம்)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2651
msgid "These composite ``OperatorBase``\\ s are how we construct increasingly complex and rich computation out of ``PrimitiveOp`` and ``StateFn`` building blocks."
msgstr "இந்த கலப்பு ``OperatorBase``\\ s பெருகிய முறையில் சிக்கலான மற்றும் சிறந்த கணக்கீட்டை எவ்வாறு உருவாக்குகிறோம் என்பதுதான் ``PrimitiveOp`` மற்றும் ``StateFn`` கட்டுமான தொகுதிகள்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2653
msgid "Every ``ListOp`` has four properties:"
msgstr "ஒவ்வொரு ``லிஸ்ட்Op`` க்கும் நான்கு பண்புகள் உள்ளன:"

#: ../../tutorials/operators/01_operator_flow.ipynb:2655
msgid "``oplist`` - The list of ``OperatorBase``\\ s which may represent terms, factors, etc."
msgstr "``oplist`` - விதிமுறைகள், காரணிகள் போன்றவற்றைக் குறிக்கக்கூடிய ``OperatorBase``\\ களின் பட்டியல்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2656
msgid "``combo_fn`` - The function taking a list of complex numbers to an output value which defines how to combine the outputs of the ``oplist`` items. For broadcasting simplicity, this function is defined over NumPy arrays."
msgstr "``combo_fn`` - ``oplist`` உருப்படிகளின் வெளியீடுகளை எவ்வாறு இணைப்பது என்பதை வரையறுக்கும் ஒரு வெளியீட்டு மதிப்புக்குக் கலப்பு எண்களின் பட்டியலை எடுக்கும் செயல்பாடு. ஒளிபரப்பு எளிமைக்காக, இந்தச் செயல்பாடு NumPy வரிசைகளில் வரையறுக்கப்படுகிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:2657
msgid "``coeff`` - A coefficient multiplying the primitive. Note that ``coeff`` can be int, float, complex or a free ``Parameter`` object (from ``qiskit.circuit`` in Terra) to be bound later using ``my_op.bind_parameters``."
msgstr "``coeff`` - பழமையானதைப் பெருக்கும் குணகம். ``coeff`` int, float, complex அல்லது இலவச ``Parameter`` பொருளாக இருக்கலாம் (Terra இல் ``qiskit.circuit`` இலிருந்து) பின்னர் ``my_op.bind_parameters`` ஐப் பயன்படுத்தி பிணைக்கப்படும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2658
msgid "``abelian`` - Indicates whether the Operators in ``oplist`` are known to mutually commute (usually set after being converted by the ``AbelianGrouper`` converter)."
msgstr "``abelian`` - ``oplist`` இல் உள்ள ஆபரேட்டர்கள் பரஸ்பரம் பயணிக்கத் தெரிந்தவர்களா என்பதைக் குறிக்கிறது (பொதுவாக ``AbelianGrouper`` மாற்றிமூலம் மாற்றப்பட்ட பிறகு அமைக்கப்படும்)."

#: ../../tutorials/operators/01_operator_flow.ipynb:2660
msgid "Note that ``ListOp`` supports typical sequence overloads, so you can use indexing like ``my_op[4]`` to access the ``OperatorBase``\\ s in ``oplist``."
msgstr "``ListOp`` வழக்கமான வரிசை ஓவர்லோடுகளை ஆதரிக்கிறது, எனவே ``oplist`` இல் ``OperatorBase``\\ களை அணுக ``my_op[4]`` போன்ற அட்டவணையைப் பயன்படுத்தலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2672
msgid "``OperatorStateFn``"
msgstr "``OperatorStateFn``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2674
msgid "We mentioned above that ``OperatorStateFn`` represents a density operator. But, if the ``is_measurement`` flag is ``True``, then ``OperatorStateFn`` represents an observable. The expectation value of this observable can then be constructed via ``ComposedOp``. Or, directly, using ``eval``. Recall that the ``is_measurement`` flag (property) is set via the ``adjoint`` method."
msgstr "``OperatorStateFn`` ஒரு அடர்த்தி ஆபரேட்டரைக் குறிக்கிறது என்பதை நாங்கள் மேலே குறிப்பிட்டோம். ஆனால், ``is_measurement`` flag ``True`` எனில், ``OperatorStateFn`` என்பது கவனிக்கத்தக்கதைக் குறிக்கிறது. இந்த அனுசரிப்புக்கான எதிர்பார்ப்பு மதிப்பு பின்னர் ``ComposedOp`` வழியாக உருவாக்கப்படலாம். அல்லது, நேரடியாக, ``eval`` ஐப் பயன்படுத்துதல். ``adjoint`` முறை வழியாக ``is_measurement`` flag (property) அமைக்கப்பட்டுள்ளது என்பதை நினைவில் கொள்க."

#: ../../tutorials/operators/01_operator_flow.ipynb:2685
msgid "Here we construct the observable corresponding to the Pauli :math:`Z` operator. Note that when printing, it is called ``OperatorMeasurement``."
msgstr "Pauli :math:`Z` ஆபரேட்டருக்கு ஒத்ததாகக் காணக்கூடியதை இங்கே உருவாக்குகிறோம். அச்சிடும் போது, ​​அது ``OperatorMeasurement`` என்று அழைக்கப்படுகிறது என்பதை நினைவில் கொள்க."

#: ../../tutorials/operators/01_operator_flow.ipynb:2757
msgid "Here, we compute :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, and :math:`\\langle + | Z | + \\rangle`, where :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."
msgstr "இங்கே, நாம் :math:`\\langle 0 | Z | 0 \\rangle`, :math:`\\langle 1 | Z | 1 \\rangle`, மற்றும் :math:`\\langle + | Z | + \\rangle` கணக்கிடுகிறோம், இதில் :math:`|+\\rangle = (|0\\rangle + |1\\rangle)/\\sqrt{2}`."

#: ../../tutorials/operators/01_operator_flow.ipynb:2811
msgid "Part IV: Converters"
msgstr "பகுதி IV: மாற்றிகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:2813
msgid "Converters are classes that manipulate operators and states and perform building blocks of algorithms. Examples include changing the basis of operators and Trotterization. Converters traverse an expression and perform a particular manipulation or replacement, defined by the converter’s ``convert()`` method, of the Operators within. Typically, if a converter encounters an ``OperatorBase`` in the recursion which is irrelevant to its conversion purpose, that ``OperatorBase`` is left unchanged."
msgstr "மாற்றிகள் ஆபரேட்டர்கள் மற்றும் நிலைகளை கையாளும் மற்றும் வழிமுறைகளின் கட்டுமானத் தொகுதிகளைச் செய்யும் வகுப்புகள். எடுத்துக்காட்டுகள் ஆபரேட்டர்களின் அடிப்படையை மாற்றுவது மற்றும் ட்ரொட்டரைசேஷன் ஆகியவை அடங்கும். மாற்றிகள் ஒரு வெளிப்பாட்டைக் கடந்து, ஒரு குறிப்பிட்ட கையாளுதல் அல்லது மாற்றீட்டைச் செய்கின்றன, இது மாற்றியின் ``convert()`` முறையால் வரையறுக்கப்படுகிறது. பொதுவாக, ஒரு மாற்றி அதன் மாற்ற நோக்கத்திற்கு பொருத்தமற்ற மறுநிகழ்வில் ``OperatorBase`` ஐ எதிர்கொண்டால், அந்த ``OperatorBase`` மாறாமல் இருக்கும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2838
msgid "Evolutions, ``exp_i()``, and the ``EvolvedOp``"
msgstr "பரிணாமங்கள், ``exp_i ()``, மற்றும் ``EvolvedOp``"

#: ../../tutorials/operators/01_operator_flow.ipynb:2840
msgid "Every ``PrimitiveOp`` and ``ListOp`` has an ``.exp_i()`` function such that ``H.exp_i()`` corresponds to :math:`e^{-iH}`. In practice, only a few of these Operators have an efficiently computable exponentiation (such as MatrixOp and the PauliOps with only one non-identity single-qubit Pauli), so we need to return a placeholder, or symbolic representation, (similar to how ``SummedOp`` is a placeholder when we can’t perform addition). This placeholder is called ``EvolvedOp``, and it holds the ``OperatorBase`` to be exponentiated in its ``.primitive`` property."
msgstr "ஒவ்வொரு ``PrimitiveOp`` மற்றும் ``ListOp`` ஆகியவற்றுக்கு ``.exp_i()`` செயல்பாடு உள்ளது, அதாவது ``H.exp_i()`` இதற்கு ஒத்திருக்கிறது :math:`e^{-iH}`. நடைமுறையில், இந்த ஆபரேட்டர்களில் சிலருக்கு மட்டுமே திறமையாக கணக்கிடக்கூடிய அதிவேகத்தன்மை உள்ளது (MatrixOp மற்றும் PauliOps போன்றவை ஒரே அடையாளமில்லாத ஒற்றை-கியூபிட் Pauli மட்டுமே), எனவே நாம் ஒரு ஒதுக்கிடத்தை அல்லது குறியீட்டு பிரதிநிதித்துவத்தை திருப்பித் தர வேண்டும் (எப்படி எங்களால் கூடுதலாகச் செய்ய முடியாதபோது ``SummedOp`` என்பது ஒரு ஒதுக்கிடமாகும்). இந்த ஒதுக்கிடத்தை ``EvolvedOp`` என்று அழைக்கப்படுகிறது, மேலும் இது ``OperatorBase`` ஐ அதன் ``.primitive`` சொத்தில் அதிவேகப்படுத்த வேண்டும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2843
msgid "Qiskit operators fully support parameterization, so we can use a ``Parameter`` for our evolution time here. Notice that there’s no “evolution time” argument in any function. The Operator flow exponentiates whatever operator we tell it to, and if we choose to multiply the operator by an evolution time, :math:`e^{-iHt}`, that will be reflected in our exponentiation parameters."
msgstr "Qiskit ஆபரேட்டர்கள் அளவுருவை முழுமையாக ஆதரிக்கிறார்கள், எனவே இங்குள்ள நமது பரிணாம நேரத்திற்கு ``Parameter`` ஐப் பயன்படுத்தலாம். எந்தவொரு செயல்பாட்டிலும் “evolution time” ஆர்கியுமென்ட் இல்லை என்பதைக் கவனியுங்கள். ஆபரேட்டர் ஓட்டம் நாம் எந்த ஆபரேட்டரிடம் சொன்னாலும் அதை வெளிப்படுத்துகிறது, மேலும் ஒரு ஆபரேட்டரை ஒரு பரிணாம நேரத்தால் பெருக்க நாங்கள் தேர்வுசெய்தால் :math:`e^{-iHt}`, இது எங்கள் அதிவேக அளவுருக்களில் பிரதிபலிக்கும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2855
msgid "Weighted sum of Pauli operators"
msgstr "Pauli ஆபரேட்டர்களின் எடையுள்ள தொகை"

#: ../../tutorials/operators/01_operator_flow.ipynb:2857
msgid "A Hamiltonian expressed as a linear combination of multi-qubit Pauli operators may be constructed like this."
msgstr "மல்டி-கியூபிட் Pauli ஆபரேட்டர்களின் நேரியல் கலவையாக வெளிப்படுத்தப்பட்ட ஒரு ஹாமில்டோனியன் இதுபோன்று கட்டமைக்கப்படலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:2882
msgid "Note that ``two_qubit_H2`` is represented as a ``SummedOp`` whose terms are ``PauliOp``\\ s."
msgstr "``wo_qubit_H2`` என்பது ``SummedOp`` எனக் குறிப்பிடப்படுகிறது, இதன் சொற்கள் ``PauliOp``\\ s."

#: ../../tutorials/operators/01_operator_flow.ipynb:2939
msgid "Next, we multiply the Hamiltonian by a ``Parameter``. This ``Parameter`` is stored in the ``coeff`` property of the ``SummedOp``. Calling ``exp_i()`` on the result wraps it in ``EvolvedOp``, representing exponentiation."
msgstr "அடுத்து, ஹாமில்டோனியனை ``Parameter`` மூலம் பெருக்குகிறோம். இந்த ``Parameter`` ``SummedOp`` இன் ``coeff`` பண்பில் சேமிக்கப்படுகிறது. முடிவில் ``exp_i()`` என்று அழைப்பது, அதை ``EvolvedOp`` போர்த்தி, அடுக்காகக் குறிக்கிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:3014
msgid "We construct ``h2_measurement``, which represents ``two_qubit_H2`` as an observable."
msgstr "``h2_measurement`` ஐ உருவாக்குகிறோம், இது ``two_qubit_H2`` ஐக் காணக்கூடியதாகக் குறிக்கிறது."

#: ../../tutorials/operators/01_operator_flow.ipynb:3072
msgid "We construct a Bell state :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."
msgstr "நாங்கள் ஒரு பெல் நிலையை உருவாக்குகிறோம் :math:`|\\Phi_+\\rangle` via :math:`\\text{CX} (H\\otimes I) |00\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3136
msgid "Here is the expression :math:`H e^{-iHt} |\\Phi_+\\rangle`."
msgstr "இங்கே வெளிப்பாடு :math:`H e^{-iHt} |\\Phi_+\\rangle`."

#: ../../tutorials/operators/01_operator_flow.ipynb:3242
msgid "Typically, we want to approximate :math:`e^{-iHt}` using two-qubit gates. We achieve this with the ``convert`` method of ``PauliTrotterEvolution``, which traverses expressions applying trotterization to all ``EvolvedOp``\\ s encountered. Although we use ``PauliTrotterEvolution`` here, there are other possibilities, such as ``MatrixEvolution``, which performs the exponentiation exactly."
msgstr "பொதுவாக, தோராயமாக மதிப்பிட விரும்புகிறோம் :math:`e^{-iHt}` இரண்டு-கியூபிட்டு கேட்களைப் பயன்படுத்துதல். ``PauliTrotterEvolution`` இன் ``convert`` முறையால் இதை நாங்கள் அடைகிறோம், இது எதிர்கொள்ளும் அனைத்து ``EvolvedOp``\\ s ட்ரொட்டரைசேஷனைப் பயன்படுத்துவதற்கான வெளிப்பாடுகளைக் கடந்து செல்கிறது. நாம் இங்கே ``PauliTrotterEvolution`` ஐப் பயன்படுத்தினாலும், ``MatrixEvolution`` போன்ற பிற சாத்தியக்கூறுகள் உள்ளன, அவை அதிவேகத்தை சரியாகச் செய்கின்றன."

#: ../../tutorials/operators/01_operator_flow.ipynb:3361
msgid "``trotterized_op`` contains a ``Parameter``. The ``bind_parameters`` method traverses the expression binding values to parameter names as specified via a ``dict``. In this case, there is only one parameter."
msgstr "``trotterized_op`` இல் ``Parameter`` உள்ளது. ``bind_parameters`` முறை, ``dict`` வழியாக குறிப்பிடப்பட்டுள்ளபடி, வெளிப்பாடு பிணைப்பு மதிப்புகளை அளவுரு பெயர்களுக்குச் செல்கிறது. இந்த வழக்கில், ஒரே ஒரு அளவுரு மட்டுமே உள்ளது."

#: ../../tutorials/operators/01_operator_flow.ipynb:3382
msgid "``bound`` is a ``ComposedOp``. The second factor is the circuit. Let’s draw it to verify that the binding has taken place."
msgstr "``bound`` என்பது ``ComposedOp``. இரண்டாவது காரணி சர்க்யூட். பிணைப்பு நடந்ததா என்பதை சரிபார்க்க அதை வரைவோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3502
msgid "Expectations"
msgstr "எதிர்பார்ப்புகள்"

#: ../../tutorials/operators/01_operator_flow.ipynb:3504
msgid "``Expectation``\\ s are converters that enable the computation of expectation values of observables. They traverse an Operator tree, replacing ``OperatorStateFn``\\ s (observables) with equivalent instructions which are more amenable to computation on quantum or classical hardware. For example, if we want to measure the expectation value of an Operator ``o`` expressed as a sum of Paulis with respect to some state function, but can only access diagonal measurements on quantum hardware, we can create an observable ``~StateFn(o)`` and use a ``PauliExpectation`` to convert it to a diagonal measurement and circuit pre-rotations to append to the state."
msgstr "``Expectation``\\ s மாற்றக்கூடியவை, அவை அவதானிக்கக்கூடியவர்களின் எதிர்பார்ப்பு மதிப்புகளைக் கணக்கிட உதவும். அவை ஒரு ஆபரேட்டர் மரத்தில் பயணிக்கின்றன, ``OperatorStateFn``\\ s (அவதானிக்கக்கூடியவை) சமமான வழிமுறைகளுடன் குவாண்டம் அல்லது கிளாசிக்கல் வன்பொருளில் கணக்கிடுவதற்கு மிகவும் ஏற்றது. எடுத்துக்காட்டாக, சில மாநில செயல்பாடுகளைப் பொறுத்து Paulis-ன் தொகையாக வெளிப்படுத்தப்பட்ட ஒரு ஆபரேட்டரின் எதிர்பார்ப்பு மதிப்பை அளவிட விரும்பினால், ஆனால் குவாண்டம் வன்பொருளில் மூலைவிட்ட அளவீடுகளை மட்டுமே அணுக முடியும் என்றால், நாம் கவனிக்கத்தக்க ``o`` ஐ உருவாக்க முடியும். ``~StateFn(o)`` மற்றும் ஒரு ``PauliExpectation`` ஐப் பயன்படுத்தி அதை ஒரு மூலைவிட்ட அளவீடு மற்றும் சர்க்யூட்டுக்கு முந்தைய சுழற்சிகளாக மாற்றவும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3507
msgid "Another interesting ``Expectation`` is the ``AerPauliExpectation``, which converts the observable into a ``CircuitStateFn`` containing a special expectation snapshot instruction which ``Aer`` can execute natively with high performance."
msgstr "மற்றொரு சுவாரஸ்யமான ``Expectation`` என்பது ``AerPauliExpectation`` ஆகும், இது கவனிக்கத்தக்கதை ``CircuitStateFn`` ஆக மாற்றுகிறது, இது ஒரு சிறப்பு எதிர்பார்ப்பு ஸ்னாப்ஷாட் அறிவுறுத்தலைக் கொண்டுள்ளது, இது ``Ae`` உயர் செயல்திறனுடன் இயல்பாக இயக்க முடியும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3628
msgid "By default ``group_paulis=True``, which will use the ``AbelianGrouper`` to convert the ``SummedOp`` into groups of mutually qubit-wise commuting Paulis. This reduces circuit execution overhead, as each group can share the same circuit execution."
msgstr "இயல்பாகவே ``group_paulis=True``, இது ``SummedOp`` ஐ பரஸ்பர கியூபிட் வாரியாக பயணிக்கும் பவுலிஸின் குழுக்களாக மாற்ற ``AbelianGrouper`` பயன்படுத்தும். இது சர்க்யூட் செயல்பாட்டை மேல்நோக்கி குறைக்கிறது, ஏனெனில் ஒவ்வொரு குழுவும் ஒரே சர்க்யூட் செயல்பாட்டை பகிர்ந்து கொள்ளலாம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3721
msgid "Note that converters act recursively, that is, they traverse an expression applying their action only where possible. So we can just convert our full evolution and measurement expression. We could have equivalently composed the converted ``h2_measurement`` with our evolution ``CircuitStateFn``. We proceed by applying the conversion on the entire expression."
msgstr "மாற்றிகள் மீண்டும் மீண்டும் செயல்படுகின்றன என்பதை நினைவில் கொள்க, அதாவது, அவை முடிந்தவரை மட்டுமே தங்கள் செயலைப் பயன்படுத்தும் ஒரு வெளிப்பாட்டைக் கடந்து செல்கின்றன. எனவே நமது முழு பரிணாமத்தையும் அளவீட்டு வெளிப்பாட்டையும் மாற்றலாம். மாற்றப்பட்ட ``h2_measurement`` ஐ நமது பரிணாம வளர்ச்சியுடன் ``CircuitStateFn`` உடன் சமமாக இயற்றியிருக்கலாம். முழு வெளிப்பாட்டிலும் மாற்றத்தைப் பயன்படுத்துவதன் மூலம் நாங்கள் தொடர்கிறோம்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3905
msgid "Now we bind multiple parameter values into a ``ListOp``, followed by ``eval`` to evaluate the entire expression. We could have used ``eval`` earlier if we bound earlier, but it would not be efficient. Here, ``eval`` will convert our ``CircuitStateFn``\\ s to ``VectorStateFn``\\ s through simulation internally."
msgstr "இப்போது பல அளவுரு மதிப்புகளை ``ListOp`` ஆக பிணைக்கிறோம், அதன்பிறகு முழு வெளிப்பாட்டை மதிப்பீடு செய்ய ``eval``. நாம் முன்பே கட்டுப்பட்டிருந்தால் ``eval`` ஐ முன்னர் பயன்படுத்தியிருக்கலாம், ஆனால் அது திறமையாக இருக்காது. இங்கே, ``eval`` எங்கள் ``CircuitStateFn`` களை உள்நாட்டில் உருவகப்படுத்துதல் மூலம் ``VectorStateFn`` களாக மாற்றும்."

#: ../../tutorials/operators/01_operator_flow.ipynb:3927
msgid "Here are the expectation values :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` corresponding to the different values of the parameter."
msgstr "எதிர்பார்ப்பு மதிப்புகள் இங்கே :math:`\\langle \\Phi_+| e^{iHt} H e^{-iHt} |\\Phi_+\\rangle` அளவுருவின் வெவ்வேறு மதிப்புகளுடன் தொடர்புடையது."

#: ../../tutorials/operators/01_operator_flow.ipynb:3980
msgid "Executing ``CircuitStateFn``\\ s with the ``CircuitSampler``"
msgstr "``CircuitSampler`` உடன் ``CircuitStateFn``\\ s ஐ செயல்படுத்துகிறோம்"

#: ../../tutorials/operators/01_operator_flow.ipynb:3982
msgid "The ``CircuitSampler`` traverses an Operator and converts any ``CircuitStateFn``\\ s into approximations of the resulting state function by a ``DictStateFn`` or ``VectorStateFn`` using a quantum backend. Note that in order to approximate the value of the ``CircuitStateFn``, it must 1) send the state function through a depolarizing channel, which will destroy all phase information and 2) replace the sampled frequencies with **square roots** of the frequency, rather than the raw probability of sampling (which would be the equivalent of sampling the **square** of the state function, per the Born rule)."
msgstr "``CircuitSampler`` ஒரு ஆபரேட்டரைக் கடந்து எந்த ``CircuitStateFn``\\ களை ஒரு குவாண்டம் பின்தளத்தைப் பயன்படுத்தி ``DictStateFn` அல்லது ``VectorStateFn`` மூலம் விளைந்த நிலை செயல்பாட்டின் தோராயமாக மாற்றுகிறது. ``CircuitStateFn`` இன் மதிப்பை தோராயமாக மதிப்பிடுவதற்கு, அது 1) நிலை செயல்பாட்டை நீக்கும் சேனல் மூலம் அனுப்ப வேண்டும், இது அனைத்து கட்ட தகவல்களையும் அழிக்கும் மற்றும் 2) மாதிரி அதிர்வெண்களை **சதுர வேர்கள்** மூலம் மாற்றும் மாதிரியின் மூல நிகழ்தகவை விட அதிர்வெண் (இது பார்ன் விதியின்படி, மாநில செயல்பாட்டின் **சதுர** மாதிரிக்கு சமமாக இருக்கும்)."

#: ../../tutorials/operators/01_operator_flow.ipynb:4038
msgid "Note again that the circuits are replaced by dicts with **square roots** of the circuit sampling probabilities. Take a look at one sub-expression before and after the conversion:"
msgstr "சர்க்யூட் மாதிரி நிகழ்தகவுகளின் **square roots** உடன் சர்க்யூட்கள் மாற்றப்படுகின்றன என்பதை மீண்டும் கவனியுங்கள். மாற்றத்திற்கு முன்னும் பின்னும் ஒரு துணை வெளிப்பாட்டைப் பாருங்கள்:"


msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-01 18:06+0000\n"
"PO-Revision-Date: 2021-07-05 02:29\n"
"Last-Translator: \n"
"Language-Team: Spanish (United)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: es-un\n"
"X-Crowdin-File: /master/nature/docs/locale/en/LC_MESSAGES/tutorials.po\n"
"X-Crowdin-File-ID: 9570\n"
"Language: es_UN\n"

#: ../../tutorials/01_electronic_structure.ipynb:13
#: ../../tutorials/02_vibrational_structure.ipynb:13
#: ../../tutorials/03_ground_state_solvers.ipynb:13
#: ../../tutorials/04_excited_states_solvers.ipynb:13
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:13
#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:13
#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr "Ejecutar de forma interactiva en jupyter notebook."

#: ../../tutorials/01_electronic_structure.ipynb:9
msgid "Electronic structure"
msgstr "Estructura electrónica"

#: ../../tutorials/01_electronic_structure.ipynb:21
#: ../../tutorials/02_vibrational_structure.ipynb:21
#: ../../tutorials/03_ground_state_solvers.ipynb:21
#: ../../tutorials/04_excited_states_solvers.ipynb:21
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:21
msgid "Introduction"
msgstr "Introducción"

#: ../../tutorials/01_electronic_structure.ipynb:23
#: ../../tutorials/02_vibrational_structure.ipynb:23
msgid "The molecular Hamiltonian is"
msgstr "El Hamiltoniano molecular es"

#: ../../tutorials/01_electronic_structure.ipynb:25
#: ../../tutorials/02_vibrational_structure.ipynb:25
msgid "\\mathcal{H} = - \\sum_I \\frac{\\nabla_{R_I}^2}{M_I} - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|} + \\sum_I\\sum_{J>I} \\frac{Z_I Z_J e^2}{|R_I-R_J|}"
msgstr "\\mathcal{H} = - \\sum_I \\frac{\\nabla_{R_I}^2}{M_I} - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|} + \\sum_I\\sum_{J>I} \\frac{Z_I Z_J e^2}{|R_I-R_J|}"

#: ../../tutorials/01_electronic_structure.ipynb:30
#: ../../tutorials/02_vibrational_structure.ipynb:30
msgid "Because the nuclei are much heavier than the electrons they do not move on the same time scale and therefore, the behavior of nuclei and electrons can be decoupled. This is the Born-Oppenheimer approximation."
msgstr "Debido a que los núcleos son mucho más pesados que los electrones, no se mueven en la misma escala de tiempo y, por lo tanto, el comportamiento de los núcleos y los electrones puede desacoplarse. Esta es la aproximación de Born-Oppenheimer."

#: ../../tutorials/01_electronic_structure.ipynb:32
msgid "Therefore, one can first tackle the electronic problem with nuclear coordinate entering only as parameters. The energy levels of the electrons in the molecule can be found by solving the non-relativistic time independent Schroedinger equation,"
msgstr "Por lo tanto, primero se puede abordar el problema electrónico con la entrada de coordenadas nucleares solo como parámetros. Los niveles de energía de los electrones en la molécula se pueden encontrar resolviendo la ecuación de Schröedinger no relativista independiente del tiempo,"

#: ../../tutorials/01_electronic_structure.ipynb:34
msgid "\\mathcal{H}_{\\text{el}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"
msgstr "\\mathcal{H}_{\\text{el}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"

#: ../../tutorials/01_electronic_structure.ipynb:39
msgid "where"
msgstr "donde"

#: ../../tutorials/01_electronic_structure.ipynb:41
msgid "\\mathcal{H}_{\\text{el}} = - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|}."
msgstr "\\mathcal{H}_{\\text{el}} = - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|}."

#: ../../tutorials/01_electronic_structure.ipynb:46
msgid "In particular the ground state energy is given by:"
msgstr "En particular, la energía del estado base es dada por:"

#: ../../tutorials/01_electronic_structure.ipynb:48
msgid "E_0 = \\frac{\\langle \\Psi_0 | H_{\\text{el}} | \\Psi_0 \\rangle}{\\langle \\Psi_0 | \\Psi_0 \\rangle}"
msgstr "E_0 = \\frac{\\langle \\Psi_0 | H_{\\text{el}} | \\Psi_0 \\rangle}{\\langle \\Psi_0 | \\Psi_0 \\rangle}"

#: ../../tutorials/01_electronic_structure.ipynb:53
msgid "where :math:`\\Psi_0` is the ground state of the system."
msgstr "donde :math:`\\Psi_0` es el estado base del sistema."

#: ../../tutorials/01_electronic_structure.ipynb:55
msgid "However, the dimensionality of this problem grows exponentially with the number of degrees of freedom. To tackle this issue we would like to prepare :math:`\\Psi_0` on a quantum computer and measure the Hamiltonian expectation value (or :math:`E_0`) directly."
msgstr "Sin embargo, la dimensionalidad de este problema crece exponencialmente con el número de grados de libertad. Para abordar este problema nos gustaría preparar :math:` \\Psi_0 ` en una computadora cuántica y medir el valor esperado del Hamiltoniano (o :math:` E_0 `) directamente."

#: ../../tutorials/01_electronic_structure.ipynb:57
msgid "So how do we do that concretely?"
msgstr "Entonces, ¿Cómo lo hacemos concretamente?"

#: ../../tutorials/01_electronic_structure.ipynb:69
msgid "The Hartree-Fock initial state"
msgstr "Estado inicial de Hartree-Fock"

#: ../../tutorials/01_electronic_structure.ipynb:71
msgid "A good starting point for solving this problem is the Hartree-Fock (HF) method. This method approximates a N-body problem into N one-body problems where each electron evolves in the mean-field of the others. Classically solving the HF equations is efficient and leads to the exact exchange energy but does not include any electron correlation. Therefore, it is usually a good starting point to start adding correlation."
msgstr "Un buen punto de partida para resolver este problema es el método Hartree-Fock (HF). Este método aproxima un problema de N-cuerpos en N problemas de un solo cuerpo donde cada electrón evoluciona en el campo medio de los demás. Resolver clásicamente las ecuaciones de HF es eficiente y conduce a la energía de intercambio exacta, pero no incluye ninguna correlación entre los electrones. Por lo tanto, suele ser un buen punto de partida para empezar a añadir las correlaciones."

#: ../../tutorials/01_electronic_structure.ipynb:73
msgid "The Hamiltonian can then be re-expressed in the basis of the solutions of the HF method, also called Molecular Orbitals (MOs):"
msgstr "Luego, el Hamiltoniano se puede volver a expresar en la base de las soluciones del método HF, también llamado Orbitales Moleculares (MOs):"

#: ../../tutorials/01_electronic_structure.ipynb:75
msgid "\\hat{H}_{elec}=\\sum_{pq} h_{pq} \\hat{a}^{\\dagger}_p \\hat{a}_q +\n"
"\\frac{1}{2} \\sum_{pqrs} h_{pqrs}  \\hat{a}^{\\dagger}_p \\hat{a}^{\\dagger}_q \\hat{a}_r  \\hat{a}_s"
msgstr "\\hat{H}_{elec}=\\sum_{pq} h_{pq} \\hat{a}^{\\dagger}_p \\hat{a}_q +\n"
"\\frac{1}{2} \\sum_{pqrs} h_{pqrs}  \\hat{a}^{\\dagger}_p \\hat{a}^{\\dagger}_q \\hat{a}_r  \\hat{a}_s"

#: ../../tutorials/01_electronic_structure.ipynb:81
msgid "with the 1-body integrals"
msgstr "con las integrales de 1 cuerpo"

#: ../../tutorials/01_electronic_structure.ipynb:83
msgid "h_{pq} = \\int \\phi^*_p(r) \\left( -\\frac{1}{2} \\nabla^2 - \\sum_{I} \\frac{Z_I}{R_I- r} \\right)   \\phi_q(r)"
msgstr "h_{pq} = \\int \\phi^*_p(r) \\left( -\\frac{1}{2} \\nabla^2 - \\sum_{I} \\frac{Z_I}{R_I- r} \\right)   \\phi_q(r)"

#: ../../tutorials/01_electronic_structure.ipynb:88
msgid "and 2-body integrals"
msgstr "y las integrales de 2 cuerpos"

#: ../../tutorials/01_electronic_structure.ipynb:90
msgid "h_{pqrs} = \\int \\frac{\\phi^*_p(r_1)  \\phi^*_q(r_2) \\phi_r(r_2)  \\phi_s(r_1)}{|r_1-r_2|}."
msgstr "h_{pqrs} = \\int \\frac{\\phi^*_p(r_1)  \\phi^*_q(r_2) \\phi_r(r_2)  \\phi_s(r_1)}{|r_1-r_2|}."

#: ../../tutorials/01_electronic_structure.ipynb:95
msgid "The MOs (:math:`\\phi_u`) can be occupied or virtual (unoccupied). One MO can contain 2 electrons. However, in what follows we actually work with Spin Orbitals which are associated with a spin up (:math:`\\alpha`) of spin down (:math:`\\beta`) electron. Thus Spin Orbitals can contain one electron or be unoccupied."
msgstr "Los MOs (:math:`\\phi_u`) pueden ser ocupados o virtuales (desocupados). Un MO puede contener 2 electrones. Sin embargo, en lo que sigue realmente trabajamos con orbitales de espín que están asociados con un espín de electrón hacia arriba (:math:`\\alpha`) o hacia abajo (:math:`\\beta`). Así, los orbitales de espín pueden contener un electrón o estar desocupados."

#: ../../tutorials/01_electronic_structure.ipynb:97
msgid "We now show how to concretely realise these steps with Qiskit."
msgstr "Ahora mostramos cómo realizar estos pasos concretamente con Qiskit."

#: ../../tutorials/01_electronic_structure.ipynb:108
msgid "Qiskit is interfaced with different classical codes which are able to find the HF solutions. Interfacing between Qiskit and the following codes is already available: \\* Gaussian \\* Psi4 \\* PyQuante \\* PySCF"
msgstr "Qiskit está interconectado con diferentes códigos clásicos que son capaces de encontrar las soluciones de HF. Ya está disponible la interconexión entre Qiskit y los siguientes códigos: \\* Gaussian \\* Psi4 \\* PyQuante \\* PySCF"

#: ../../tutorials/01_electronic_structure.ipynb:110
msgid "In the following we set up a PySCF driver, for the hydrogen molecule at equilibrium bond length (0.735 angstrom) in the singlet state and with no charge."
msgstr "A continuación inicializamos un driver PySCF, para la molécula de hidrógeno en la longitud de equilibrio de enlace (0.735 angstrom) en el estado singlete y sin carga."

#: ../../tutorials/01_electronic_structure.ipynb:135
msgid "For further information about the drivers see https://qiskit.org/documentation/nature/apidocs/qiskit_nature.drivers.html"
msgstr "Para más información acerca de los controladores, vea https://qiskit.org/documentation/nature/apidocs/qiskit_nature.drivers.html"

#: ../../tutorials/01_electronic_structure.ipynb:147
msgid "The mapping from fermions to qubits"
msgstr "El mapeo de fermiones a qubits"

#: ../../tutorials/01_electronic_structure.ipynb:149
msgid "|adf16ee8a3ef49c48206f98a85cc78b6|"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:151
msgid "The Hamiltonian given in the previous section is expressed in terms of fermionic operators. To encode the problem into the state of a quantum computer, these operators must be mapped to spin operators (indeed the qubits follow spin statistics)."
msgstr "El Hamiltoniano dado en la sección previa esta expresado en términos de operadores fermiónicos. Para codificar el problema en el estado de una computadora cuántica, estos operadores deben ser mapeados a operadores de espín (de hecho, los qubits siguen las estadísticas de espín)."

#: ../../tutorials/01_electronic_structure.ipynb:153
msgid "There exist different mapping types with different properties. Qiskit already supports the following mappings: \\* The Jordan-Wigner ‘jordan_wigner’ mapping (über das paulische äquivalenzverbot. In The Collected Works of Eugene Paul Wigner (pp. 109-129). Springer, Berlin, Heidelberg (1993)). \\* The Parity ‘parity’ (The Journal of chemical physics, 137(22), 224109 (2012)) \\* The Bravyi-Kitaev ‘bravyi_kitaev’ (Annals of Physics, 298(1), 210-226 (2002))"
msgstr "Existen diferentes tipos de mapeo con diferentes propiedades. Qiskit ya soporta los siguientes mapeos: \\* The Jordan-Wigner ‘jordan_wigner’ mapping (über das paulische äquivalenzverbot. In The Collected Works of Eugene Paul Wigner (pp. 109-129). Springer, Berlin, Heidelberg (1993)). \\* The Parity ‘parity’ (The Journal of chemical physics, 137(22), 224109 (2012)) \\* The Bravyi-Kitaev ‘bravyi_kitaev’ (Annals of Physics, 298(1), 210-226 (2002))"

#: ../../tutorials/01_electronic_structure.ipynb:155
msgid "The Jordan-Wigner mapping is particularly interesting as it maps each Spin Orbital to a qubit (as shown on the Figure above)."
msgstr "El mapeo Jordan-Wigner es particularmente interesante ya que mapea cada orbital de espín a un qubit (como se mostró en la figura anterior)."

#: ../../tutorials/01_electronic_structure.ipynb:157
msgid "Here we set up the Electronic Structure Problem to generate the Second quantized operator and a qubit converter that will map it to a qubit operator."
msgstr "Aquí configuramos el Electronic Structure Problem para generar el segundo operador cuantificado y un convertidor de qubit que lo asignará con un operador de qubit."

#: ../../tutorials/01_electronic_structure.ipynb:239
msgid "If we now transform this Hamiltonian for the given driver defined above we get our qubit operator:"
msgstr "Si ahora transformamos este Hamiltoniano para el driver dado definido anteriormente obtenemos nuestro operador de qubits:"

#: ../../tutorials/01_electronic_structure.ipynb:309
msgid "In the minimal (STO-3G) basis set 4 qubits are required. We can reduce the number of qubits by using the Parity mapping, which allows for the removal of 2 qubits by exploiting known symmetries arising from the mapping."
msgstr "En la base mínima (STO-3G) se requieren 4 qubits. Podemos reducir el número de qubits utilizando el mapeo de paridad, que permite la eliminación de 2 qubits explotando las simetrías conocidas que surgen del mapeo."

#: ../../tutorials/01_electronic_structure.ipynb:359
msgid "This time only 2 qubits are needed."
msgstr "Esta vez sólo se necesitan 2 qubits."

#: ../../tutorials/01_electronic_structure.ipynb:370
msgid "Now that the Hamiltonian is ready, it can be used in a quantum algorithm to find information about the electronic structure of the corresponding molecule. Check out our tutorials on Ground State Calculation and Excited States Calculation to learn more about how to do that in Qiskit!"
msgstr "Ahora que el Hamiltoniano está listo, se puede utilizar en un algoritmo cuántico para encontrar información sobre la estructura electrónica de la molécula correspondiente. ¡Revisa nuestros tutoriales sobre Cálculo del Estado Base y Cálculo de Estados Excitados para aprender más acerca de cómo hacer eso en Qiskit!"

#: ../../tutorials/02_vibrational_structure.ipynb:9
msgid "Vibrational structure"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:32
msgid "Within the Born-Oppenheimer approximation, a molecular wave function is factorized as a product of an electronic part, which is the solution of the electronic Schroedinger equation, and a vibro-rotational one, which is the solution of the nuclear Schroedinger equation in the potential energy surface (PES) generated by sampling the eigenvalues of the electronic Schroedinger equation for different geometries."
msgstr "Dentro de la aproximación de Born-Oppenheimer, una función de onda molecular es factorizada como un producto de la parte del electrón, que es la solución a la ecuación de Schröedinger del electrón, una parte vibro-rotacional, que es la solución de la ecuación de Shröedinger nuclear en la superficie de energía superficial (PES, por sus siglas en inglés), generada al muestrear los eigenvalores de la ecuación de Schröedinger del electrón para diferentes geometrías."

#: ../../tutorials/02_vibrational_structure.ipynb:34
msgid "The nuclear Schroedinger equation is usually solved in two steps, in analogy with its electronic counterpart. A single-particle basis (the basis functions are called, in this case, modals) is obtained either by the harmonic approximation applied to the PES or from a vibrational self-consistent field (VSCF) calculation. Vibrational anharmonic correlations are added a-posteriori with perturbative or variational approaches. The latter include Vibrational Configuration Interaction (VCI) and Vibrational Coupled Cluster (VCC) for highly-accurate anharmonic energies. The main advantage of VCI and VCC over alternative approaches (such as perturbation theories) is that their accuracy can be systematically improved towards the complete basis set limit for a given PES. However, their applicability is limited to small molecules with up to about 10 atoms due to their unfavorable scaling with system size."
msgstr "La ecuación nuclear de Schroedinger generalmente se resuelve en dos pasos, en analogía con su contraparte electrónica. Una base de una sola partícula (las funciones de base se denominan, en este caso, modales) se obtiene mediante la aproximación armónica aplicada al PES o a partir de un cálculo de campo autoconsistente vibratorio (vibrational self-consistent field, VSCF). Las correlaciones anarmónicas vibratorias se agregan a posteriori con enfoques perturbativos o variacionales. Estos últimos incluyen Interacción de Configuración Vibratoria (Vibrational Configuration Interaction, VCI) y Clúster Acoplado Vibratorio (Vibrational Coupled Cluster, VCC) para energías anarmónicas de alta precisión. La principal ventaja de VCI y VCC sobre los enfoques alternativos (como las teorías de perturbación) es que su precisión se puede mejorar sistemáticamente hacia el límite del conjunto de bases completo para un PES dado. Sin embargo, su aplicabilidad se limita a moléculas pequeñas con hasta aproximadamente 10 átomos debido a su escalado desfavorable con el tamaño del sistema."

#: ../../tutorials/02_vibrational_structure.ipynb:37
msgid "To tackle the scaling problem we would like to use quantum algorithms."
msgstr "Para abordar el problema de escalamiento nos gustaría usar algoritmos cuánticos."

#: ../../tutorials/02_vibrational_structure.ipynb:39
msgid "The nuclear Schroedinger equation is"
msgstr "La ecuación nuclear de Schröedinger es"

#: ../../tutorials/02_vibrational_structure.ipynb:41
msgid "\\mathcal{H}_{\\text{vib}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"
msgstr "\\mathcal{H}_{\\text{vib}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"

#: ../../tutorials/02_vibrational_structure.ipynb:46
msgid "The so-called Watson Hamiltonian (neglecting vibro-rotational coupling terms) is"
msgstr "El llamado Hamiltoniano de Watson (ignorando los términos de acoplamiento vibro-rotacional) es"

#: ../../tutorials/02_vibrational_structure.ipynb:48
msgid "\\mathcal{H}_\\text{vib}(Q_1, \\ldots, Q_L)\n"
"  = - \\frac{1}{2} \\sum_{l=1}^{L} \\frac{\\partial^2}{\\partial Q_l^2} + V(Q_1, \\ldots, Q_L)"
msgstr "\\mathcal{H}_\\text{vib}(Q_1, \\ldots, Q_L)\n"
"  = - \\frac{1}{2} \\sum_{l=1}^{L} \\frac{\\partial^2}{\\partial Q_l^2} + V(Q_1, \\ldots, Q_L)"

#: ../../tutorials/02_vibrational_structure.ipynb:54
msgid "where :math:`Q_l` are the harmonic mass-weighted normal coordinates."
msgstr "donde :math:`Q_l` son las coordenadas cartesianas armónicas ponderadas en masa."

#: ../../tutorials/02_vibrational_structure.ipynb:56
msgid ":math:`\\mathcal{H}_\\text{vib}` must be mapped to an operator that acts on the states of a given set of :math:`N_q` qubits in order to calculate its eigenfunctions on quantum hardware. In electronic structure calculations, the mapping is achieved by expressing the non-relativistic electronic Hamiltonian in second quantization, :nbsphinx-math:`\\textit{i.e.}` by projecting it onto the complete set of antisymmetrized occupation number vectors (ONV) generated by a given (finite) set of orbitals. To encode the vibrational Hamiltonian in an analogous second quantization operators, we expand the potential :math:`V(Q_1, \\ldots, Q_L)` with the :math:`n`-body expansion as follows:"
msgstr ":math:`\\mathcal{H}_\\text{vib}` debe ser correlacionado a un operador que actúa sobre los estados de un conjunto de :math:`N_q` qubits para poder calcular sus eigenfunciones en hardware cuántico. En los cálculos de estructura electrónica, la correlación se logra al expresar el Hamiltoniano no relativista del electrón en la segunda cuantización :nbsphinx-math:`\\textit{i.e.}` mediante una proyección sobre el conjunto completo de vectores de números de ocupación (ONV, por sus siglas en inglés) generados por un conjunto (finito) de orbitales dados. Para codificar el Hamiltoniano vibracional en un operador de segunda cuantización análogo, expandimos el potencial :math:`V(Q_1, \\ldots, Q_L)` con la expansión de :math:`n` cuerpos de la siguiente manera:"

#: ../../tutorials/02_vibrational_structure.ipynb:59
msgid "V(Q_1, \\ldots, Q_L) = V_0 + \\sum_{l=1}^L V^{[l]}(Q_l)\n"
"  + \\sum_{l<m}^L V^{[l,m]}(Q_l, Q_m) + \\sum_{l<m<n}^L V^{[l,m,n]}(Q_l, Q_m, Q_n) + \\ldots"
msgstr "V(Q_1, \\ldots, Q_L) = V_0 + \\sum_{l=1}^L V^{[l]}(Q_l)\n"
"  + \\sum_{l<m}^L V^{[l,m]}(Q_l, Q_m) + \\sum_{l<m<n}^L V^{[l,m,n]}(Q_l, Q_m, Q_n) + \\ldots"

#: ../../tutorials/02_vibrational_structure.ipynb:65
msgid "where :math:`V_0` is the electronic energy of the reference geometry, the one-mode term :math:`V^{[l]}(Q_l)` represents the variation of the PES upon change of the :math:`l`-th normal coordinate from the equilibrium position. Similarly, the two-body potential :math:`V^{[l,m]}(Q_l, Q_m)` represents the change in the exact PES upon a simultaneous displacement along the :math:`l`-th and :math:`m`-th coordinates. Often, including terms up to three-body in the :math:`L`-body expansion is sufficient to obtain an accuracy of about 1~cm\\ :math:`^{-1}`. We highlight that the many-body expansion of the potential operator defining the Watson Hamiltonian contains arbitrarily high coupling terms. This is a crucial difference compared to the non-relativistic electronic-structure Hamiltonian that contains only pairwise interactions."
msgstr "donde :math:`V_0` es la energía electrónica de la geometría de referencia, el término de un modo :math:`V^{[l]}(Q_l)` representa la variación del PES al cambiar de la :math:`l`-ésima coordenada normal desde la posición de equilibrio. De manera similar, el potencial de dos cuerpos :math:`V^{[l,m]}(Q_l, Q_m)` representa el cambio en el PES exacto tras un desplazamiento simultáneo a lo largo de las :math:`l`-ésimas y :math:`m`-ésimas coordenadas. A menudo, incluir términos de hasta tres cuerpos en la expansión de :math:`L` cuerpos es suficiente para obtener una precisión de aproximadamente 1~cm\\ :math:`^{-1}`. Destacamos que la expansión de muchos cuerpos del operador potencial que define el Hamiltoniano de Watson contiene términos de acoplamiento arbitrariamente altos. Esta es una diferencia crucial en comparación con el Hamiltoniano de estructura electrónica no relativista que contiene solo interacciones por pares."

#: ../../tutorials/02_vibrational_structure.ipynb:68
msgid "A flexible second quantization form of the Watson Hamiltonian is obtained within the so-called n-mode representation. Let us assume that each mode :math:`l` is described by a :math:`N_l`-dimensional basis set :math:`S_l` defined as follows:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:70
msgid "\\mathcal{S}_l = \\{ \\phi_1^{(l)} (Q_l) , \\ldots , \\phi_{N_l}^{(l)} (Q_l) \\} \\, ."
msgstr "\\mathcal{S}_l = \\{ \\phi_1^{(l)} (Q_l) , \\ldots , \\phi_{N_l}^{(l)} (Q_l) \\} \\, ."

#: ../../tutorials/02_vibrational_structure.ipynb:75
msgid "The :math:`n`-mode wave function can be expanded in the product basis :math:`\\mathcal{S} = \\otimes_{i=1}^L \\mathcal{S}_i` as the following CI-like expansion:"
msgstr "La función de onda de :math:`n`-modos se puede expandir en producto de bases :math:`\\mathcal{S} = \\otimes_{i=1}^L \\mathcal{S}_i` como la siguiente expansión tipo CI (interacción de configuraciones):"

#: ../../tutorials/02_vibrational_structure.ipynb:77
msgid "|\\Psi\\rangle = \\sum_{k_1=1}^{N_1} \\cdots \\sum_{k_L=1}^{N_L} C_{k_1,\\ldots,k_L}\n"
"  \\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L) \\, ,"
msgstr "|\\Psi\\rangle = \\sum_{k_1=1}^{N_1} \\cdots \\sum_{k_L=1}^{N_L} C_{k_1,\\ldots,k_L}\n"
"  \\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L) \\, ,"

#: ../../tutorials/02_vibrational_structure.ipynb:83
msgid "The many-body basis function :math:`\\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L)` are encoded within the so-called :math:`n`-mode second quantization as occupation-number vectors (ONVs) as follows:"
msgstr "Las funciones base de muchos-cuerpos :math:`\\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L)` están codificadas dentro de la llamada segunda cuantización de :math:`n`-modos como vectores de número de ocupación (ONVs) de la siguiente manera:"

#: ../../tutorials/02_vibrational_structure.ipynb:85
msgid "\\phi_{k_1}(Q_1) \\cdots \\phi_{k_L}(Q_L)\n"
"                    \\equiv  |0_1 \\cdots 1_{k_1} \\cdots 0_{N_1},\n"
"                                 0_1 \\cdots 1_{k_2} \\cdots 0_{N_2},\n"
"                                 \\cdots ,\n"
"                                 0_1 \\cdots 1_{k_L} \\cdots 0_{N_L}\\rangle \\, ."
msgstr "\\phi_{k_1}(Q_1) \\cdots \\phi_{k_L}(Q_L)\n"
"                    \\equiv  |0_1 \\cdots 1_{k_1} \\cdots 0_{N_1},\n"
"                                 0_1 \\cdots 1_{k_2} \\cdots 0_{N_2},\n"
"                                 \\cdots ,\n"
"                                 0_1 \\cdots 1_{k_L} \\cdots 0_{N_L}\\rangle \\, ."

#: ../../tutorials/02_vibrational_structure.ipynb:94
msgid "The ONV defined above is, therefore, the product of :math:`L` mode-specific ONVs, each one describing an individual mode. Since each mode is described by one and only one basis function, the occupation of each mode-specific ONV is one. From a theoretical perspective, each mode can be interpreted as a distinguishable quasi-particle (defined as phonons in solid-state physics). Distinguishability arises from the fact that the PES is not invariant by permutation of two modes, also in this case unlike the Coulomb interaction between two equal particles. From this perspective, a molecule can be interpreted as a collection of :math:`L` indistinguishable particles that interact through the PES operator."
msgstr "El ONV definido anteriormente es, por lo tanto, el producto de :math:`L` ONVs de modo específico, cada uno describiendo un modo individual. Dado que cada modo está descrito por una y solo una función base, la ocupación de cada ONV de modo específico es uno. Desde una perspectiva teórica, cada modo se puede interpretar como una cuasipartícula distinguible (definidas como fonones en física de estado sólido). La distinguibilidad surge del hecho que la PES no es invariante por la permutación de dos modos, también en este caso a diferencia de la interacción de Coulomb entre dos partículas iguales. Desde esta perspectiva, una molécula se puede interpretar como una colección de :math:`L` partículas indistinguibles que interactúan a través del operador de la PES."

#: ../../tutorials/02_vibrational_structure.ipynb:97
msgid "Based on this second-quantization representation we introduce a pair of creation and annihilation operators per mode :math:`l` :nbsphinx-math:`\\textit{and}` per basis function :math:`k_l` defined as:"
msgstr "Basándonos en esta representación de segunda cuantización, presentamos un par de operadores de creación y aniquilación por modo :math:`l` :nbsphinx-math:`\\textit{and}` por función base :math:`k_l` definidos como:"

#: ../../tutorials/02_vibrational_structure.ipynb:99
msgid "\\begin{aligned}\n"
"  a_{k_l}^\\dagger |\\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"    &=  | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l}^\\dagger | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"   &= | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"\\end{aligned}"
msgstr "\\begin{aligned}\n"
"  a_{k_l}^\\dagger |\\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"    &=  | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l}^\\dagger | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"   &= | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"\\end{aligned}"

#: ../../tutorials/02_vibrational_structure.ipynb:111
#: ../../tutorials/04_excited_states_solvers.ipynb:112
msgid "with"
msgstr "con"

#: ../../tutorials/02_vibrational_structure.ipynb:113
msgid "\\begin{aligned}\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m}^\\dagger \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}, a_{h_m} \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m} \\right] &= \\delta_{l,m} \\, , \\delta_{k_l,h_m}\n"
"\\end{aligned}"
msgstr "\\begin{aligned}\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m}^\\dagger \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}, a_{h_m} \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m} \\right] &= \\delta_{l,m} \\, , \\delta_{k_l,h_m}\n"
"\\end{aligned}"

#: ../../tutorials/02_vibrational_structure.ipynb:122
msgid "The second quantization form is obtained by expressing the potential as"
msgstr "La forma de segunda cuantización se obtiene expresando el potencial como"

#: ../../tutorials/02_vibrational_structure.ipynb:124
msgid "\\begin{aligned}\n"
" \\mathcal{H}_\\text{vib}^{SQ} =& \\sum_{l=1}^L\n"
"   \\sum_{k_l,h_l}^{N_l} \\langle \\phi_{k_l} | T(Q_l) + V^{[l]}(Q_l) | \\phi_{h_l} \\rangle a_{k_l}^+ a_{h_l} \\\\\n"
"+& \\sum_{l<m}^L \\sum_{k_l,h_l}^{N_l} \\sum_{k_m,h_m}^{N_m}\n"
"   \\langle \\phi_{k_l} \\phi_{k_m} | V^{[l,m]}(Q_l, Q_m) | \\phi_{h_l} \\phi_{h_m} \\rangle\n"
"   a_{k_l}^+ a_{k_m}^+ a_{h_l} a_{h_m} + \\cdots\n"
"\\end{aligned}"
msgstr "\\begin{aligned}\n"
" \\mathcal{H}_\\text{vib}^{SQ} =& \\sum_{l=1}^L\n"
"   \\sum_{k_l,h_l}^{N_l} \\langle \\phi_{k_l} | T(Q_l) + V^{[l]}(Q_l) | \\phi_{h_l} \\rangle a_{k_l}^+ a_{h_l} \\\\\n"
"+& \\sum_{l<m}^L \\sum_{k_l,h_l}^{N_l} \\sum_{k_m,h_m}^{N_m}\n"
"   \\langle \\phi_{k_l} \\phi_{k_m} | V^{[l,m]}(Q_l, Q_m) | \\phi_{h_l} \\phi_{h_m} \\rangle\n"
"   a_{k_l}^+ a_{k_m}^+ a_{h_l} a_{h_m} + \\cdots\n"
"\\end{aligned}"

#: ../../tutorials/02_vibrational_structure.ipynb:135
msgid "We highlight here the difference between the operators defined here above and the electronic structure one. First, as we already mentioned, the potential contains (in principle) three- and higher-body coupling terms that lead to strings with six (or more) second-quantization operators. Moreover, the Hamiltonian conserves the number of particles for each mode, as can be seen from the fact that the number of creation and annihilation operators for a given mode is the same in each term. Nevertheless, different modes are coupled by two- (and higher) body terms containing SQ operators belonging to different modes :math:`l` and :math:`m`."
msgstr "Destacamos aquí la diferencia entre los operadores definidos aquí anteriormente y el de la estructura del electrón. Primero, como ya mencionamos, el potencial contiene (en principio) términos de acoplamiento de tres y más cuerpos que conducen a strings con seis (o más) operadores de segunda cuantización. Por otra parte, el Hamiltoniano conserva el número de partículas para cada modo, como se puede ver del hecho que el número de operadores de creación y aniquilación para un modo dado es el mismo en cada término. No obstante, modos diferentes están acoplados por términos de dos (o más) cuerpos que contienen operadores SQ que pertenecen a diferentes modos :math:`l` y :math:`m`."

#: ../../tutorials/02_vibrational_structure.ipynb:138
msgid "Reference: Ollitrault, Pauline J., et al., arXiv:2003.12578 (2020)."
msgstr "Referencia: Ollitrault, Pauline J., et al., arXiv:2003.12578 (2020)."

#: ../../tutorials/02_vibrational_structure.ipynb:149
msgid "Compute the electronic potential"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:151
msgid "Solving the ESE for different nuclear configurations to obtain the PES function :math:`V(Q_1, \\ldots, Q_L)`. So far Qiskit gives the possibility to approximate the PES with a quartic force field."
msgstr "Resolver el ESE para diferentes configuraciones nucleares para obtener la función PES :math:`V(Q_1, \\ldots, Q_L)`. Hasta ahora Qiskit ofrece la posibilidad de aproximar la PES con un campo de fuerza cuártico."

#: ../../tutorials/02_vibrational_structure.ipynb:153
msgid "V(Q_1, \\ldots, Q_L) = \\frac{1}{2}  \\sum_{ij} k_{ij} Q_i Q_j\n"
"                  + \\frac{1}{6}  \\sum_{ijk} k_{ijk} Q_i Q_j Q_k\n"
"                  + \\frac{1}{16} \\sum_{ijkl} k_{ijkl} Q_i Q_j Q_k Q_l"
msgstr "V(Q_1, \\ldots, Q_L) = \\frac{1}{2}  \\sum_{ij} k_{ij} Q_i Q_j\n"
"                  + \\frac{1}{6}  \\sum_{ijk} k_{ijk} Q_i Q_j Q_k\n"
"                  + \\frac{1}{16} \\sum_{ijkl} k_{ijkl} Q_i Q_j Q_k Q_l"

#: ../../tutorials/02_vibrational_structure.ipynb:160
msgid "The advantage of such form for the PES is that the anharmonic force fields (:math:`k_{ij}`, :math:`k_{ijk}`, :math:`k_{ijkl}`) can be calculated by finite-difference approaches. For methods for which the nuclear energy Hessian can be calculated analytically with response theory-based methods (such as HF and DFT), the quartic force field can be calculated by semi-numerical differentiation as:"
msgstr "La ventaja de dicha forma para la PES es que los campos de fuerza anarmónicos (:math:`k_{ij}`, :math:`k_{ijk}`, :math:`k_{ijkl}`) se pueden calcular por enfoques de diferencia finita. Para métodos para los que la energía nuclear del Hessiano se puede calcular analíticamente con métodos basados en la teoría de la respuesta (como HF y DFT) , el campo de fuerza cuártico se puede calcular mediante una diferenciación semi-numérica como:"

#: ../../tutorials/02_vibrational_structure.ipynb:162
msgid "k_{ijk} = \\frac{H_{ij}(+\\delta Q_k) - H_{ij}(-\\delta Q_k)}{2\\delta Q_k}"
msgstr "k_{ijk} = \\frac{H_{ij}(+\\delta Q_k) - H_{ij}(-\\delta Q_k)}{2\\delta Q_k}"

#: ../../tutorials/02_vibrational_structure.ipynb:167
msgid "and"
msgstr "y"

#: ../../tutorials/02_vibrational_structure.ipynb:169
msgid "k_{ijkl} = \\frac{H_{ij}(+\\delta Q_k+\\delta Q_l) - H_{ij}(+\\delta Q_k-\\delta Q_l)\n"
"                    -H_{ij}(-\\delta Q_k+\\delta Q_l) + H_{ij}(-\\delta Q_k+\\delta Q_l)}\n"
"                    {4\\delta Q_k \\delta Q_l}"
msgstr "k_{ijkl} = \\frac{H_{ij}(+\\delta Q_k+\\delta Q_l) - H_{ij}(+\\delta Q_k-\\delta Q_l)\n"
"                    -H_{ij}(-\\delta Q_k+\\delta Q_l) + H_{ij}(-\\delta Q_k+\\delta Q_l)}\n"
"                    {4\\delta Q_k \\delta Q_l}"

#: ../../tutorials/02_vibrational_structure.ipynb:176
msgid "Such numerical procedure is implemented, for instance, in the Gaussian suite of programs."
msgstr "Tal procedimiento numérico está implementado, por ejemplo, en el conjunto de programas Gaussian."

#: ../../tutorials/02_vibrational_structure.ipynb:178
msgid "In practice this can be done with Qiskit using the GaussianForceDriver."
msgstr "En la práctica esto se puede hacer con Qiskit usando GaussianForceDriver."

#: ../../tutorials/02_vibrational_structure.ipynb:215
msgid "Map to a qubit Hamiltonian"
msgstr "Mapear a un Hamiltoniano de qubit"

#: ../../tutorials/02_vibrational_structure.ipynb:217
msgid "Now that we have an approximation for the potential, we need to write the Hamiltonian in second quantization. To this end we need to select a modal basis to calculate the one-body integrals :math:`\\langle\\phi_{k_i}| V(Q_i) | \\phi_{h_i} \\rangle`, two-body integrals :math:`\\langle\\phi_{k_i} \\phi_{k_j}| V(Q_i,Q_j) | \\phi_{h_i} \\phi_{h_j} \\rangle`\\ …"
msgstr "Ahora que tenemos una aproximación para el potencial, necesitamos escribir el Hamiltoniano en la segunda cuantización. Para este fin necesitamos seleccionar una a base modal para calcular las integrales de un solo cuerpo :math:`\\langle\\phi_{k_i}| V(Q_i) | \\phi_{h_i} \\rangle`, integrales de dos cuerpos :math:`\\langle\\phi_{k_i} \\phi_{k_j}| V(Q_i,Q_j) | \\phi_{h_i} \\phi_{h_j} \\rangle`\\ …"

#: ../../tutorials/02_vibrational_structure.ipynb:219
msgid "In the simplest case, the :math:`\\phi` functions are the harmonic-oscillator eigenfunctions for each mode. The main advantage of this choice is that the integrals of a PES expressed as a Taylor expansion are easy to calculate with such basis. A routine for computing these integrals is implemented in Qiskit."
msgstr "En el caso más simple, las funciones :math:`\\phi` son las eigenfunciones del oscilador armónico para cada modo. La principal ventaja de esta elección es que las integrales de una PES expresada como una expansión de Taylor son fáciles de calcular con dicha base. Una rutina para calcular estas integrales está implementada en Qiskit."

#: ../../tutorials/02_vibrational_structure.ipynb:221
msgid "The bosonic operator, :math:`\\mathcal{H}_\\text{vib}^{SQ}`, is then created and must be mapped to a qubit operator. The direct mapping introduced in the first section of this tutorial can be used is Qiskit as follows:"
msgstr "El operador bosónico :math:`\\mathcal{H}_\\text{vib}^{SQ}`, se crea y debe ser mapeado a un operador de qubit. El mapeo directo presentado en la primera sección de este tutorial se puede usar en Qiskit de la siguiente manera:"

#: ../../tutorials/02_vibrational_structure.ipynb:247
msgid "The Vibrational operator for the problem now reads as"
msgstr "El operador vibrónico para el problema ahora se lee como"

#: ../../tutorials/02_vibrational_structure.ipynb:401
msgid "In the previous cell we defined a bosonic transformation to express the Hamiltonian in the harmonic modal basis, with 2 modals per mode with the potential truncated at order 2 and the ‘direct’ boson to qubit mapping. The calculation is then ran as:"
msgstr "En la celda previa definimos una transformación bosónica para expresar el Hamiltoniano en la base modal armónica, con 2 modales por modo con el potencial truncado en orden 2 y el bosón 'directo' al mapeo en qubit. El cálculo se ejecuta luego como:"

#: ../../tutorials/02_vibrational_structure.ipynb:560
msgid "To have a different number of modals per mode:"
msgstr "Para tener un número diferente de modales por modo:"

#: ../../tutorials/02_vibrational_structure.ipynb:1171
msgid "Now that the Hamiltonian is ready, it can be used in a quantum algorithm to find information about the vibrational structure of the corresponding molecule. Check out our tutorials on Ground State Calculation and Excited States Calculation to learn more about how to do that in Qiskit Nature!"
msgstr "Ahora que el Hamiltoniano está listo, se puede utilizar en un algoritmo cuántico para encontrar información sobre la estructura vibrónica de la molécula correspondiente. ¡Revisa nuestros tutoriales sobre Cálculo del Estado Base y Cálculo de Estados Excitados para aprender más acerca de cómo hacer eso en Qiskit Nature!"

#: ../../tutorials/03_ground_state_solvers.ipynb:9
msgid "Ground state solvers"
msgstr "Solucionadores para el estado base"

#: ../../tutorials/03_ground_state_solvers.ipynb:23
msgid "|fba11f07d2b94bfbbc01982987ba5d52|"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the ground state calculation interface of Qiskit Chemistry. The goal is to compute the ground state of a molecular Hamiltonian. This Hamiltonian can be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the Electronic structure and Vibrational structure tutorials."
msgstr "En este tutorial hablaremos de la interfaz de cálculo del estado base de Qiskit Chemistry. El objetivo es calcular el estado base de un Hamiltoniano molecular. Este Hamiltoniano puede ser electrónico o vibrónico. Para conocer más acerca de la preparación del Hamiltoniano, revisa los tutoriales de estructura Electrónica y Vibrónica."

#: ../../tutorials/03_ground_state_solvers.ipynb:27
#: ../../tutorials/04_excited_states_solvers.ipynb:27
msgid "The first step is to define the molecular system. In the following we ask for the electronic part of a hydrogen molecule."
msgstr "El primer paso es definir el sistema molecular. A continuación, pedimos la parte electrónica de una molécula de hidrógeno."

#: ../../tutorials/03_ground_state_solvers.ipynb:63
#: ../../tutorials/04_excited_states_solvers.ipynb:62
msgid "The Solver"
msgstr "El Solucionador"

#: ../../tutorials/03_ground_state_solvers.ipynb:65
#: ../../tutorials/04_excited_states_solvers.ipynb:64
msgid "Then we need to define a solver. The solver is the algorithm through which the ground state is computed."
msgstr "Después necesitamos definir un solucionador. El solucionador es el algoritmo mediante el cual el estado base es calculado."

#: ../../tutorials/03_ground_state_solvers.ipynb:67
msgid "Let’s first start with a purely classical example: the NumPy minimum eigensolver. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:90
msgid "To find the ground state we coul also use the Variational Quantum Eigensolver (VQE) algorithm. The VQE algorithms works by exchanging information between a classical and a quantum computer as depicted in the following figure."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:92
msgid "|8d30bf84bb6141219d7aa92324383263|"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:94
msgid "Let’s initialize a VQE solver."
msgstr "Inicialicemos un solucionador de VQE."

#: ../../tutorials/03_ground_state_solvers.ipynb:123
msgid "To define the VQE solver one needs two essential elements:"
msgstr "Para definir el solucionador de VQE necesitamos dos elementos esenciales:"

#: ../../tutorials/03_ground_state_solvers.ipynb:125
msgid "A variational form: here we use the Unitary Coupled Cluster (UCC) ansatz (see for instance [Physical Review A 98.2 (2018): 022322]). Since it is a chemistry standard, a factory is already available allowing a fast initialization of a VQE with UCC. The default is to use all single and double excitations. However, the excitation type (S, D, SD) as well as other parameters can be selected."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:126
msgid "An initial state: the initial state of the qubits. In the factory used above, the qubits are initialized in the Hartree-Fock (see the electronic structure tutorial) initial state (the qubits corresponding to occupied MOs are :math:`|1\\rangle` and those corresponding to virtual MOs are :math:`|0\\rangle`."
msgstr "Un estado inicial: el estado inicial de los qubits. En la fabrica usada anteriormente, los qubits son inicializados al estado inicial de Hartree-Fock (ver el tutorial de estructura electrónica), (los qubits que corresponden a orbitales moleculares ocupados son :math:`|1\\rangle` y los que corresponden a orbitales moleculares virtuales son :math:`|0\\rangle`."

#: ../../tutorials/03_ground_state_solvers.ipynb:127
msgid "The backend: this is the quantum machine on which the right part of the figure above will be performed. Here we ask for the perfect quantum emulator (``statevector_simulator``)."
msgstr "El backend: esta es la máquina cuántica en la cual la parte derecha de la figura anterior va a ser ejecutada. Aquí pedimos el emulador cuántico perfecto (``statevector_simulator``)."

#: ../../tutorials/03_ground_state_solvers.ipynb:129
msgid "One could also use any available ansatz / initial state or even define one’s own. For instance,"
msgstr "Uno podría usar cualquier ansatz / estado inicial disponible, o incluso definir uno propio. Por ejemplo,"

#: ../../tutorials/03_ground_state_solvers.ipynb:160
#: ../../tutorials/04_excited_states_solvers.ipynb:167
msgid "The calculation and results"
msgstr "El cálculo y los resultados"

#: ../../tutorials/03_ground_state_solvers.ipynb:162
msgid "We are now ready to run the calculation."
msgstr "Ahora estamos listos para ejecutar el cálculo."

#: ../../tutorials/03_ground_state_solvers.ipynb:247
msgid "We can compare the VQE results to the NumPy exact solver and see that they match."
msgstr "Podemos comparar los resultados de VQE con el solucionador exacto de NumPy y ver que sí coinciden."

#: ../../tutorials/03_ground_state_solvers.ipynb:330
msgid "Using a filter function"
msgstr "Usando una función filtro"

#: ../../tutorials/03_ground_state_solvers.ipynb:341
msgid "Sometimes the true ground state of the Hamiltonian is not of interest because it lies in a different symmetry sector of the Hilbert space. In this case the NumPy eigensolver can take a filter function to return only the eigenstates with for example the correct number of particles. This is of particular importance in the case of vibrational structure calculations where the true ground state of the Hamiltonian is the vacuum state. A default filter function to check the number of particles is implemented in the different transformations and can be used as"
msgstr "A veces el verdadero estado del Hamiltoniano no es de interés ya que yace en un sector de simetría distinto del espacio de Hilbert. En este caso, el NumPy eigensolver puede tomar una función filtro para devolver solo los eigenestados con, por ejemplo, el número correcto de partículas. Esto es de particular importancia en el caso de los cálculos de estructuras vibrónicas donde el estado real del Hamiltoniano es el estado de vacío cuántico. Una función filtro predeterminada para revisar el número de partículas es implementada en las diferentes transformaciones y puede ser usado como"

#: ../../tutorials/04_excited_states_solvers.ipynb:9
msgid "Excited states solvers"
msgstr "Solucionadores para estados excitados"

#: ../../tutorials/04_excited_states_solvers.ipynb:23
msgid "|15a65c99e1ab4c30ad18693cd0467ff3|"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the excited states calculation interface of Qiskit Chemistry. The goal is to compute the excited states of a molecular Hamiltonian. This Hamiltonian can be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the Electronic structure and Vibrational structure tutorials."
msgstr "En este tutorial vamos a hablar de la interfaz de cálculo de estados excitados de Qiskit Chemistry. El objetivo es calcular los estados excitados de un Hamiltoniano molecular. Este Hamiltoniano puede ser electrónico o vibrónico. Para saber mas acerca de la preparación del Hamiltoniano, revise los tutoriales de estructura Electrónica y estructura Vibrónica."

#: ../../tutorials/04_excited_states_solvers.ipynb:66
msgid "Let’s first start with a purely classical example: the NumPy eigensolver. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms. Here, we are only interested to look at eigenstates with a given number of particle. To compute only those states a filter function can be passed to the NumPy eigensolver. A default filter function is already implemented in Qiskit and can be used in this way:"
msgstr "Comencemos primero con un ejemplo puramente clásico: el solucionador propio (eigensolver) NumPy. Este algoritmo diagonaliza exactamente al Hamiltoniano. Aunque escala mal, se puede usar en sistemas pequeños para verificar los resultados de los algoritmos cuánticos. Aquí, solo estamos interesados en mirar estados propios con un número dado de partículas. Para calcular solo esos estados, se puede pasar una función de filtro al eigensolver de NumPy. Una función de filtro predeterminada ya está implementada en Qiskit y se puede usar de esta manera:"

#: ../../tutorials/04_excited_states_solvers.ipynb:89
msgid "The excitation energies can also be accessed with the qEOM algorithm [arXiv preprint arXiv:1910.12890 (2019)]. The EOM method finds the excitation energies (differences in energy between the ground state and all :math:`n`\\ th excited states) by solving the following pseudo-eigenvalue problem."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:91
msgid "\\begin{pmatrix}\n"
"    \\text{M} & \\text{Q}\\\\\n"
"    \\text{Q*} & \\text{M*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}\n"
"= E_{0n}\n"
"\\begin{pmatrix}\n"
"    \\text{V} & \\text{W}\\\\\n"
"    -\\text{W*} & -\\text{V*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}"
msgstr "\\begin{pmatrix}\n"
"    \\text{M} & \\text{Q}\\\\\n"
"    \\text{Q*} & \\text{M*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}\n"
"= E_{0n}\n"
"\\begin{pmatrix}\n"
"    \\text{V} & \\text{W}\\\\\n"
"    -\\text{W*} & -\\text{V*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}"

#: ../../tutorials/04_excited_states_solvers.ipynb:114
msgid "M_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger},\\hat{\\text{H}}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr "M_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger},\\hat{\\text{H}}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"

#: ../../tutorials/04_excited_states_solvers.ipynb:119
msgid "Q_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{H}}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr "Q_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{H}}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"

#: ../../tutorials/04_excited_states_solvers.ipynb:124
msgid "V_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr "V_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"

#: ../../tutorials/04_excited_states_solvers.ipynb:129
msgid "W_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_\\alpha}^{(\\alpha)})^{\\dagger}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr "W_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_\\alpha}^{(\\alpha)})^{\\dagger}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"

#: ../../tutorials/04_excited_states_solvers.ipynb:134
msgid "Although the previous equation can be solved classically, each matrix element must be measured on the quantum computer with the corresponding ground state. To use the qEOM as a solver in Qiskit, we have to define a ground state calculation first, providing to the algorithm information on how to find the ground state. With this the qEOM solver can be initialized:"
msgstr "Aunque la ecuación anterior se puede resolver clásicamente, cada elemento de la matriz se debe medir en la computadora cuántica con el estado base correspondiente. Para usar qEOM como un solucionador en Qiskit, primero tenemos que definir un cálculo del estado base, proporcionando a los algoritmos información acerca de cómo encontrar el estado base. Con esto, se puede inicializar el solucionador qEOM:"

#: ../../tutorials/04_excited_states_solvers.ipynb:169
msgid "The results are computed and printed"
msgstr "Los resultados son calculados y se imprimen"

#: ../../tutorials/04_excited_states_solvers.ipynb:376
msgid "One can see from these results that one state is missing from the NumPy results. The reason for this is because the spin is also used as a filter and only singlet states are shown. In the following we use a custom filter function to check consistently our results and only filter out states with incorrect number of particle (in this case the number of particle is 2)."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:9
msgid "Sampling the potential energy surface"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:23
msgid "This interactive notebook demonstrates how to utilize the Potential Energy Surface (PES) samplers algorithm of qiskit chemistry to generate the dissociation profile of a molecule. We use the Born-Oppenhemier Potential Energy Surface (BOPES)and demonstrate how to exploit bootstrapping and extrapolation to reduce the total number of function evaluations in computing the PES using the Variational Quantum Eigensolver (VQE)."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:69
msgid "Here, we use the H2 molecule as a model system for testing."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:127
msgid "Make a perturbation to the molecule along the absolute_stretching dof"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:174
msgid "Calculate bond dissociation profile using BOPES Sampler"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:176
msgid "Here, we pass the molecular information and the VQE to a built-in type called the BOPES Sampler. The BOPES Sampler allows the computation of the potential energy surface for a specified set of degrees of freedom/points of interest."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:188
msgid "First we compare no bootstrapping vs bootstrapping"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:190
msgid "Bootstrapping the BOPES sampler involves utilizing the optimal variational parameters for a given degree of freedom, say r (ex. interatomic distance) as the initial point for VQE at a later degree of freedom, say r + :math:`\\epsilon`. By default, if boostrapping is set to True, all previous optimal parameters are used as initial points for the next runs."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:258
msgid "Compare to classical eigensolver"
msgstr "Comparar con un eigensolucionador clásico"

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:292
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:494
msgid "Plot results"
msgstr "Graficar resultados"

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:350
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:577
msgid "Compare number of evaluations"
msgstr "Comparar número de evaluaciones"

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:416
msgid "Extrapolation"
msgstr "Extrapolación"

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:418
msgid "Here, an extrapolator added that will try to fit each (param,point) set to some specified function and suggest an initial parameter set for the next point (degree of freedom)."
msgstr "Aquí, un extrapolador añadido que intentará ajustar cada conjunto (param,point) a alguna función especificada y sugerir un conjunto de parámetros iniciales para el siguiente punto (grado de libertad)."

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:420
msgid "Extrapolator is based on an external extrapolator that sets the ‘window’, that is, the number of previous points to use for extrapolation, while the internal extrapolator proceeds with the actual extrapolation."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:421
msgid "In practice, the user sets the window by specifying an integer value to num_bootstrap - which is also the number of previous points to use for bootstrapping. Additionally, the external extrapolator defines the space within how to extrapolate - here PCA, clustering and the standard window approach."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:423
msgid "In practice, if no extrapolator is defined and bootstrapping is True, then all previous points will be bootstrapped. If an extrapolator list is defined and no points are specified for bootstrapping, then the extrapolation will be done based on all previous points."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:434
msgid "Window Extrapolator: An extrapolator which wraps another extrapolator, limiting the internal extrapolator’s ground truth parameter set to a fixed window size"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:435
msgid "PCA Extrapolator: A wrapper extrapolator which reduces the points’ dimensionality with PCA, performs extrapolation in the transformed pca space, and untransforms the results before returning."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:436
msgid "Sieve Extrapolator: A wrapper extrapolator which performs an extrapolation, then clusters the extrapolated parameter values into two large and small clusters, and sets the small clusters’ parameters to zero."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:437
msgid "Polynomial Extrapolator: An extrapolator based on fitting each parameter to a polynomial function of a user-specified degree."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:438
msgid "Differential Extrapolator: An extrapolator based on treating each param set as a point in space, and performing regression to predict the param set for the next point. A user-specified degree also adds derivatives to the values in the point vectors which serve as features in the training data for the linear regression."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:450
msgid "Here we test two different extrapolation techniques"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:9
msgid "Calculating Thermodynamics Observables with a quantum computer"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:53
msgid "A preliminary draft with more information related to this tutorial can be found in preprint: Stober et al, arXiv 2003.02303 (2020)"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:65
msgid "Calculation of the Born Oppenheimer Potential Energy Surface (BOPES)"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:76
msgid "To compute thermodynamic observables we begin with single point energy calculation which calculates the wavefunction and charge density and therefore the energy of a particular arrangement of nuclei. Here we compute the Born-Oppenheimer potential energy surface of a hydrogen molecule, as an example, which is simply the electronic energy as a function of bond length."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:253
msgid "Calculation of the molecular Vibrational Energy levels"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:265
msgid "The Born-Oppeheimer approximation removes internuclear vibrations from the molecular Hamiltonian and the energy computed from quantum mechanical ground-state energy calculations using this approximation contain only the electronic energy. Since even at absolute zero internuclear vibrations still occur, a correction is required to obtain the true zero-temperature energy of a molecule. This correction is called the zero-point vibrational energy (ZPE), which is computed by summing the contribution from internuclear vibrational modes. Therefore, the next step in computing thermodynamic observables is determining the vibrational energy levels. This can be done by constructing the Hessian matrix based on computed single point energies close to the equilibrium bond length. The eigenvalues of the Hessian matrix can then be used to determine the vibrational energy levels and the zero-point vibrational energy"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:268
msgid ":nbsphinx-math:`\\begin{equation} {\\rm ZPE} = \\frac{1}{2}\\, \\sum_i ^M \\nu_i \\, , \\end{equation}` with :math:`\\nu_i` being the vibrational frequencies, :math:`M = 3N − 6` or :math:`M = 3N − 5` for non-linear or linear molecules, respectively, and :math:`N` is number of the particles."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:279
msgid "Here we fit a “full” energy surface using a 1D spline potential and use it to evaluate molecular vibrational energy levels."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:326
msgid "Create a partition function for the calculation of heat capacity"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:337
msgid "The partition function for a molecule is the product of contributions from translational, rotational, vibrational, electronic, and nuclear degrees of freedom. Having the vibrational frequencies, now we can obtain the vibrational partition function :math:`q_{\\rm vibration}` to compute the whole molecular partition function :nbsphinx-math:`\\begin{equation} q_{\\rm vibration} = \\prod_{i=1} ^M \\frac{\\exp\\,(-\\Theta_{\\nu_i}/2T)}{1-\\exp\\,(-\\Theta_{\\nu_i}/2T} \\, . \\end{equation}` Here :math:`\\Theta_{\\nu_i}= h\\nu_i/k_B`, :math:`T` is the temperature and :math:`k_B` is the Boltzmann constant."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:341
msgid "The single-point energy calculations and the resulting partition function can be used to calculate the (constant volume or constant pressure) heat capacity of the molecules. The constant volume heat capacity, for example, is given by"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:343
msgid ":nbsphinx-math:`\\begin{equation} C_v = \\left.\\frac{\\partial U}{\\partial T}\\right|_{N,V}\\, , \\qquad {\\rm with} \\quad U=k_B T^2 \\left.\\frac{\\partial {\\rm ln} Q}{\\partial T}\\right|_{N,V} . \\end{equation}`"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:350
msgid ":math:`U` is the internal energy, :math:`V` is the volume and :math:`Q` is the partition function."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:361
msgid "Here we illustrate the simplest usage of the partition function, namely creating a Thermodynamics object to compute properties like the constant pressure heat capacity defined above."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:410
msgid "Here we demonstrate how to access particular components (the rotational part) of the partition function, which in the H2 case we can further split to para-hydrogen and ortho-hydrogen components."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:433
msgid "We will now plot the constant volume heat capacity (of the rotational part) demonstrating how we can call directly the functions in the ‘thermodynamics’ module, providing a callable object for the partition function (or in this case its rotational component). Note that in the plot we normalize the plot dividing by the universal gas constant R (Avogadro’s number times Boltzman’s constant) and we use crossed to compare with experimental data found in literature."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:9
msgid "Leveraging Qiskit Runtime"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:20
msgid "Iterative algorithms, such as the Variational Quantum Eigensolver (VQE), traditionally send one batch of circuits (one “job”) to be executed on the quantum device in each iteration. Sending a job involves certain overhead, mainly"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:22
msgid "the time to process the requests and send the data (API overhead, usually about 10s)"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:23
msgid "the job queue time, that is how long you have to wait before it’s your turn to run on the device (usually about 2min)"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:25
msgid "If we send hundreds of jobs iteratively, this overhead quickly dominates the execution time of our algorithm. Qiskit Runtime allows us to tackle these issues and significantly speed up (especially) iterative algorithms. With Qiskit Runtime, one job does not contain only a batch of circuits but the *entire* algorithm. That means we only experience the API overhead and queue wait *once* instead of in every iteration! You’ll be able to either upload algorithm parameters and delegate all the complexity to the cloud, where your program is executed, or upload your personal algorithm directly."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:28
msgid "For the VQE, the integration of Qiskit Runtime in your existing code is a piece of cake. There is a (almost) drop-in replacement, called ``VQEProgram`` for the ``VQE`` class."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:30
msgid "Let’s see how you can leverage the runtime on a simple chemistry example: Finding the ground state energy of the lithium hydrate (LiH) molecule at a given bond distance."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:42
msgid "Problem specification: LiH molecule"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:44
msgid "First, we specify the molecule whose ground state energy we seek. Here, we look at LiH with a bond distance of 2.5 Å."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:101
msgid "Classical reference solution"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:112
msgid "As a reference solution we can solve this system classically with the ``NumPyEigensolver``."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:171
msgid "VQE"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:173
msgid "To run the VQE we need to select a parameterized quantum circuit acting as ansatz and a classical optimizer. Here we’ll choose a heuristic, hardware efficient ansatz and the SPSA optimizer."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:221
msgid "Before executing the VQE in the cloud using Qiskit Runtime, let’s execute a local VQE first."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:302
msgid "Runtime VQE"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:304
msgid "Let’s exchange the eigensolver from a local VQE algorithm to a VQE executed using Qiskit Runtime – simply by exchanging the ``VQE`` class by the ``VQEProgram``."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:306
msgid "First, we’ll have to load a provider to access Qiskit Runtime. **Note:** You have to replace the next cell with your provider."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:332
msgid "Now we can set up the ``VQEProgram``. In this first release, the optimizer must be provided as a dictionary, in future releasess you’ll be able to pass the same optimizer object as in the traditional VQE."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:409
msgid "If we are interested in the development of the energy, the ``VQEProgram`` allows access to the history of the optimizer, which contains the loss per iteration (along with the parameters and a timestamp). We can access this data via the ``raw_result`` attribute of the ground state solver."
msgstr ""

#: ../../tutorials/index.rst:3
msgid "Qiskit Nature Tutorials"
msgstr ""


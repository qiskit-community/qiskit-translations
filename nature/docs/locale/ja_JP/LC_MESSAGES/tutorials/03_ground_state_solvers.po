msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-03 16:57+0000\n"
"PO-Revision-Date: 2023-03-09 05:33\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /master/nature/docs/locale/en/LC_MESSAGES/tutorials/03_ground_state_solvers.po\n"
"X-Crowdin-File-ID: 9670\n"

#: ../../tutorials/03_ground_state_solvers.ipynb:9
msgid "This page was generated from `docs/tutorials/03_ground_state_solvers.ipynb`__."
msgstr "このページは `docs/tutorials/03_ground_state_solvers.ipynb`__ から生成されました。"

#: ../../tutorials/03_ground_state_solvers.ipynb:9
msgid "Ground state solvers"
msgstr "基底状態ソルバー"

#: ../../tutorials/03_ground_state_solvers.ipynb:21
msgid "Introduction"
msgstr "はじめに"

#: ../../tutorials/03_ground_state_solvers.ipynb:23
msgid "|cd136bece125457d8a9cfe7197b87e9a|"
msgstr "|cd136bece125457d8a9cfe7197b87e9a|"

#: ../../tutorials/03_ground_state_solvers.ipynb:31
msgid "cd136bece125457d8a9cfe7197b87e9a"
msgstr "cd136bece125457d8a9cfe7197b87e9a"

#: ../../tutorials/03_ground_state_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the ground state calculation interface of Qiskit Nature. The goal is to compute the ground state of a molecular Hamiltonian. This Hamiltonian can for example be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the `Electronic structure <01_electronic_structure.ipynb>`__ and `Vibrational structure tutorials <02_vibrational_structure.ipynb>`__."
msgstr "このチュートリアルでは、Qiskit Natureの基底状態計算インターフェースについて説明します。 目的は分子ハミルトニアンの基底状態を計算することです。 このハミルトニアンは、例えば電子的あるいは振動的なものである可能性があります。 ハミルトニアンの準備についての詳細は、 `電子構造 <01_electronic_structure.ipynb>`__ と `振動構造のチュートリアル <02_vibrational_structure.ipynb>`__ を参照してください。"

#: ../../tutorials/03_ground_state_solvers.ipynb:27
msgid "It should be said, that in the electronic case, we are actually computing purely the **electronic** part. When using the Qiskit Nature stack as presented in this tutorial, the *nuclear repulsion energy* will be added automatically, to obtain the **total** ground state energy."
msgstr "電子的なケースでは、実際には純粋に**電子的**な部分を計算している、と言うべきでしょう。このチュートリアルで紹介するQiskit Natureスタックを使用する場合、**核反発エネルギー*が自動的に追加され、**トータル** の基底状態エネルギーが得られます。"

#: ../../tutorials/03_ground_state_solvers.ipynb:29
msgid "The first step is to define the molecular system. In the following we ask for the electronic part of a hydrogen molecule."
msgstr "まず分子系の定義から始めます。以下では、水素分子の電子部分を求めています。"

#: ../../tutorials/03_ground_state_solvers.ipynb:63
msgid "We will also be sticking to the Jordan-Wigner mapping. To learn more about the various mappers available in Qiskit Nature, check out the `Qubit Mappers tutorial <06_qubit_mappers.ipynb>`__."
msgstr "また、Jordan-Wignerマッピングを使う予定です。Qiskit Natureで利用できる様々なマッパーについてもっと知りたい方は、`量子ビット空間への変換 <06_qubit_mappers.ipynb>`__ をチェックしてください。"

#: ../../tutorials/03_ground_state_solvers.ipynb:87
msgid "The Solver"
msgstr "ソルバー"

#: ../../tutorials/03_ground_state_solvers.ipynb:89
msgid "After these steps, we need to define a solver. The solver is the algorithm through which the ground state is computed."
msgstr "次に、ソルバーを定義する必要があります。ソルバーとは、基底状態を求めるアルゴリズムのことです。"

#: ../../tutorials/03_ground_state_solvers.ipynb:91
msgid "Let’s first start with a purely classical example: the ``NumPyMinimumEigensolver``. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms."
msgstr "まず、純粋に古典的な ``NumPyMinimumEigensolver`` の例から始めましょう。このアルゴリズムは、ハミルトニアンを正確に対角化します。これは規模の大きな問題には適用できませんが、小さな系で量子アルゴリズムの結果を確認するために用いることができます。"

#: ../../tutorials/03_ground_state_solvers.ipynb:114
msgid "To find the ground state we could also use the Variational Quantum Eigensolver (VQE) algorithm. The VQE algorithm works by exchanging information between a classical and a quantum computer as depicted in the following figure."
msgstr "基底状態を見つけるために、変分量子固有ソルバー (VQE) アルゴリズムを用いることもできます。 VQE アルゴリズムは次の図に示すように、古典コンピューターと量子コンピューターの間で情報を交換することによって動作します。"

#: ../../tutorials/03_ground_state_solvers.ipynb:116
msgid "|47fba32128284d15a08de6531f7ce35e|"
msgstr "|47fba32128284d15a08de6531f7ce35e|"

#: ../../tutorials/03_ground_state_solvers.ipynb:120
msgid "47fba32128284d15a08de6531f7ce35e"
msgstr "47fba32128284d15a08de6531f7ce35e"

#: ../../tutorials/03_ground_state_solvers.ipynb:118
msgid "Let’s initialize a VQE solver."
msgstr "VQE ソルバーを初期化しましょう。"

#: ../../tutorials/03_ground_state_solvers.ipynb:146
msgid "To define the VQE solver one needs three essential elements:"
msgstr "VQE ソルバーを定義するには、3つの重要な要素が必要です。"

#: ../../tutorials/03_ground_state_solvers.ipynb:148
msgid "An Estimator primitive: these were released as part of Qiskit Terra 0.22. To learn more about primitives, check out `this resource <https://qiskit.org/documentation/apidoc/primitives.html>`__."
msgstr "Estimator primitive: これらはQiskit Terra 0.22の一部としてリリースされました。Primitiveについてもっと知りたい方は、`このリソース <https://qiskit.org/documentation/apidoc/primitives.html>`__ をチェックしてください。"

#: ../../tutorials/03_ground_state_solvers.ipynb:149
msgid "A variational form: here we use the Unitary Coupled Cluster (UCC) ansatz (see for instance [Physical Review A 98.2 (2018): 022322]). Since it is a chemistry standard, a factory is already available allowing a fast initialization of a VQE with UCC. The default is to use all single and double excitations. However, the excitation type (S, D, SD) as well as other parameters can be selected. Since we are using the ``VQEUCCFactory``, this will also prepend the ``UCCSD`` variational form with a ``HartreeFock`` initial state, which initializes the occupation of our qubits according to the problem which we are trying solve."
msgstr "変分形式：ここでは、Unitary Coupled Cluster (UCC) ansatzを使用します (例えば、[Physical Review A 98.2 (2018): 022322] を参照してください)。化学の標準であるため、UCCを用いたVQEの高速な初期化を可能にするファクトリーが既に利用可能です。デフォルトでは、すべての単励起と二重励起を使用します。ただし、励起タイプ (S, D, SD) や他のパラメーターを選択することができます。 ``VQEUCCFactory`` を使用しているので、 ``UCCSD`` 変分形式と ``HartreeFock`` 初期状態が付加され、解決しようとする問題に応じて量子ビットの占有率が初期化されます。"

#: ../../tutorials/03_ground_state_solvers.ipynb:151
msgid "An optimizer: this is the classical piece of code in charge of optimizing the parameters in our variational form. See `the corresponding documentation of Qiskit Terra <https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html>`__ for more information."
msgstr "オプティマイザー: これは変分形式のパラメーターを最適化する古典的なコードです。詳細は `Qiskit Terraの関連ドキュメント <https://qiskit.org/documentation/stubs/qiskit.algorithms.optimizers.html>`__ を参照してください。"

#: ../../tutorials/03_ground_state_solvers.ipynb:153
msgid "One could also use any available ansatz / initial state or even define one’s own. For instance,"
msgstr "また、任意の利用可能なansatz / 初期状態を使用することもできますし、独自に定義することも可能です。以下にその例を示します。"

#: ../../tutorials/03_ground_state_solvers.ipynb:186
msgid "The calculation and results"
msgstr "計算と結果"

#: ../../tutorials/03_ground_state_solvers.ipynb:188
msgid "We are now ready to put everything together to compute the ground-state of our problem. Doing so requires us to wrap our ``QubitConverter`` and quantum algorithm into a single ``GroundStateEigensolver`` like so:"
msgstr "これで、問題の基底状態を計算するために、すべてをまとめる準備ができました。 ``QubitConverter`` と量子アルゴリズムを一つの ``GroundStateEigensolver`` にラップする必要があります。"

#: ../../tutorials/03_ground_state_solvers.ipynb:211
msgid "This will now take of the entire workflow: 1. generating the second-quantized operators stored in our ``problem`` 2. mapping (and potentially reducing) the operators in the qubit space 3. if we provided a quantum algorithm factory (e.g. ``VQEUCCFactory``): finalizing its setup based on the ``problem`` 4. running the quantum algorithm on the Hamiltonian qubit operator 5. once converged, evaluating the additional observables at the determined ground state"
msgstr "これで、ワークフロー全体を見ることができます。1. ``problem`` に格納されている第二量子化された演算子を生成します。 2. 演算子を量子ビット空間にマッピング (縮小の可能性もある) します。 3. 量子アルゴリズムファクトリー (例： ``VQEUCCFactory``) を提供した場合、 ``problem`` に基づいてその設定を確定します。 4. ハミルトニアン量子ビット演算子で量子アルゴリズムを実行します。5. 収束したら、決定した基底状態での追加の観測量を評価します。"

#: ../../tutorials/03_ground_state_solvers.ipynb:317
msgid "We can compare the VQE results to the NumPy exact solver and see that they match."
msgstr "NumPy の正確なソルバーと比較して、VQE の結果が一致していることを確認できます。"

#: ../../tutorials/03_ground_state_solvers.ipynb:425
msgid "Using a filter function"
msgstr "フィルター関数の使用"

#: ../../tutorials/03_ground_state_solvers.ipynb:436
msgid "Sometimes the true ground state of the Hamiltonian is not of interest because it lies in a different symmetry sector of the Hilbert space. In this case the ``NumPyEigensolver`` can take a filter function to return only the eigenstates with for example the correct number of particles. This is of particular importance in the case of vibrational structure calculations where the true ground state of the Hamiltonian is the vacuum state. A default filter function to check the number of particles is implemented in the different problems and can be used as follows:"
msgstr "ハミルトニアンの真の基底状態がヒルベルト空間の異なる対称性領域にあるため、そうした解に興味がないという場合もあります。こうした場合に ``NumPyEigensolver`` は、フィルター関数を取って、正しい粒子数をもつ固有状態だけを返すようにすることが可能です。これは特に、ハミルトニアンの真の基底状態が真空状態となる、振動構造計算の場合に重要です。粒子数をチェックするためのデフォルトのフィルター関数は、様々な問題に実装されており、以下のように用いることができます。"


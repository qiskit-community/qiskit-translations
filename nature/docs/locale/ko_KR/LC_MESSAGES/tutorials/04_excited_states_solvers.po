msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-21 20:02+0000\n"
"PO-Revision-Date: 2021-07-23 21:16\n"
"Last-Translator: \n"
"Language-Team: Korean\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ko\n"
"X-Crowdin-File: /master/nature/docs/locale/en/LC_MESSAGES/tutorials/04_excited_states_solvers.po\n"
"X-Crowdin-File-ID: 9672\n"
"Language: ko_KR\n"

#: ../../tutorials/04_excited_states_solvers.ipynb:9
msgid "This page was generated from `docs/tutorials/04_excited_states_solvers.ipynb`__."
msgstr "이 페이지는 `docs/tutorials/04_excited_states_solvers.ipynb`__ 에서 생성되었다."

#: ../../tutorials/04_excited_states_solvers.ipynb:9
msgid "Excited states solvers"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:21
msgid "Introduction"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:23
msgid "|02c6f0d1b03e48a6b73bc807fee71283|"
msgstr "|02c6f0d1b03e48a6b73bc807fee71283|"

#: ../../tutorials/04_excited_states_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the excited states calculation interface of Qiskit Chemistry. The goal is to compute the excited states of a molecular Hamiltonian. This Hamiltonian can be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the Electronic structure and Vibrational structure tutorials."
msgstr "본 튜토리얼에서는 Qiskit Chemistry의 여기 상태 계산 인터페이스에 대해 설명한다. 목표는 분자 해밀턴의 여기 상태를 계산하는 것이다. 이 해밀턴은 전자적이거나 진동적일 수 있다. 해밀턴의 준비에 대해서 더 알고 싶으시면, 전자구조와 진동 구조 튜토리얼을 확인해보자."

#: ../../tutorials/04_excited_states_solvers.ipynb:27
msgid "The first step is to define the molecular system. In the following we ask for the electronic part of a hydrogen molecule."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:62
msgid "The Solver"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:64
msgid "Then we need to define a solver. The solver is the algorithm through which the ground state is computed."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:66
msgid "Let’s first start with a purely classical example: the NumPy eigensolver. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms. Here, we are only interested to look at eigenstates with a given number of particle. To compute only those states a filter function can be passed to the NumPy eigensolver. A default filter function is already implemented in Qiskit and can be used in this way:"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:89
msgid "The excitation energies can also be accessed with the qEOM algorithm [arXiv preprint arXiv:1910.12890 (2019)]. The EOM method finds the excitation energies (differences in energy between the ground state and all :math:`n`\\ th excited states) by solving the following pseudo-eigenvalue problem."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:91
msgid "\\begin{pmatrix}\n"
"    \\text{M} & \\text{Q}\\\\\n"
"    \\text{Q*} & \\text{M*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}\n"
"= E_{0n}\n"
"\\begin{pmatrix}\n"
"    \\text{V} & \\text{W}\\\\\n"
"    -\\text{W*} & -\\text{V*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:112
msgid "with"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:114
msgid "M_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger},\\hat{\\text{H}}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:119
msgid "Q_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{H}}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:124
msgid "V_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:129
msgid "W_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_\\alpha}^{(\\alpha)})^{\\dagger}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr "W_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_\\alpha}^{(\\alpha)})^{\\dagger}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"

#: ../../tutorials/04_excited_states_solvers.ipynb:134
msgid "Although the previous equation can be solved classically, each matrix element must be measured on the quantum computer with the corresponding ground state. To use the qEOM as a solver in Qiskit, we have to define a ground state calculation first, providing to the algorithm information on how to find the ground state. With this the qEOM solver can be initialized:"
msgstr "이전의 방정식이 고전적으로 해결될 수 있지만, 각 행렬 요소는 바닥 상태에 대응되는 양자 컴퓨터에서 측정되어야 한다. qEOM을 Qiskit에서 solver로 사용하려면 바닥 상태 계산을 정의하여 바닥 상태를 찾는 방법에 대한 알고리즘 정보를 제공해야 한다. 이를 통해 qEOM solver를 초기화할 수 있다."

#: ../../tutorials/04_excited_states_solvers.ipynb:167
msgid "The calculation and results"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:169
msgid "The results are computed and printed"
msgstr "결과가 계산되고 출력된다."

#: ../../tutorials/04_excited_states_solvers.ipynb:376
msgid "One can see from these results that one state is missing from the NumPy results. The reason for this is because the spin is also used as a filter and only singlet states are shown. In the following we use a custom filter function to check consistently our results and only filter out states with incorrect number of particle (in this case the number of particle is 2)."
msgstr ""


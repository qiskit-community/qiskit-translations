msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-07-12 21:08+0000\n"
"PO-Revision-Date: 2021-07-12 22:03\n"
"Last-Translator: \n"
"Language-Team: Malayalam\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ml-IN\n"
"X-Crowdin-File: /master/nature/docs/locale/en/LC_MESSAGES/tutorials.po\n"
"X-Crowdin-File-ID: 9570\n"
"Language: ml_IN\n"

#: ../../tutorials/01_electronic_structure.ipynb:13
#: ../../tutorials/02_vibrational_structure.ipynb:13
#: ../../tutorials/03_ground_state_solvers.ipynb:13
#: ../../tutorials/04_excited_states_solvers.ipynb:13
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:13
#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:13
#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:13
msgid "Run interactively in jupyter notebook."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:9
msgid "Electronic structure"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:21
#: ../../tutorials/02_vibrational_structure.ipynb:21
#: ../../tutorials/03_ground_state_solvers.ipynb:21
#: ../../tutorials/04_excited_states_solvers.ipynb:21
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:21
msgid "Introduction"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:23
#: ../../tutorials/02_vibrational_structure.ipynb:23
msgid "The molecular Hamiltonian is"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:25
#: ../../tutorials/02_vibrational_structure.ipynb:25
msgid "\\mathcal{H} = - \\sum_I \\frac{\\nabla_{R_I}^2}{M_I} - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|} + \\sum_I\\sum_{J>I} \\frac{Z_I Z_J e^2}{|R_I-R_J|}"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:30
#: ../../tutorials/02_vibrational_structure.ipynb:30
msgid "Because the nuclei are much heavier than the electrons they do not move on the same time scale and therefore, the behavior of nuclei and electrons can be decoupled. This is the Born-Oppenheimer approximation."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:32
msgid "Therefore, one can first tackle the electronic problem with nuclear coordinate entering only as parameters. The energy levels of the electrons in the molecule can be found by solving the non-relativistic time independent Schroedinger equation,"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:34
msgid "\\mathcal{H}_{\\text{el}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:39
msgid "where"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:41
msgid "\\mathcal{H}_{\\text{el}} = - \\sum_i \\frac{\\nabla_{r_i}^2}{m_e} - \\sum_I\\sum_i  \\frac{Z_I e^2}{|R_I-r_i|} + \\sum_i \\sum_{j>i} \\frac{e^2}{|r_i-r_j|}."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:46
msgid "In particular the ground state energy is given by:"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:48
msgid "E_0 = \\frac{\\langle \\Psi_0 | H_{\\text{el}} | \\Psi_0 \\rangle}{\\langle \\Psi_0 | \\Psi_0 \\rangle}"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:53
msgid "where :math:`\\Psi_0` is the ground state of the system."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:55
msgid "However, the dimensionality of this problem grows exponentially with the number of degrees of freedom. To tackle this issue we would like to prepare :math:`\\Psi_0` on a quantum computer and measure the Hamiltonian expectation value (or :math:`E_0`) directly."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:57
msgid "So how do we do that concretely?"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:69
msgid "The Hartree-Fock initial state"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:71
msgid "A good starting point for solving this problem is the Hartree-Fock (HF) method. This method approximates a N-body problem into N one-body problems where each electron evolves in the mean-field of the others. Classically solving the HF equations is efficient and leads to the exact exchange energy but does not include any electron correlation. Therefore, it is usually a good starting point to start adding correlation."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:73
msgid "The Hamiltonian can then be re-expressed in the basis of the solutions of the HF method, also called Molecular Orbitals (MOs):"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:75
msgid "\\hat{H}_{elec}=\\sum_{pq} h_{pq} \\hat{a}^{\\dagger}_p \\hat{a}_q +\n"
"\\frac{1}{2} \\sum_{pqrs} h_{pqrs}  \\hat{a}^{\\dagger}_p \\hat{a}^{\\dagger}_q \\hat{a}_r  \\hat{a}_s"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:81
msgid "with the 1-body integrals"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:83
msgid "h_{pq} = \\int \\phi^*_p(r) \\left( -\\frac{1}{2} \\nabla^2 - \\sum_{I} \\frac{Z_I}{R_I- r} \\right)   \\phi_q(r)"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:88
msgid "and 2-body integrals"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:90
msgid "h_{pqrs} = \\int \\frac{\\phi^*_p(r_1)  \\phi^*_q(r_2) \\phi_r(r_2)  \\phi_s(r_1)}{|r_1-r_2|}."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:95
msgid "The MOs (:math:`\\phi_u`) can be occupied or virtual (unoccupied). One MO can contain 2 electrons. However, in what follows we actually work with Spin Orbitals which are associated with a spin up (:math:`\\alpha`) of spin down (:math:`\\beta`) electron. Thus Spin Orbitals can contain one electron or be unoccupied."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:97
msgid "We now show how to concretely realise these steps with Qiskit."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:108
msgid "Qiskit is interfaced with different classical codes which are able to find the HF solutions. Interfacing between Qiskit and the following codes is already available: \\* Gaussian \\* Psi4 \\* PyQuante \\* PySCF"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:110
msgid "In the following we set up a PySCF driver, for the hydrogen molecule at equilibrium bond length (0.735 angstrom) in the singlet state and with no charge."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:135
msgid "For further information about the drivers see https://qiskit.org/documentation/nature/apidocs/qiskit_nature.drivers.html"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:147
msgid "The mapping from fermions to qubits"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:149
msgid "|0ad8624f075a48508e80bebabad36807|"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:151
msgid "The Hamiltonian given in the previous section is expressed in terms of fermionic operators. To encode the problem into the state of a quantum computer, these operators must be mapped to spin operators (indeed the qubits follow spin statistics)."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:153
msgid "There exist different mapping types with different properties. Qiskit already supports the following mappings: \\* The Jordan-Wigner ‘jordan_wigner’ mapping (über das paulische äquivalenzverbot. In The Collected Works of Eugene Paul Wigner (pp. 109-129). Springer, Berlin, Heidelberg (1993)). \\* The Parity ‘parity’ (The Journal of chemical physics, 137(22), 224109 (2012)) \\* The Bravyi-Kitaev ‘bravyi_kitaev’ (Annals of Physics, 298(1), 210-226 (2002))"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:155
msgid "The Jordan-Wigner mapping is particularly interesting as it maps each Spin Orbital to a qubit (as shown on the Figure above)."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:157
msgid "Here we set up the Electronic Structure Problem to generate the Second quantized operator and a qubit converter that will map it to a qubit operator."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:239
msgid "If we now transform this Hamiltonian for the given driver defined above we get our qubit operator:"
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:309
msgid "In the minimal (STO-3G) basis set 4 qubits are required. We can reduce the number of qubits by using the Parity mapping, which allows for the removal of 2 qubits by exploiting known symmetries arising from the mapping."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:359
msgid "This time only 2 qubits are needed."
msgstr ""

#: ../../tutorials/01_electronic_structure.ipynb:370
msgid "Now that the Hamiltonian is ready, it can be used in a quantum algorithm to find information about the electronic structure of the corresponding molecule. Check out our tutorials on Ground State Calculation and Excited States Calculation to learn more about how to do that in Qiskit!"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:9
msgid "Vibrational structure"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:32
msgid "Within the Born-Oppenheimer approximation, a molecular wave function is factorized as a product of an electronic part, which is the solution of the electronic Schroedinger equation, and a vibro-rotational one, which is the solution of the nuclear Schroedinger equation in the potential energy surface (PES) generated by sampling the eigenvalues of the electronic Schroedinger equation for different geometries."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:34
msgid "The nuclear Schroedinger equation is usually solved in two steps, in analogy with its electronic counterpart. A single-particle basis (the basis functions are called, in this case, modals) is obtained either by the harmonic approximation applied to the PES or from a vibrational self-consistent field (VSCF) calculation. Vibrational anharmonic correlations are added a-posteriori with perturbative or variational approaches. The latter include Vibrational Configuration Interaction (VCI) and Vibrational Coupled Cluster (VCC) for highly-accurate anharmonic energies. The main advantage of VCI and VCC over alternative approaches (such as perturbation theories) is that their accuracy can be systematically improved towards the complete basis set limit for a given PES. However, their applicability is limited to small molecules with up to about 10 atoms due to their unfavorable scaling with system size."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:37
msgid "To tackle the scaling problem we would like to use quantum algorithms."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:39
msgid "The nuclear Schroedinger equation is"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:41
msgid "\\mathcal{H}_{\\text{vib}} |\\Psi_{n}\\rangle = E_{n} |\\Psi_{n}\\rangle"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:46
msgid "The so-called Watson Hamiltonian (neglecting vibro-rotational coupling terms) is"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:48
msgid "\\mathcal{H}_\\text{vib}(Q_1, \\ldots, Q_L)\n"
"  = - \\frac{1}{2} \\sum_{l=1}^{L} \\frac{\\partial^2}{\\partial Q_l^2} + V(Q_1, \\ldots, Q_L)"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:54
msgid "where :math:`Q_l` are the harmonic mass-weighted normal coordinates."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:56
msgid ":math:`\\mathcal{H}_\\text{vib}` must be mapped to an operator that acts on the states of a given set of :math:`N_q` qubits in order to calculate its eigenfunctions on quantum hardware. In electronic structure calculations, the mapping is achieved by expressing the non-relativistic electronic Hamiltonian in second quantization, :nbsphinx-math:`\\textit{i.e.}` by projecting it onto the complete set of antisymmetrized occupation number vectors (ONV) generated by a given (finite) set of orbitals. To encode the vibrational Hamiltonian in an analogous second quantization operators, we expand the potential :math:`V(Q_1, \\ldots, Q_L)` with the :math:`n`-body expansion as follows:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:59
msgid "V(Q_1, \\ldots, Q_L) = V_0 + \\sum_{l=1}^L V^{[l]}(Q_l)\n"
"  + \\sum_{l<m}^L V^{[l,m]}(Q_l, Q_m) + \\sum_{l<m<n}^L V^{[l,m,n]}(Q_l, Q_m, Q_n) + \\ldots"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:65
msgid "where :math:`V_0` is the electronic energy of the reference geometry, the one-mode term :math:`V^{[l]}(Q_l)` represents the variation of the PES upon change of the :math:`l`-th normal coordinate from the equilibrium position. Similarly, the two-body potential :math:`V^{[l,m]}(Q_l, Q_m)` represents the change in the exact PES upon a simultaneous displacement along the :math:`l`-th and :math:`m`-th coordinates. Often, including terms up to three-body in the :math:`L`-body expansion is sufficient to obtain an accuracy of about 1~cm\\ :math:`^{-1}`. We highlight that the many-body expansion of the potential operator defining the Watson Hamiltonian contains arbitrarily high coupling terms. This is a crucial difference compared to the non-relativistic electronic-structure Hamiltonian that contains only pairwise interactions."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:68
msgid "A flexible second quantization form of the Watson Hamiltonian is obtained within the so-called n-mode representation. Let us assume that each mode :math:`l` is described by a :math:`N_l`-dimensional basis set :math:`S_l` defined as follows:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:70
msgid "\\mathcal{S}_l = \\{ \\phi_1^{(l)} (Q_l) , \\ldots , \\phi_{N_l}^{(l)} (Q_l) \\} \\, ."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:75
msgid "The :math:`n`-mode wave function can be expanded in the product basis :math:`\\mathcal{S} = \\otimes_{i=1}^L \\mathcal{S}_i` as the following CI-like expansion:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:77
msgid "|\\Psi\\rangle = \\sum_{k_1=1}^{N_1} \\cdots \\sum_{k_L=1}^{N_L} C_{k_1,\\ldots,k_L}\n"
"  \\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L) \\, ,"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:83
msgid "The many-body basis function :math:`\\phi_{k_1}^{(1)}(Q_1) \\cdots \\phi_{k_L}^{(L)}(Q_L)` are encoded within the so-called :math:`n`-mode second quantization as occupation-number vectors (ONVs) as follows:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:85
msgid "\\phi_{k_1}(Q_1) \\cdots \\phi_{k_L}(Q_L)\n"
"                    \\equiv  |0_1 \\cdots 1_{k_1} \\cdots 0_{N_1},\n"
"                                 0_1 \\cdots 1_{k_2} \\cdots 0_{N_2},\n"
"                                 \\cdots ,\n"
"                                 0_1 \\cdots 1_{k_L} \\cdots 0_{N_L}\\rangle \\, ."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:94
msgid "The ONV defined above is, therefore, the product of :math:`L` mode-specific ONVs, each one describing an individual mode. Since each mode is described by one and only one basis function, the occupation of each mode-specific ONV is one. From a theoretical perspective, each mode can be interpreted as a distinguishable quasi-particle (defined as phonons in solid-state physics). Distinguishability arises from the fact that the PES is not invariant by permutation of two modes, also in this case unlike the Coulomb interaction between two equal particles. From this perspective, a molecule can be interpreted as a collection of :math:`L` indistinguishable particles that interact through the PES operator."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:97
msgid "Based on this second-quantization representation we introduce a pair of creation and annihilation operators per mode :math:`l` :nbsphinx-math:`\\textit{and}` per basis function :math:`k_l` defined as:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:99
msgid "\\begin{aligned}\n"
"  a_{k_l}^\\dagger |\\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"    &=  | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l}^\\dagger | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 1_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle\n"
"   &= | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle \\\\\n"
"  a_{k_l} | \\cdots, 0_1 \\cdots 0_{k_l} \\cdots 0_{N_l}, \\cdots\\rangle &=  0 \\\\\n"
"\\end{aligned}"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:111
#: ../../tutorials/04_excited_states_solvers.ipynb:112
msgid "with"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:113
msgid "\\begin{aligned}\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m}^\\dagger \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}, a_{h_m} \\right] &= 0 \\\\\n"
"  \\left[ a_{k_l}^\\dagger, a_{h_m} \\right] &= \\delta_{l,m} \\, , \\delta_{k_l,h_m}\n"
"\\end{aligned}"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:122
msgid "The second quantization form is obtained by expressing the potential as"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:124
msgid "\\begin{aligned}\n"
" \\mathcal{H}_\\text{vib}^{SQ} =& \\sum_{l=1}^L\n"
"   \\sum_{k_l,h_l}^{N_l} \\langle \\phi_{k_l} | T(Q_l) + V^{[l]}(Q_l) | \\phi_{h_l} \\rangle a_{k_l}^+ a_{h_l} \\\\\n"
"+& \\sum_{l<m}^L \\sum_{k_l,h_l}^{N_l} \\sum_{k_m,h_m}^{N_m}\n"
"   \\langle \\phi_{k_l} \\phi_{k_m} | V^{[l,m]}(Q_l, Q_m) | \\phi_{h_l} \\phi_{h_m} \\rangle\n"
"   a_{k_l}^+ a_{k_m}^+ a_{h_l} a_{h_m} + \\cdots\n"
"\\end{aligned}"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:135
msgid "We highlight here the difference between the operators defined here above and the electronic structure one. First, as we already mentioned, the potential contains (in principle) three- and higher-body coupling terms that lead to strings with six (or more) second-quantization operators. Moreover, the Hamiltonian conserves the number of particles for each mode, as can be seen from the fact that the number of creation and annihilation operators for a given mode is the same in each term. Nevertheless, different modes are coupled by two- (and higher) body terms containing SQ operators belonging to different modes :math:`l` and :math:`m`."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:138
msgid "Reference: Ollitrault, Pauline J., et al., arXiv:2003.12578 (2020)."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:149
msgid "Compute the electronic potential"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:151
msgid "Solving the ESE for different nuclear configurations to obtain the PES function :math:`V(Q_1, \\ldots, Q_L)`. So far Qiskit gives the possibility to approximate the PES with a quartic force field."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:153
msgid "V(Q_1, \\ldots, Q_L) = \\frac{1}{2}  \\sum_{ij} k_{ij} Q_i Q_j\n"
"                  + \\frac{1}{6}  \\sum_{ijk} k_{ijk} Q_i Q_j Q_k\n"
"                  + \\frac{1}{16} \\sum_{ijkl} k_{ijkl} Q_i Q_j Q_k Q_l"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:160
msgid "The advantage of such form for the PES is that the anharmonic force fields (:math:`k_{ij}`, :math:`k_{ijk}`, :math:`k_{ijkl}`) can be calculated by finite-difference approaches. For methods for which the nuclear energy Hessian can be calculated analytically with response theory-based methods (such as HF and DFT), the quartic force field can be calculated by semi-numerical differentiation as:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:162
msgid "k_{ijk} = \\frac{H_{ij}(+\\delta Q_k) - H_{ij}(-\\delta Q_k)}{2\\delta Q_k}"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:167
msgid "and"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:169
msgid "k_{ijkl} = \\frac{H_{ij}(+\\delta Q_k+\\delta Q_l) - H_{ij}(+\\delta Q_k-\\delta Q_l)\n"
"                    -H_{ij}(-\\delta Q_k+\\delta Q_l) + H_{ij}(-\\delta Q_k+\\delta Q_l)}\n"
"                    {4\\delta Q_k \\delta Q_l}"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:176
msgid "Such numerical procedure is implemented, for instance, in the Gaussian suite of programs."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:178
msgid "In practice this can be done with Qiskit using the GaussianForceDriver."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:215
msgid "Map to a qubit Hamiltonian"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:217
msgid "Now that we have an approximation for the potential, we need to write the Hamiltonian in second quantization. To this end we need to select a modal basis to calculate the one-body integrals :math:`\\langle\\phi_{k_i}| V(Q_i) | \\phi_{h_i} \\rangle`, two-body integrals :math:`\\langle\\phi_{k_i} \\phi_{k_j}| V(Q_i,Q_j) | \\phi_{h_i} \\phi_{h_j} \\rangle`\\ …"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:219
msgid "In the simplest case, the :math:`\\phi` functions are the harmonic-oscillator eigenfunctions for each mode. The main advantage of this choice is that the integrals of a PES expressed as a Taylor expansion are easy to calculate with such basis. A routine for computing these integrals is implemented in Qiskit."
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:221
msgid "The bosonic operator, :math:`\\mathcal{H}_\\text{vib}^{SQ}`, is then created and must be mapped to a qubit operator. The direct mapping introduced in the first section of this tutorial can be used is Qiskit as follows:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:247
msgid "The Vibrational operator for the problem now reads as"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:401
msgid "In the previous cell we defined a bosonic transformation to express the Hamiltonian in the harmonic modal basis, with 2 modals per mode with the potential truncated at order 2 and the ‘direct’ boson to qubit mapping. The calculation is then ran as:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:560
msgid "To have a different number of modals per mode:"
msgstr ""

#: ../../tutorials/02_vibrational_structure.ipynb:1171
msgid "Now that the Hamiltonian is ready, it can be used in a quantum algorithm to find information about the vibrational structure of the corresponding molecule. Check out our tutorials on Ground State Calculation and Excited States Calculation to learn more about how to do that in Qiskit Nature!"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:9
msgid "Ground state solvers"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:23
msgid "|0db35da9e3fc45f1a02635ff70ddf8d1|"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the ground state calculation interface of Qiskit Chemistry. The goal is to compute the ground state of a molecular Hamiltonian. This Hamiltonian can be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the Electronic structure and Vibrational structure tutorials."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:27
#: ../../tutorials/04_excited_states_solvers.ipynb:27
msgid "The first step is to define the molecular system. In the following we ask for the electronic part of a hydrogen molecule."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:63
#: ../../tutorials/04_excited_states_solvers.ipynb:62
msgid "The Solver"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:65
#: ../../tutorials/04_excited_states_solvers.ipynb:64
msgid "Then we need to define a solver. The solver is the algorithm through which the ground state is computed."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:67
msgid "Let’s first start with a purely classical example: the NumPy minimum eigensolver. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:90
msgid "To find the ground state we coul also use the Variational Quantum Eigensolver (VQE) algorithm. The VQE algorithms works by exchanging information between a classical and a quantum computer as depicted in the following figure."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:92
msgid "|bb416182bd064762b7b7bbb9b1e03a44|"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:94
msgid "Let’s initialize a VQE solver."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:123
msgid "To define the VQE solver one needs two essential elements:"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:125
msgid "A variational form: here we use the Unitary Coupled Cluster (UCC) ansatz (see for instance [Physical Review A 98.2 (2018): 022322]). Since it is a chemistry standard, a factory is already available allowing a fast initialization of a VQE with UCC. The default is to use all single and double excitations. However, the excitation type (S, D, SD) as well as other parameters can be selected."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:126
msgid "An initial state: the initial state of the qubits. In the factory used above, the qubits are initialized in the Hartree-Fock (see the electronic structure tutorial) initial state (the qubits corresponding to occupied MOs are :math:`|1\\rangle` and those corresponding to virtual MOs are :math:`|0\\rangle`."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:127
msgid "The backend: this is the quantum machine on which the right part of the figure above will be performed. Here we ask for the perfect quantum emulator (``statevector_simulator``)."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:129
msgid "One could also use any available ansatz / initial state or even define one’s own. For instance,"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:160
#: ../../tutorials/04_excited_states_solvers.ipynb:167
msgid "The calculation and results"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:162
msgid "We are now ready to run the calculation."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:247
msgid "We can compare the VQE results to the NumPy exact solver and see that they match."
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:330
msgid "Using a filter function"
msgstr ""

#: ../../tutorials/03_ground_state_solvers.ipynb:341
msgid "Sometimes the true ground state of the Hamiltonian is not of interest because it lies in a different symmetry sector of the Hilbert space. In this case the NumPy eigensolver can take a filter function to return only the eigenstates with for example the correct number of particles. This is of particular importance in the case of vibrational structure calculations where the true ground state of the Hamiltonian is the vacuum state. A default filter function to check the number of particles is implemented in the different transformations and can be used as"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:9
msgid "Excited states solvers"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:23
msgid "|6702d146d3ff42d68fa668be7dbfec57|"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:25
msgid "In this tutorial we are going to discuss the excited states calculation interface of Qiskit Chemistry. The goal is to compute the excited states of a molecular Hamiltonian. This Hamiltonian can be electronic or vibrational. To know more about the preparation of the Hamiltonian, check out the Electronic structure and Vibrational structure tutorials."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:66
msgid "Let’s first start with a purely classical example: the NumPy eigensolver. This algorithm exactly diagonalizes the Hamiltonian. Although it scales badly, it can be used on small systems to check the results of the quantum algorithms. Here, we are only interested to look at eigenstates with a given number of particle. To compute only those states a filter function can be passed to the NumPy eigensolver. A default filter function is already implemented in Qiskit and can be used in this way:"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:89
msgid "The excitation energies can also be accessed with the qEOM algorithm [arXiv preprint arXiv:1910.12890 (2019)]. The EOM method finds the excitation energies (differences in energy between the ground state and all :math:`n`\\ th excited states) by solving the following pseudo-eigenvalue problem."
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:91
msgid "\\begin{pmatrix}\n"
"    \\text{M} & \\text{Q}\\\\\n"
"    \\text{Q*} & \\text{M*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}\n"
"= E_{0n}\n"
"\\begin{pmatrix}\n"
"    \\text{V} & \\text{W}\\\\\n"
"    -\\text{W*} & -\\text{V*}\n"
"\\end{pmatrix}\n"
"\\begin{pmatrix}\n"
"    \\text{X}_n\\\\\n"
"    \\text{Y}_n\n"
"\\end{pmatrix}"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:114
msgid "M_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger},\\hat{\\text{H}}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:119
msgid "Q_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{H}}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:124
msgid "V_{\\mu_{\\alpha}\\nu_{\\beta}} = \\langle0| [(\\hat{\\text{E}}_{\\mu_{\\alpha}}^{(\\alpha)})^{\\dagger}, \\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:129
msgid "W_{\\mu_{\\alpha}\\nu_{\\beta}} = -\\langle0| [(\\hat{\\text{E}}_{\\mu_\\alpha}^{(\\alpha)})^{\\dagger}, (\\hat{\\text{E}}_{\\nu_{\\beta}}^{(\\beta)})^{\\dagger}]|0\\rangle"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:134
msgid "Although the previous equation can be solved classically, each matrix element must be measured on the quantum computer with the corresponding ground state. To use the qEOM as a solver in Qiskit, we have to define a ground state calculation first, providing to the algorithm information on how to find the ground state. With this the qEOM solver can be initialized:"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:169
msgid "The results are computed and printed"
msgstr ""

#: ../../tutorials/04_excited_states_solvers.ipynb:376
msgid "One can see from these results that one state is missing from the NumPy results. The reason for this is because the spin is also used as a filter and only singlet states are shown. In the following we use a custom filter function to check consistently our results and only filter out states with incorrect number of particle (in this case the number of particle is 2)."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:9
msgid "Sampling the potential energy surface"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:23
msgid "This interactive notebook demonstrates how to utilize the Potential Energy Surface (PES) samplers algorithm of qiskit chemistry to generate the dissociation profile of a molecule. We use the Born-Oppenhemier Potential Energy Surface (BOPES)and demonstrate how to exploit bootstrapping and extrapolation to reduce the total number of function evaluations in computing the PES using the Variational Quantum Eigensolver (VQE)."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:69
msgid "Here, we use the H2 molecule as a model system for testing."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:127
msgid "Make a perturbation to the molecule along the absolute_stretching dof"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:174
msgid "Calculate bond dissociation profile using BOPES Sampler"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:176
msgid "Here, we pass the molecular information and the VQE to a built-in type called the BOPES Sampler. The BOPES Sampler allows the computation of the potential energy surface for a specified set of degrees of freedom/points of interest."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:188
msgid "First we compare no bootstrapping vs bootstrapping"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:190
msgid "Bootstrapping the BOPES sampler involves utilizing the optimal variational parameters for a given degree of freedom, say r (ex. interatomic distance) as the initial point for VQE at a later degree of freedom, say r + :math:`\\epsilon`. By default, if boostrapping is set to True, all previous optimal parameters are used as initial points for the next runs."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:258
msgid "Compare to classical eigensolver"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:292
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:494
msgid "Plot results"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:350
#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:577
msgid "Compare number of evaluations"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:416
msgid "Extrapolation"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:418
msgid "Here, an extrapolator added that will try to fit each (param,point) set to some specified function and suggest an initial parameter set for the next point (degree of freedom)."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:420
msgid "Extrapolator is based on an external extrapolator that sets the ‘window’, that is, the number of previous points to use for extrapolation, while the internal extrapolator proceeds with the actual extrapolation."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:421
msgid "In practice, the user sets the window by specifying an integer value to num_bootstrap - which is also the number of previous points to use for bootstrapping. Additionally, the external extrapolator defines the space within how to extrapolate - here PCA, clustering and the standard window approach."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:423
msgid "In practice, if no extrapolator is defined and bootstrapping is True, then all previous points will be bootstrapped. If an extrapolator list is defined and no points are specified for bootstrapping, then the extrapolation will be done based on all previous points."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:434
msgid "Window Extrapolator: An extrapolator which wraps another extrapolator, limiting the internal extrapolator’s ground truth parameter set to a fixed window size"
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:435
msgid "PCA Extrapolator: A wrapper extrapolator which reduces the points’ dimensionality with PCA, performs extrapolation in the transformed pca space, and untransforms the results before returning."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:436
msgid "Sieve Extrapolator: A wrapper extrapolator which performs an extrapolation, then clusters the extrapolated parameter values into two large and small clusters, and sets the small clusters’ parameters to zero."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:437
msgid "Polynomial Extrapolator: An extrapolator based on fitting each parameter to a polynomial function of a user-specified degree."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:438
msgid "Differential Extrapolator: An extrapolator based on treating each param set as a point in space, and performing regression to predict the param set for the next point. A user-specified degree also adds derivatives to the values in the point vectors which serve as features in the training data for the linear regression."
msgstr ""

#: ../../tutorials/05_Sampling_potential_energy_surfaces.ipynb:450
msgid "Here we test two different extrapolation techniques"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:9
msgid "Calculating Thermodynamics Observables with a quantum computer"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:53
msgid "A preliminary draft with more information related to this tutorial can be found in preprint: Stober et al, arXiv 2003.02303 (2020)"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:65
msgid "Calculation of the Born Oppenheimer Potential Energy Surface (BOPES)"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:76
msgid "To compute thermodynamic observables we begin with single point energy calculation which calculates the wavefunction and charge density and therefore the energy of a particular arrangement of nuclei. Here we compute the Born-Oppenheimer potential energy surface of a hydrogen molecule, as an example, which is simply the electronic energy as a function of bond length."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:253
msgid "Calculation of the molecular Vibrational Energy levels"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:265
msgid "The Born-Oppeheimer approximation removes internuclear vibrations from the molecular Hamiltonian and the energy computed from quantum mechanical ground-state energy calculations using this approximation contain only the electronic energy. Since even at absolute zero internuclear vibrations still occur, a correction is required to obtain the true zero-temperature energy of a molecule. This correction is called the zero-point vibrational energy (ZPE), which is computed by summing the contribution from internuclear vibrational modes. Therefore, the next step in computing thermodynamic observables is determining the vibrational energy levels. This can be done by constructing the Hessian matrix based on computed single point energies close to the equilibrium bond length. The eigenvalues of the Hessian matrix can then be used to determine the vibrational energy levels and the zero-point vibrational energy"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:268
msgid ":nbsphinx-math:`\\begin{equation} {\\rm ZPE} = \\frac{1}{2}\\, \\sum_i ^M \\nu_i \\, , \\end{equation}` with :math:`\\nu_i` being the vibrational frequencies, :math:`M = 3N − 6` or :math:`M = 3N − 5` for non-linear or linear molecules, respectively, and :math:`N` is number of the particles."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:279
msgid "Here we fit a “full” energy surface using a 1D spline potential and use it to evaluate molecular vibrational energy levels."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:326
msgid "Create a partition function for the calculation of heat capacity"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:337
msgid "The partition function for a molecule is the product of contributions from translational, rotational, vibrational, electronic, and nuclear degrees of freedom. Having the vibrational frequencies, now we can obtain the vibrational partition function :math:`q_{\\rm vibration}` to compute the whole molecular partition function :nbsphinx-math:`\\begin{equation} q_{\\rm vibration} = \\prod_{i=1} ^M \\frac{\\exp\\,(-\\Theta_{\\nu_i}/2T)}{1-\\exp\\,(-\\Theta_{\\nu_i}/2T} \\, . \\end{equation}` Here :math:`\\Theta_{\\nu_i}= h\\nu_i/k_B`, :math:`T` is the temperature and :math:`k_B` is the Boltzmann constant."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:341
msgid "The single-point energy calculations and the resulting partition function can be used to calculate the (constant volume or constant pressure) heat capacity of the molecules. The constant volume heat capacity, for example, is given by"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:343
msgid ":nbsphinx-math:`\\begin{equation} C_v = \\left.\\frac{\\partial U}{\\partial T}\\right|_{N,V}\\, , \\qquad {\\rm with} \\quad U=k_B T^2 \\left.\\frac{\\partial {\\rm ln} Q}{\\partial T}\\right|_{N,V} . \\end{equation}`"
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:350
msgid ":math:`U` is the internal energy, :math:`V` is the volume and :math:`Q` is the partition function."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:361
msgid "Here we illustrate the simplest usage of the partition function, namely creating a Thermodynamics object to compute properties like the constant pressure heat capacity defined above."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:410
msgid "Here we demonstrate how to access particular components (the rotational part) of the partition function, which in the H2 case we can further split to para-hydrogen and ortho-hydrogen components."
msgstr ""

#: ../../tutorials/06_calculating_thermodynamic_observables.ipynb:433
msgid "We will now plot the constant volume heat capacity (of the rotational part) demonstrating how we can call directly the functions in the ‘thermodynamics’ module, providing a callable object for the partition function (or in this case its rotational component). Note that in the plot we normalize the plot dividing by the universal gas constant R (Avogadro’s number times Boltzman’s constant) and we use crossed to compare with experimental data found in literature."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:9
msgid "Leveraging Qiskit Runtime"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:20
msgid "Iterative algorithms, such as the Variational Quantum Eigensolver (VQE), traditionally send one batch of circuits (one “job”) to be executed on the quantum device in each iteration. Sending a job involves certain overhead, mainly"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:22
msgid "the time to process the requests and send the data (API overhead, usually about 10s)"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:23
msgid "the job queue time, that is how long you have to wait before it’s your turn to run on the device (usually about 2min)"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:25
msgid "If we send hundreds of jobs iteratively, this overhead quickly dominates the execution time of our algorithm. Qiskit Runtime allows us to tackle these issues and significantly speed up (especially) iterative algorithms. With Qiskit Runtime, one job does not contain only a batch of circuits but the *entire* algorithm. That means we only experience the API overhead and queue wait *once* instead of in every iteration! You’ll be able to either upload algorithm parameters and delegate all the complexity to the cloud, where your program is executed, or upload your personal algorithm directly."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:28
msgid "For the VQE, the integration of Qiskit Runtime in your existing code is a piece of cake. There is a (almost) drop-in replacement, called ``VQEProgram`` for the ``VQE`` class."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:30
msgid "Let’s see how you can leverage the runtime on a simple chemistry example: Finding the ground state energy of the lithium hydrate (LiH) molecule at a given bond distance."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:42
msgid "Problem specification: LiH molecule"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:44
msgid "First, we specify the molecule whose ground state energy we seek. Here, we look at LiH with a bond distance of 2.5 Å."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:101
msgid "Classical reference solution"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:112
msgid "As a reference solution we can solve this system classically with the ``NumPyEigensolver``."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:171
msgid "VQE"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:173
msgid "To run the VQE we need to select a parameterized quantum circuit acting as ansatz and a classical optimizer. Here we’ll choose a heuristic, hardware efficient ansatz and the SPSA optimizer."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:221
msgid "Before executing the VQE in the cloud using Qiskit Runtime, let’s execute a local VQE first."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:302
msgid "Runtime VQE"
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:304
msgid "Let’s exchange the eigensolver from a local VQE algorithm to a VQE executed using Qiskit Runtime – simply by exchanging the ``VQE`` class by the ``VQEProgram``."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:306
msgid "First, we’ll have to load a provider to access Qiskit Runtime. **Note:** You have to replace the next cell with your provider."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:332
msgid "Now we can set up the ``VQEProgram``. In this first release, the optimizer must be provided as a dictionary, in future releasess you’ll be able to pass the same optimizer object as in the traditional VQE."
msgstr ""

#: ../../tutorials/07_leveraging_qiskit_runtime.ipynb:409
msgid "If we are interested in the development of the energy, the ``VQEProgram`` allows access to the history of the optimizer, which contains the loss per iteration (along with the parameters and a timestamp). We can access this data via the ``raw_result`` attribute of the ground state solver."
msgstr ""

#: ../../tutorials/index.rst:3
msgid "Qiskit Nature Tutorials"
msgstr ""


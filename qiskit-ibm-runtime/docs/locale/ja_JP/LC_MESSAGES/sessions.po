msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-28 21:26+0000\n"
"PO-Revision-Date: 2023-10-08 09:52\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /main/qiskit-ibm-runtime/docs/locale/en/LC_MESSAGES/sessions.po\n"
"X-Crowdin-File-ID: 10003\n"

#: ../../sessions.rst:2
msgid "Introduction to sessions"
msgstr "Session 入門"

#: ../../sessions.rst:4
msgid "A session is a contract between the user and the Qiskit Runtime service that ensures that a collection of jobs can be grouped and jointly prioritized by the quantum computer’s job scheduler. This eliminates artificial delays caused by other users’ jobs running on the same quantum device during the session time."
msgstr "Session とは、ユーザーとQiskit Runtimeサービスとの間のコントラクトであり、ジョブの集まりをグループ化し、量子コンピューターのジョブスケジューラーによって共同で優先順位をつけることができるようにするものです。これにより、session 時間中に同じ量子デバイス上で実行される他のユーザーのジョブによって引き起こされる人為的な遅延を排除することができます。"

#: ../../sessions.rst:9
msgid "In simple terms, once your session is active, jobs submitted within the session are not interrupted by other users’ jobs."
msgstr "簡単に言うと、session がアクティブになると、session 内で投入されたジョブは、他のユーザーのジョブに邪魔されなくなります。"

#: ../../sessions.rst:11
msgid "Compared with jobs that use the `fair-share scheduler <https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/queue>`__, sessions become particularly beneficial when running programs that require iterative calls between classical and quantum resources, where a large number of jobs are submitted sequentially. This is the case, for example, when training a variational algorithm such as VQE or QAOA, or in device characterization experiments."
msgstr "`fair-share scheduler <https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/queue>`__ を使用するジョブに比べ、session は、古典リソースと量子リソースの間の反復的な呼び出しを必要とし、多数のジョブが連続して投入されるプログラムの実行時に特に有益です。例えば、VQEやQAOAのような変分アルゴリズムの学習や、デバイスの特性評価実験がこれにあたります。"

#: ../../sessions.rst:13
msgid "Runtime sessions can be used in conjunction with Qiskit Runtime primitives. Primitive program interfaces vary based on the type of task that you want to run on the quantum computer and the corresponding data that you want returned as a result. After identifying the appropriate primitive for your program, you can use Qiskit to prepare inputs, such as circuits, observables (for Estimator), and customizable options to optimize your job. For more information, see the `Primitives <primitives.html>`__ topic."
msgstr "Runtime session は、Qiskit Runtime primitive と組み合わせて使用することができます。Primitiveは、量子コンピューター上でどのような処理を行い、その結果をどのようなデータとして返すかによって使い分けられます。プログラムに適したprimitiveを特定した後、Qiskitを使用して、回路、観測値（Estimator用）、ジョブを最適化するためのカスタマイズ可能なオプションなどの入力を準備することができます。詳細については、 `Primitives <primitives.html>`__ のトピックを参照してください。"

#: ../../sessions.rst:16
msgid "Benefits of using sessions"
msgstr "Session を使用する利点"

#: ../../sessions.rst:18
msgid "There are several benefits to using sessions:"
msgstr "Session の使用には、次のような利点があります："

#: ../../sessions.rst:20
msgid "Jobs that belong to a single algorithm run are run together without interruption, increasing efficiency if your program submits multiple sequential jobs."
msgstr "単一のアルゴリズム実行に属するジョブが中断することなく一緒に実行されるため、プログラムが複数の連続したジョブを投入する場合の効率が向上します。"

#: ../../sessions.rst:23
msgid "The queuing time does not decrease for the first job submitted within a session. Therefore, a session does not provide any benefits if you only need to run a single job."
msgstr "Session 内で最初に投入されたジョブについては、キューイング時間は短縮されません。したがって、単一のジョブだけを実行する必要がある場合、session は何のメリットもありません。"

#: ../../sessions.rst:24
msgid "Since data from the first session job is cached and used by subsequent jobs, if the first job is cancelled, subsequent session jobs will all fail."
msgstr "最初の session のジョブのデータはキャッシュされ、後続のジョブで使用されるため、最初のジョブがキャンセルされると、後続の session のジョブはすべて失敗します。"

#: ../../sessions.rst:26
msgid "When using sessions, the uncertainty around queuing time is significantly reduced. This allows better estimation of a workload's total runtime and better resource management."
msgstr "Session を使用すると、キューイング時間に関する不確実性が大幅に減少します。これにより、ワークロードの総実行時間をより良く見積もることができ、より良いリソース管理が可能になります。"

#: ../../sessions.rst:27
msgid "In a device characterization context, being able to run experiments closely together helps prevent device drifts and provide more accurate results."
msgstr "デバイスの特性評価において、実験を密に実行できるため、デバイスのドリフトを防ぎ、より正確な結果を得ることができます。"

#: ../../sessions.rst:28
msgid "While the session is active, you can submit different jobs, inspect job results, and re-submit new jobs without opening a new session."
msgstr "Session がアクティブな間は、新しい session を開くことなく、異なるジョブの投入、ジョブ結果の確認、新しいジョブの再投入が可能です。"

#: ../../sessions.rst:29
msgid "You maintain the flexibility to deploy your programs either remotely (cloud / on-premises) or locally (your laptop)."
msgstr "リモート（クラウド/オンプレミス）またはローカル（ラップトップ）のどちらでも、柔軟にプログラムを展開できます。"

#: ../../sessions.rst:32
msgid "The mechanics of sessions (queuing)"
msgstr "Session（キューイング）の仕組み"

#: ../../sessions.rst:34
msgid "For each backend, the first job in the session waits its turn in the queue normally, but while the session is active, subsequent jobs within the same session take priority over any other queued jobs. If no jobs that are part of the active session are ready, the session is deactivated (paused), and the next job from the regular fair-share queue is run. See :ref:`ttl` for more information."
msgstr "各バックエンドにおいて、session 内の最初のジョブは通常通りキューで順番を待ちますが、session がアクティブな間は、同じ session 内の後続のジョブが、キューに入れられた他のジョブよりも優先されます。アクティブな session の一部であるジョブが準備できていない場合、session は非アクティブ化（一時停止）され、通常の fair-share キューから次のジョブが実行されます。詳細については、 :ref:`ttl` を参照してください。"

#: ../../sessions.rst:36
msgid "A quantum processor still executes one job at a time. Therefore, jobs that belong to a session still need to wait for their turn if one is already running."
msgstr "量子プロセッサーは、1度に1つのジョブを実行します。そのため、session に属するジョブがすでに実行されている場合は、そのジョブの順番を待つ必要があります。"

#: ../../sessions.rst:39
msgid "Internal systems jobs such as calibration have priority over session jobs."
msgstr "キャリブレーションなどの内部システムのジョブは、session のジョブよりも優先されます。"

#: ../../sessions.rst:42
msgid "Iterations and batching"
msgstr "反復とバッチ処理"

#: ../../sessions.rst:44
msgid "Sessions can be used for iterative or batch execution."
msgstr "Session は反復またはバッチ実行に使用できます。"

#: ../../sessions.rst:47
msgid "Iterative"
msgstr "反復"

#: ../../sessions.rst:49
msgid "Any session job submitted within the five-minute interactive timeout, also known as Time to live (TTL), is processed immediately. This allows some time for variational algorithms, such as VQE, to perform classical post-processing."
msgstr "TTL (Time to live) とも呼ばれる5分間のインタラクティブタイムアウト内に投入されたsession ジョブは、即座に処理されます。これにより、VQEのような変分アルゴリズムが古典的な後処理を行うための時間が確保されます。"

#: ../../sessions.rst:51
msgid "The quantum device is locked to the session user unless the TTL is reached."
msgstr "TTLに達しない限り、量子デバイスは session ユーザーにロックされます。"

#: ../../sessions.rst:52
msgid "Post-processing could be done anywhere, such as a personal computer, cloud service, or an HPC environment."
msgstr "後処理は、パーソナルコンピューター、クラウドサービス、HPC環境など、どこでも行うことができます。"

#: ../../sessions.rst:57
msgid "Batch"
msgstr "バッチ"

#: ../../sessions.rst:59
msgid "Ideal for running experiments closely together to avoid device drifts, that is, to maintain device characterization."
msgstr "デバイスのドリフトを避けるため、つまりデバイス特性を維持するために、実験を密に実行するのに最適です。"

#: ../../sessions.rst:61
msgid "Suitable for batching many jobs together."
msgstr "多くのジョブをまとめてバッチ処理するのに適しています。"

#: ../../sessions.rst:62
msgid "Jobs that fit within the maximum session time run back-to-back on hardware."
msgstr "最大 session 時間内に収まるジョブは、ハードウェア上で連続して実行されます。"

#: ../../sessions.rst:65
msgid "When batching, jobs are not guaranteed to run in the order they are submitted."
msgstr "バッチ処理では、ジョブが送信された順番に実行されることは保証されません。"

#: ../../sessions.rst:72
msgid "How long a session stays active"
msgstr "Session の有効期間"

#: ../../sessions.rst:74
msgid "The length of time a session is active is controlled by the *maximum session timeout* (``max_time``) value and the *interactive* timeout value (TTL). The ``max_time`` timer starts when the session becomes active.  That is, when the first job runs, not when it is queued. It does not stop if a session becomes inactive. The TTL timer starts each time a session job finishes."
msgstr "Session がアクティブである時間の長さは、 *最大 Session タイムアウト*  (``max_time``) 値と *インタラクティブな* タイムアウト値(TTL) によって制御されます。 ``max_time`` タイマーは session がアクティブになったときに開始します。つまり、それは、最初のジョブが実行されたときであり、キューに入れられたときではありません。また、Session が非アクティブになっても停止しません。TTLタイマーは session ジョブが終了するたびに開始します。"

#: ../../sessions.rst:77
msgid "For an Open plan user, the maximum session timeout is 15 minutes."
msgstr "オープンプランのユーザーの場合、最大 session タイムアウトは15分です。"

#: ../../sessions.rst:80
msgid "Maximum session timeout"
msgstr "最大 Session タイムアウト"

#: ../../sessions.rst:82
msgid "When a session is started, it is assigned a *maximum session timeout* value.  You can set this value by using the ``max_time`` parameter, which can be greater than the program's ``max_execution_time``. For instructions, see `Run a primitive in a session <how_to/run_session.html>`__."
msgstr "Session が開始される際、 *最大session タイムアウト* 値が割り当てられます。  この値は、``max_time`` パラメーターを使用して設定できます。このパラメーターは、プログラムの ``max_execution_time`` より大きくてもかまいません。手順については、 `Session内でprimitiveを実行する <how_to/run_session.html>`__ を参照してください。"

#: ../../sessions.rst:85
msgid "If you do not specify a timeout value, it is the smaller of these values:"
msgstr "タイムアウト値を指定しない場合は、以下の値のうち小さい方の値となります："

#: ../../sessions.rst:87
msgid "The system limit"
msgstr "システムの制限値"

#: ../../sessions.rst:88
msgid "The ``max_execution_time`` defined by the program"
msgstr "プログラムによって定義された ``max_execution_time``"

#: ../../sessions.rst:90
msgid "See `What is the maximum execution time for a Qiskit Runtime job? <faqs/max_execution_time.html>`__ to determine the system limit and the ``max_execution_time`` for primitive programs."
msgstr "Primitive プログラムのシステム制限と ``max_execution_time`` を決定するには、 `What is the maximum execution time for a Qiskit Runtime job? <faqs/max_execution_time.html>`__ を参照ください。"

#: ../../sessions.rst:95
msgid "Interactive timeout value"
msgstr "インタラクティブなタイムアウト値"

#: ../../sessions.rst:97
msgid "Every session has an *interactive timeout value*, or time to live (TTL), of five minutes, which cannot be changed. If there are no session jobs queued within the TTL window, the session is temporarily deactivated and normal job selection resumes. A deactivated session can be resumed if it has not reached its maximum timeout value. The session is resumed when a subsequent session job starts. Once a session is deactivated, its next job waits in the queue like other jobs."
msgstr "すべての session には5分間の *インタラクティブなタイムアウト値* 、つまり存続時間 ( time to live, TTL) が設定されており、これを変更することはできません。TTLウィンドウ内にキューに入っている session ジョブがない場合、sessionは一時的に非アクティブになり、通常のジョブ選択が再開されます。無効化された session は、最大タイムアウト値に達していなければ再開できます。Session は、後続の session ジョブが開始したときに再開されます。Session が非アクティブ化されると、その次のジョブは他のジョブと同様にキューで待機します。"

#: ../../sessions.rst:99
msgid "After a session is deactivated, the next job in the queue is selected to run. This newly selected job (which can belong to a different user) can run as a singleton, but it can also start a different session. In other words, a deactivated session does not block the creation of other sessions. Jobs from this new session would then take priority until it is deactivated or closed, at which point normal job selection resumes."
msgstr "Session が非活性化されると、キュー内の次のジョブが選択されて実行されます。この新しく選択されたジョブ（異なるユーザーに属することができる）は、シングルトンとして実行することができますが、異なる session を開始することもできます。言い換えると、無効化された session は、他の session の作成をブロックしません。この新しい session からのジョブは、それが非活性化されるか閉じられるまで優先され、その時点で通常のジョブ選択が再開されます。"

#: ../../sessions.rst:102
msgid "When running jobs through the Open Plan, the interactive timeout value is two seconds."
msgstr "オープンプランでジョブを実行する場合、インタラクティブなタイムアウトの値は2秒です。"

#: ../../sessions.rst:107
msgid "What happens when a session ends"
msgstr "Session が終了するとどうなるか"

#: ../../sessions.rst:109
msgid "A session ends by reaching its maximum timeout value or when it is manually closed by the user.  Do not close a session until all jobs **complete**. See `Close a session <how_to/run_session.html#close session>`__ for details. After a session is closed, the following occurs:"
msgstr "Session は、最大タイムアウト値に達するか、ユーザーによって手動で閉じられると終了します。すべてのジョブが **完了** するまで、session を閉じないでください。詳細については、 `Session を閉じる <how_to/run_session.html#close session>`__ を参照してください。Session が閉じられると、以下が発生します："

#: ../../sessions.rst:111
msgid "Any queued jobs remaining in the session (whether they are queued or not) are put into a failed state."
msgstr "Session に残っているキューに入れられたジョブ（キューに入れられたかどうかにかかわらず）は、すべて失敗状態になります。"

#: ../../sessions.rst:112
msgid "No further jobs can be submitted to the session."
msgstr "その session に、それ以上ジョブを投入することはできません。"

#: ../../sessions.rst:113
msgid "The session cannot be reopened."
msgstr "Session を再開することはできません。"

#: ../../sessions.rst:117
msgid "Sessions and reservations"
msgstr "Session と予約"

#: ../../sessions.rst:119
msgid "IBM Quantum Premium users can access both reservations and sessions on specific backends. Such users should plan ahead and decide whether to use a session or a reservation. You *can* use a session within a reservation.  However, if you use a session within a reservation and some session jobs don’t finish during the reservation window, the remaining pending jobs might fail. If you use session inside a reservation, we suggest you set a realistic ``max_time`` value."
msgstr "IBM Quantum Premiumユーザーは、特定のバックエンドで予約と session の両方にアクセスできます。このようなユーザーは、事前に計画を立て、session と予約のどちらを使用するかを決定する必要があります。予約の中で session を使用することも *できます* 。ただし、予約内で session を使用し、一部の session ジョブが予約ウィンドウ内に終了しなかった場合、保留中の残りのジョブが失敗する可能性があります。予約の中で session を使用する場合は、現実的な ``max_time`` 値を設定することをお勧めします。"

#: ../../sessions.rst:125
msgid "Next steps"
msgstr "次のステップ"

#: ../../sessions.rst:127
msgid "`Run a primitive in a session <how_to/run_session.html>`__"
msgstr "`Session内でprimitiveを実行する <how_to/run_session.html>`__"


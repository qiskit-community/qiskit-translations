msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-18 21:33+0000\n"
"PO-Revision-Date: 2023-10-18 21:55\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /main/qiskit-ibm-runtime/docs/locale/en/LC_MESSAGES/tutorials/qaoa_with_primitives.po\n"
"X-Crowdin-File-ID: 10009\n"

#: ../../tutorials/qaoa_with_primitives.ipynb:9
msgid "This page was generated from `docs/tutorials/qaoa_with_primitives.ipynb`__."
msgstr "このページは `docs/tutorials/qaoa_with_primitives.ipynb`__ から生成されました。"

#: ../../tutorials/qaoa_with_primitives.ipynb:9
msgid "QAOA using Qiskit Runtime primitives and Session"
msgstr "Qiskit Runtime primitives と Session を使用したQAOA"

#: ../../tutorials/qaoa_with_primitives.ipynb:21
msgid "Background"
msgstr "背景"

#: ../../tutorials/qaoa_with_primitives.ipynb:23
msgid "The Quantum Approximate Optimization Algorithm (QAOA) is a hybrid iterative method for solving combinatorial optimization problems. You can learn more about this algorithm `here <https://learn.qiskit.org/course/ch-applications/solving-combinatorial-optimization-problems-using-qaoa>`__. In this tutorial we demonstrate how to implement the QAOA algorithm using Qiskit Runtime for solving a simple max-cut problem."
msgstr "量子近似最適化アルゴリズム（QAOA）は、組合せ最適化問題を解くためのハイブリッド反復法です。このアルゴリズムについての詳細は `こちら <https://learn.qiskit.org/course/ch-applications/solving-combinatorial-optimization-problems-using-qaoa>`__ を参照してください。このチュートリアルでは、シンプルな最大カット問題を解くためにQiskit Runtimeを使用してQAOAアルゴリズムを実装する方法を示します。"

#: ../../tutorials/qaoa_with_primitives.ipynb:25
msgid "In a max-cut problem, we want to partition nodes of a graph in a way that maximizes the number of edges between nodes in differing groups. The desired max-cut partition for the following graph is clear: the 0th-node on the left should be separated from the rest of the nodes on the right by a cut. We will find this answer by applying QAOA by using Qiskit Runtime primitives and sessions."
msgstr "最大カット問題では、異なるグループのノード間の辺の数が最大になるようにグラフのノードを分割したいと考えます。次のグラフに対して望まれる最大カット分割は明らかです：左の0番目のノードは、カットによって右の残りのノードから分離されるべきです。Qiskit Runtime の primitives と session を使って QAOA を適用し、この解を見つけます。"

#: ../../tutorials/qaoa_with_primitives.ipynb:65
msgid "Setup"
msgstr "設定"

#: ../../tutorials/qaoa_with_primitives.ipynb:102
msgid "Initialize Runtime service and select backend"
msgstr "Runtime サービスを初期化してバックエンドを選択する"

#: ../../tutorials/qaoa_with_primitives.ipynb:104
msgid "First, we need to instantiate the IBM Quantum Runtime service ``QiskitRuntimeService`` to choose a `computational resource <https://quantum-computing.ibm.com/services/resources?tab=systems&limit=40>`__ on which to execute our QAOA algorithm. In this tutorial, the ``ibmq_qasm_simlator`` is chosen."
msgstr "最初に、IBM Quantum Runtime サービス ``QiskitRuntimeService`` をインスタンス化して、QAOA アルゴリズムを実行するためのリソース `計算リソース <https://quantum-computing.ibm.com/services/resources?tab=systems&limit=40>`__ を選択する必要があります。このチュートリアルでは、 ``ibmq_qasm_simlator`` を選択します。"

#: ../../tutorials/qaoa_with_primitives.ipynb:127
msgid "QAOA Hamiltonian and ansatz"
msgstr "QAOA ハミルトニアンと ansatz"

#: ../../tutorials/qaoa_with_primitives.ipynb:129
msgid "To use the QAOA algorithm for a max-cut problem we require a Pauli Hamiltonian that encodes the cost in a manner such that the minimum expectation value of the operator corresponds to the maximum number of edges between the nodes in two different groups."
msgstr "QAOAアルゴリズムを最大カット問題に用いるには、演算子の最小期待値が2つの異なるグループのノード間の最大エッジ数に対応するような方法でコストをエンコードするパウリ・ハミルトニアンが必要です。"

#: ../../tutorials/qaoa_with_primitives.ipynb:131
msgid "For this simple example, the operator is a linear combination of terms with ``Z`` operators on nodes connected by an edge (recall that the 0th qubit is farthest right): :math:`IIIZZ + IIZIZ + IZIIZ + ZIIIZ`. Once the operator is constructed, the ansatz for the QAOA algorithm can easily be built by using the ``QAOAAnsatz`` circuit from the Qiskit circuit library."
msgstr "この単純な例では、演算子はエッジで接続されたノード上の ``Z`` 演算子を持つ項の線形結合です（0番目の量子ビットが最も右にあることを思い出してください）：:math:`IIIZZ + IIZIZ + IZIIZ + ZIIIZ` 。一旦演算子が構築されれば、QAOAアルゴリズムのansatzはQiskit circuit ライブラリーの ``QAOAAnsatz`` 回路を使うことで簡単に構築できます。"

#: ../../tutorials/qaoa_with_primitives.ipynb:171
msgid "The previous image illustrates the ansatz in basic gates for clarity. However, it can be expressed in multiple levels of decomposition by changing the ``reps`` argument or by drawing the circuit without the ``decompose`` method. For example, the following representation directly shows the QAOA structure with the default ``reps`` value, which is ``reps=1``."
msgstr "前の図では、わかりやすくするために基本ゲートでansatzを示しています。しかし、引数 ``reps`` を変更するか、 ``decompose`` メソッドを使わずに回路を描画することで、複数レベルの分解で表現することができます。例えば、以下の表現はデフォルトの ``reps`` 値である ``reps=1`` でのQAOA構造を直接示しています。"

#: ../../tutorials/qaoa_with_primitives.ipynb:207
msgid "Define the cost function by using Estimator"
msgstr "Estimatorを使ったコスト関数の定義"

#: ../../tutorials/qaoa_with_primitives.ipynb:218
msgid "As with an iterative optimization procedure, we now need to define our cost function over which to minimize. We proceed in an identical manner to the `VQE tutorial <vqe_with_estimator.ipynb>`__, computing the expectation value of our Hamiltonian with respect to the parameterized ansatz circuit using the Qiskit Runtime ``Estimator`` primitive:"
msgstr "反復最適化手順と同様に、最小化するコスト関数を定義する必要があります。 `VQEチュートリアル <vqe_with_estimator.ipynb>`__ と同じように、Qiskit Runtimeの ``Estimator``  primitive を使用して、パラメーター化されたansatz回路に関するハミルトニアンの期待値を計算します："

#: ../../tutorials/qaoa_with_primitives.ipynb:253
msgid "Minimize the cost function"
msgstr "コスト関数の最小化"

#: ../../tutorials/qaoa_with_primitives.ipynb:255
msgid "Any classical optimizer can be used to minimize the cost function. On a real quantum system, an optimizer designed for non-smooth cost function landscapes usually does better. Here we use the `COBYLA routine from SciPy through the minimize function <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html>`__."
msgstr "古典オプティマイザーは、コスト関数を最小化することができます。本物の量子システムでは、非平滑なコスト関数の形状用に設計されたオプティマイザーの方が、通常はうまくいきます。ここでは、 `SciPyのCOBYLAルーチンをminimize関数を通して <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html>`__ 使用します。"

#: ../../tutorials/qaoa_with_primitives.ipynb:257
msgid "Because we are iteratively executing many calls to Runtime, we use a ``Session`` to execute all calls within a single block. Moreover, for QAOA, the solution is encoded in the output distribution of the ansatz circuit bound with the optimal parameters from the minimization. Therefore, we will need a ``Sampler`` primitive as well, and will instantiate it with the same ``Session``."
msgstr "Runtimeへの多数の呼び出しを繰り返し実行するため、 ``Session`` を使用して単一のブロック内ですべての呼び出しを実行します。さらに、QAOAでは、最小化で得た最適なパラメーターで結合されたansatz回路の出力分布として解がエンコードされます。そのため ``Sampler`` primitive も必要となり、同じ ``Session`` でインスタンス化します。"

#: ../../tutorials/qaoa_with_primitives.ipynb:281
msgid "We now set an initial set of random parameters:"
msgstr "ここで、ランダムなパラメーターの初期セットを設定します："

#: ../../tutorials/qaoa_with_primitives.ipynb:302
msgid "and run our minimization routine:"
msgstr "そして最小化ルーチンを実行します："

#: ../../tutorials/qaoa_with_primitives.ipynb:323
msgid "In the end, we have a result in the standard SciPy ``OptimizeResult`` format."
msgstr "最後に、標準的な SciPy の ``OptimizeResult`` フォーマットの結果が得られます。"

#: ../../tutorials/qaoa_with_primitives.ipynb:388
msgid "Solution to max-cut"
msgstr "最大カットの解"

#: ../../tutorials/qaoa_with_primitives.ipynb:399
msgid "The solution vector of parameter angles (``x``), when plugged into the ``ansatz`` circuit, yields the graph partitioning that we were looking for."
msgstr "パラメーター角度 (``x``) の解ベクトルを ``ansatz`` 回路に入れると、求めていたグラフ分割が得られます。"

#: ../../tutorials/qaoa_with_primitives.ipynb:436
msgid "For small problem instances, the solution can be visually obtained:"
msgstr "小さな問題インスタンスでは、解を視覚的に得ることができます："

#: ../../tutorials/qaoa_with_primitives.ipynb:471
msgid "The most probable bit-strings, up to finite-sampling deviations, encode the solution. Here we see that ``00001`` and ``11110`` are found, and are indeed correct. There are two solutions because the labeling of the two partitions with ``'0'`` or ``'1'`` is arbitrary."
msgstr "有限サンプリング偏差までの最も確率の高いビット列が、解を符号化しています。ここでは ``00001`` と ``11110`` が見つかり、確かに正しいことがわかります。 ``'0'`` または ``'1'`` という2つのパーティションのラベル付けは任意であるため、2つの解が存在します。"


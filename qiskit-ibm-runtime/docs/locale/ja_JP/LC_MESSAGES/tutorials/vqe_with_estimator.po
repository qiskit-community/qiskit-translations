msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-12 19:16+0000\n"
"PO-Revision-Date: 2023-10-08 13:33\n"
"Last-Translator: \n"
"Language: ja\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /main/qiskit-ibm-runtime/docs/locale/en/LC_MESSAGES/tutorials/vqe_with_estimator.po\n"
"X-Crowdin-File-ID: 9834\n"

#: ../../tutorials/vqe_with_estimator.ipynb:9
msgid "This page was generated from `docs/tutorials/vqe_with_estimator.ipynb`__."
msgstr "このページは `docs/tutorials/vqe_with_estimator.ipynb`__ から生成されました。"

#: ../../tutorials/vqe_with_estimator.ipynb:9
msgid "VQE using Estimator primitive and Sessions"
msgstr "Estimator primitive と session を使った VQE"

#: ../../tutorials/vqe_with_estimator.ipynb:21
msgid "Background"
msgstr "背景"

#: ../../tutorials/vqe_with_estimator.ipynb:23
msgid "`Variational quantum algorithms <https://arxiv.org/abs/2012.09265>`__ are promising candidate hybrid-algorithms for observing the utility of quantum computation on noisy near-term devices. Variational algorithms are characterized by the use of a classical optimization algorithm to iteratively update a parameterized trial solution, or \"ansatz\". Chief among these methods is the Variational Quantum Eigensolver (VQE) that aims to solve for the ground state of a given Hamiltonian represented as a linear combination of Pauli terms, with an ansatz circuit where the number of parameters to optimize over is polynomial in the number of qubits. Given that size of the full solution vector is exponential in the number of qubits, successful minimization using VQE requires, in general, additional problem specific information to define the structure of the ansatz circuit."
msgstr "`変分量子アルゴリズム <https://arxiv.org/abs/2012.09265>`__ は、ノイズの多い近い将来のデバイス上での量子計算の有用性を観測するための有望なハイブリッドアルゴリズムの候補です。変分アルゴリズムは、パラメーター化されたトライアル解（ansatz）を繰り返し更新するために、古典的な最適化アルゴリズムを使用することが特徴です。これらの手法の中で最も重要なものは、変分量子固有値ソルバー（VQE）であり、パウリ項の線形結合として表されるハミルトニアンの基底状態を、最適化するパラメーターの数が量子ビット数の多項式となる ansatz 回路を用いて解くことを目的としています。完全な解のベクトルのサイズが量子ビット数に対して指数関数的であることを考えると、VQEを用いて最小化を成功させるには、一般的に、ansatz 回路の構造を定義するために、問題固有の情報を追加する必要があります。"

#: ../../tutorials/vqe_with_estimator.ipynb:26
msgid "Executing a VQE algorithm requires the following 3 components:"
msgstr "VQE アルゴリズムを実行するには、以下の 3 つのコンポーネントが必要です："

#: ../../tutorials/vqe_with_estimator.ipynb:28
msgid "Hamiltonian and ansatz (problem specification)"
msgstr "ハミルトニアンと ansatz (問題の仕様)"

#: ../../tutorials/vqe_with_estimator.ipynb:29
msgid "Qiskit Runtime estimator"
msgstr "Qiskit Runtime estimator"

#: ../../tutorials/vqe_with_estimator.ipynb:30
msgid "Classical optimizer"
msgstr "古典オプティマイザー"

#: ../../tutorials/vqe_with_estimator.ipynb:32
msgid "Although the Hamiltonian and ansatz require domain specific knowledge to construct, these details are immaterial to the Runtime, and we can execute a wide class of VQE problems in the same manner."
msgstr "ハミルトニアンとansatzを構築するには領域固有の知識が必要ですが、これらの詳細は Runtime にとって重要ではなく、同じ方法で幅広いクラスのVQE問題を実行することができます。"

#: ../../tutorials/vqe_with_estimator.ipynb:44
msgid "Setup"
msgstr "設定"

#: ../../tutorials/vqe_with_estimator.ipynb:46
msgid "Here we import the tools needed for a VQE experiment. The primary imports can be grouped logically into three components that correspond to the three required elements."
msgstr "ここでは、VQEの実験に必要なツールをインポートします。主要なインポートは、必要な3つの要素に対応する3つのコンポーネントに論理的にグループ化することができます。"

#: ../../tutorials/vqe_with_estimator.ipynb:86
msgid "Initialize Runtime service and select backend"
msgstr "Runtime サービスを初期化してバックエンドを選択する"

#: ../../tutorials/vqe_with_estimator.ipynb:88
msgid "Here we instantiate the Runtime service that gives access to the simulator that we use in this tutorial."
msgstr "ここでは、このチュートリアルで使用するシミュレーターへのアクセスを提供する Runtime サービスをインスタンス化します。"

#: ../../tutorials/vqe_with_estimator.ipynb:120
msgid "Problem specification"
msgstr "問題の仕様"

#: ../../tutorials/vqe_with_estimator.ipynb:122
msgid "Here we define the problem instance for our VQE algorithm. Although the problem in question can come from a variety of domains, the form for execution through Runtime is the same. Qiskit provides a convenience class for expressing Hamiltonians in Pauli form, and a collection of widely used ansatz circuits in the ``qiskit.circuit.library``."
msgstr "ここでは、VQE アルゴリズムの問題インスタンスを定義します。問題の領域は様々ですが、Runtime を通して実行される形式は同じです。Qiskit はハミルトニアンをパウリ形式で表現するための便利なクラスと、広く使用されている ansatz 回路のコレクションを ``qiskit.circuit.library`` で提供しています。"

#: ../../tutorials/vqe_with_estimator.ipynb:124
msgid "Here, our example Hamiltonian is derived from a quantum chemistry problem"
msgstr "ここでは、量子化学の問題からハミルトニアンを導出します。"

#: ../../tutorials/vqe_with_estimator.ipynb:147
msgid "and our choice of ansatz is the ``EfficientSU2`` that, by default, linearly entangles qubits, making it ideal for quantum hardware with limited connectivity."
msgstr "そして ansatz として選択する ``EfficientSU2`` は、デフォルトで量子ビットを線形にエンタングルするため、接続性の限られた量子ハードウェアに最適です。"

#: ../../tutorials/vqe_with_estimator.ipynb:183
msgid "From the previous figure we see that our ansatz circuit is defined by a vector of parameters, :math:`\\theta_{i}`, with the total number given by:"
msgstr "上の図から、ansatz 回路はパラメーターのベクトル、:math:`\\theta_{i}` で定義され、その総数は次式で与えられます："

#: ../../tutorials/vqe_with_estimator.ipynb:231
msgid "VQE cost function and minimization"
msgstr "VQEのコスト関数と最小化"

#: ../../tutorials/vqe_with_estimator.ipynb:233
msgid "Like many classical optimization problems, the solution to a VQE problem can be formulated as minimization of a scalar cost function. By definition, VQE looks to find the ground state solution to a Hamiltonian by optimizing the ansatz circuit parameters to minimize the expectation value (energy) of the Hamiltonian. With the Runtime ``Estimator`` directly taking a Hamiltonian and parameterized ansatz, and returning the necessary energy, The cost function for a VQE instance is quite simple:"
msgstr "多くの古典的な最適化問題と同様に、VQE問題の解はスカラーのコスト関数の最小化として定式化することができます。定義によれば、VQEはハミルトニアンの期待値（エネルギー）を最小化するために ansatz 回路のパラメーターを最適化することによって、ハミルトニアンの基底状態の解を見つけることを目的としています。Runtime ``Estimator`` がハミルトニアンとパラメーター化された ansatz を直接受け取り、必要なエネルギーを返すので、VQEインスタンスのコスト関数は非常にシンプルです："

#: ../../tutorials/vqe_with_estimator.ipynb:267
msgid "Note that, in addition to the array of optimization parameters that must be the first argument, we use additional arguments to pass the terms needed in the cost function."
msgstr "最初の引数でなければならない最適化パラメーターの配列に加えて、コスト関数に必要な項を渡すために追加の引数を使用することに注意してください。"

#: ../../tutorials/vqe_with_estimator.ipynb:278
msgid "We are now free to use a classical optimizer of our choice to minimize our cost function. Here we use the `COBYLA routine from SciPy through the ``minimize`` function <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html>`__. Note that, when running on real quantum hardware, the choice of optimizer is important as not all optimizers handle noisy cost function landscapes equally well."
msgstr "コスト関数を最小化するために、古典オプティマイザーを自由に使うことができます。ここでは `SciPyのCOBYLAルーチンを ``minimize`` 関数 <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html>`__ を通して使用します。実際の量子ハードウェア上で実行する場合、どのオプティマイザーも同じようにノイズの多いコスト関数を扱えるわけではないので、オプティマイザーの選択は重要であることに注意してください。"

#: ../../tutorials/vqe_with_estimator.ipynb:280
msgid "To begin the routine, we start by specifying a random initial set of parameters,"
msgstr "ルーチンを開始するために、まずランダムな初期パラメーターセットを指定します。"

#: ../../tutorials/vqe_with_estimator.ipynb:301
msgid "and because we are sending a large number of jobs that we would like to execute together, here we use a ``Session`` to execute all the generated circuits in one block. Here ``args`` is the standard SciPy way to supply the additional parameters needed by the cost function."
msgstr "一緒に実行したいジョブを大量に送信するため、ここでは ``Session`` を使用して、生成されたすべての回路を1つのブロックで実行します。ここで ``args`` は SciPy の標準的な方法で、コスト関数が必要とする追加パラメーターを与えます。"

#: ../../tutorials/vqe_with_estimator.ipynb:324
msgid "At the terminus of this routine we have a result in the standard SciPy ``OptimizeResult`` format. From this we see that it took ``nfev`` number of cost function evaluations to obtain the solution vector of parameter angles (``x``) that, when plugged into the ansatz circuit, yield the approximate ground state solution we were looking for."
msgstr "このルーチンの最後で、標準的なSciPyの ``OptimizeResult`` フォーマットの結果が得られます。この結果から、角度パラメーター (``x``) の解ベクトルを得るために、 ``nfev`` 回のコスト関数の評価が必要であり、それを ansatz 回路に差し込むと、求めていた基底状態の近似解が得られることがわかります。"

#: ../../tutorials/vqe_with_estimator.ipynb:389
msgid "Adding a callback function"
msgstr "コールバック関数の追加"

#: ../../tutorials/vqe_with_estimator.ipynb:391
msgid "As it stands now, we are unable to save intermediate results from the iteration process, view the value of the cost function per iteration, nor are we able to monitor the progress of the routine. Callback functions are a standard way for users to obtain additional information about the status of an iterative algorithm. The standard SciPy callback routine allows for returning only the interim vector at each iteration. However, it is possible to do much more than this. Here we show how to use a mutable object, such as a dictionary, to store the current vector at each iteration, for example in case we need to restart the routine due to failure, and also return the current iteration number and average time per iteration."
msgstr "現状では、繰り返し処理の中間結果を保存したり、繰り返しごとのコスト関数の値を表示したり、ルーチンの進行状況を監視したりすることはできません。コールバック関数は、ユーザーが反復アルゴリズムの状態に関する追加情報を得るための標準的な方法です。標準的なSciPyのコールバックルーチンでは、各反復で中間ベクトルだけを返すことができます。しかし、それ以上のことも可能です。ここでは、辞書のような変更可能なオブジェクトを使用して、各反復の現在のベクトルを保存し、例えば、失敗によりルーチンを再起動する必要がある場合に、現在の反復回数と反復ごとの平均時間を返す方法を示します。"

#: ../../tutorials/vqe_with_estimator.ipynb:466
msgid "We can now repeat the experiment setting the ``callback`` argument in ``minimize`` with our function:"
msgstr "これで、関数を使用して ``minimize`` に ``callback`` 引数を設定して実験を繰り返すことができます："

#: ../../tutorials/vqe_with_estimator.ipynb:536
msgid "If the procedure terminates correctly, then the ``prev_vector`` and ``iters`` values in our ``callback_dict`` dictionary should be equal to the solution vector and total number of function evaluations, respectively. This is easy to verify:"
msgstr "このプロシージャーが正しく終了すれば、 ``callback_dict`` 辞書内の ``prev_vector`` と ``iters`` の値は、それぞれ解ベクトルと関数評価の総数に等しくなるはずです。これは簡単に確認でます："

#: ../../tutorials/vqe_with_estimator.ipynb:617
msgid "We can also now view the progress towards convergence as monitored by the cost history at each iteration:"
msgstr "また、各反復におけるコスト履歴によってモニターされる収束への進捗状況を見ることもできるようになりました："


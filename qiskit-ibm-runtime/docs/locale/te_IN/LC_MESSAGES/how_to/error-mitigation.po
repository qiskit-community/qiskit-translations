msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-12 19:16+0000\n"
"PO-Revision-Date: 2023-09-12 20:11\n"
"Last-Translator: \n"
"Language: te\n"
"Language-Team: Telugu\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: te\n"
"X-Crowdin-File: /main/qiskit-ibm-runtime/docs/locale/en/LC_MESSAGES/how_to/error-mitigation.po\n"
"X-Crowdin-File-ID: 9917\n"

#: ../../how_to/error-mitigation.rst:2
msgid "Configure error mitigation"
msgstr "లోపం తగ్గింపును కాన్ఫిగర్ చేయండి"

#: ../../how_to/error-mitigation.rst:6
msgid "Error mitigation techniques allow users to mitigate circuit errors by modeling the device noise at the time of execution. This typically results in quantum pre-processing overhead related to model training and classical post-processing overhead to mitigate errors in the raw results by using the generated model."
msgstr ""

#: ../../how_to/error-mitigation.rst:8
msgid "The error mitigation techniques built in to primitives are advanced resilience options.   To specify these options, use the ``resilience_level`` option when submitting your job."
msgstr ""

#: ../../how_to/error-mitigation.rst:10
msgid "The resilience level specifies how much resilience to build against errors. Higher levels generate more accurate results, at the expense of longer processing times. Resilience levels can be used to configure the cost/accuracy trade-off when applying error mitigation to your primitive query. Error mitigation reduces errors (bias) in results by processing the outputs from a collection, or ensemble, of related circuits. The degree of error reduction depends on the method applied. The resilience level abstracts the detailed choice of error mitigation method to allow users to reason about the cost/accuracy trade that is appropriate to their application."
msgstr ""

#: ../../how_to/error-mitigation.rst:12
msgid "Given this, each level corresponds to a method or methods with increasing level of quantum sampling overhead to enable you experiment with different time-accuracy tradeoffs.  The following table shows you which levels and corresponding methods are available for each of the primitives."
msgstr ""

#: ../../how_to/error-mitigation.rst:15
msgid "Error mitigation is task specific so the techniques you are able to apply vary based whether you are sampling a distribution or generating expectation values."
msgstr ""

#: ../../how_to/error-mitigation.rst:18
msgid "Resilience Level"
msgstr "స్థితిస్థాపకత స్థాయి"

#: ../../how_to/error-mitigation.rst:18
msgid "Definition"
msgstr "నిర్వచనం"

#: ../../how_to/error-mitigation.rst:18
msgid "Estimator"
msgstr "ఎస్టిమేటర్"

#: ../../how_to/error-mitigation.rst:18
msgid "Sampler"
msgstr "సామ్ప్లెర్"

#: ../../how_to/error-mitigation.rst:20
msgid "0"
msgstr "0"

#: ../../how_to/error-mitigation.rst:20
msgid "No mitigation"
msgstr "తగ్గింపు లేదు"

#: ../../how_to/error-mitigation.rst:20
msgid "None"
msgstr "ఏదీ లేదు"

#: ../../how_to/error-mitigation.rst:22
msgid "1 [Default]"
msgstr "1 [Default]"

#: ../../how_to/error-mitigation.rst:22
msgid "Minimal mitigation costs: Mitigate error associated with readout errors"
msgstr "కనిష్ట ఉపశమన ఖర్చులు: రీడౌట్ లోపాలతో అనుబంధించబడిన లోపాన్ని తగ్గించండి"

#: ../../how_to/error-mitigation.rst:22
msgid "Twirled Readout Error eXtinction (:ref:`TREX <TREX>`)"
msgstr "ట్విర్లెడ్ ​​రీడౌట్ ఎర్రర్ ఎక్స్‌టింక్షన్ (:ref:` TREX <TREX>`)"

#: ../../how_to/error-mitigation.rst:22
msgid "M3"
msgstr "M3"

#: ../../how_to/error-mitigation.rst:25
msgid "2"
msgstr "2"

#: ../../how_to/error-mitigation.rst:25
msgid "Medium mitigation costs. Typically reduces bias in estimators, but is not guaranteed to be zero bias."
msgstr "మధ్యస్థ ఉపశమన ఖర్చులు. సాధారణంగా అంచనా వేసేవారిలో పక్షపాతాన్ని తగ్గిస్తుంది, కానీ జీరో బయాస్ అని హామీ ఇవ్వబడదు."

#: ../../how_to/error-mitigation.rst:25
msgid "Zero Noise Extrapolation (:ref:`ZNE <ZNE>`)"
msgstr "జీరో నాయిస్ ఎక్స్‌ట్రాపోలేషన్ (:ref:` ZNE <ZNE>`)"

#: ../../how_to/error-mitigation.rst:25 ../../how_to/error-mitigation.rst:28
msgid "---"
msgstr "---"

#: ../../how_to/error-mitigation.rst:28
msgid "3"
msgstr "3"

#: ../../how_to/error-mitigation.rst:28
msgid "Heavy mitigation with layer sampling. Theoretically expected to deliver zero bias estimators."
msgstr "లేయర్ సాంప్లింగ్తో భారీ ఉపశమనం. సిద్ధాంతపరంగా జీరో బయాస్ ఎస్టిమేటర్‌లను అందించాలని భావిస్తున్నారు."

#: ../../how_to/error-mitigation.rst:28
msgid "Probabilistic Error Cancellation (:ref:`PEC <PEC>`)"
msgstr "సంభావ్యత లోపం రద్దుచేయబడింది (:ref:` PEC <PEC>`)"

#: ../../how_to/error-mitigation.rst:33
msgid "Resilience levels are currently in beta so sampling overhead and solution quality will vary from circuit to circuit. New features, advanced options and management tools will be released on a rolling basis. Specific error mitigation methods are not guaranteed to be applied at each resilience level."
msgstr ""

#: ../../how_to/error-mitigation.rst:36
msgid "Configure the Estimator with resilience levels"
msgstr "ఎస్టిమేటర్‌ను స్థితిస్థాపకత స్థాయిలతో కాన్ఫిగర్ చేయండి"

#: ../../how_to/error-mitigation.rst:43
msgid "No error mitigation is applied to the user program."
msgstr "వినియోగదారు ప్రోగ్రామ్‌కు ఎటువంటి లోపం తగ్గింపు వర్తించదు."

#: ../../how_to/error-mitigation.rst:56
msgid "Level 1 applies error mitigation methods that particularly address readout errors. In the Estimator, we apply a model-free technique known as Twirled Readout Error eXtinction (TREX). It reduces measurement error by diagonalizing the noise channel associated with measurement by randomly flipping qubits through X gates immediately before measurement, and flipping the corresponding measured bit if an X gate was applied. A rescaling term from the diagonal noise channel is learned by benchmarking random circuits initialized in the zero state. This allows the service to remove bias from expectation values that result from readout noise. This approach is described further in `Model-free readout-error mitigation for quantum expectation values <https://arxiv.org/abs/2012.09738>`__."
msgstr ""

#: ../../how_to/error-mitigation.rst:69
msgid "Level 2 uses the Zero Noise Extrapolation method (ZNE) which computes an expectation value of the observable for different noise factors (amplification stage) and then uses the measured expectation values to infer the ideal expectation value at the zero-noise limit (extrapolation stage). This approach tends to reduce errors in expectation values, but is not guaranteed to produce an unbiased result."
msgstr ""

#: ../../how_to/error-mitigation.rst:74
msgid "This image shows a graph that compares the noise amplification factor to expectation values."
msgstr ""

#: ../../how_to/error-mitigation.rst:74
msgid "Illustration of the ZNE method"
msgstr "ZNE పద్ధతి యొక్క ఉదాహరణ"

#: ../../how_to/error-mitigation.rst:76 ../../how_to/error-mitigation.rst:98
msgid "The overhead of this method scales with the number of noise factors. The default settings sample the expectation value at three noise factors, leading to a roughly 3x overhead when employing this resilience level."
msgstr ""

#: ../../how_to/error-mitigation.rst:89
msgid "Level 3 enables the Probabilistic Error Cancellation (PEC) method. This approach mitigates error by learning and inverting a sparse noise model that is able to capture correlated noise. PEC returns an unbiased estimate of an expectation value so long as learned noise model faithfully represents the actual noise model at the time of mitigation.  In practice, the experimental procedure for learning the noise model has ambiguities due to certain error terms that cannot be independently distinguished. These are resolved by a symmetry assumption, which depending on the true underlying noise may lead a biased estimate of the mitigated expectation values due to using an imperfect noise model."
msgstr ""

#: ../../how_to/error-mitigation.rst:91
msgid "The Qiskit Runtime primitive implementation of PEC specifically addresses noise in self-inverse two-qubit gates, so it first *stratifies* each input circuit into an alternating sequence of simultaneous 1-qubit gates followed by a layer of simultaneous 2-qubit gates. Then it learns the noise model associated with each unique 2-qubit gate layer."
msgstr ""

#: ../../how_to/error-mitigation.rst:96
msgid "This image shows a stratified circuit."
msgstr ""

#: ../../how_to/error-mitigation.rst:96
msgid "This is an example of a `stratified` circuit, where the layers of two-qubit gates are labeled layer 1 through n. Note that each :math:`U_l` is composed of two-qubit gates on the native connectivity graph of the quantum processor. The open boxes represent arbitrary single-qubit gates."
msgstr ""

#: ../../how_to/error-mitigation.rst:100
msgid "PEC uses a quasi-probability method to mimic the effect of inverting the learned noise. This requires sampling from a randomized circuit family associated with the user’s original circuit. Applying PEC will increase the variability of the returned expectation value estimates unless the number of samples per circuit is also increased for both input and characterization circuits. The amount of samples required to counter this variability scales exponentially with the noise strength of the mitigated circuit."
msgstr ""

#: ../../how_to/error-mitigation.rst:102
msgid "How this works:"
msgstr "ఇది ఎలా పని చేస్తుంది:"

#: ../../how_to/error-mitigation.rst:104
msgid "When estimating an unmitigated Pauli observable :math:`\\langle P\\rangle` the standard error in the estimated expectation value is given by :math:`\\frac{1}{\\sqrt{N_{\\mbox{shots}}}}\\left(1- \\langle P\\rangle^2\\right)` where :math:`N_{\\mbox{shots}}` is the number of shots used to estimate :math:`\\langle P\\rangle`. When applying PEC mitigation, the standard error becomes :math:`\\sqrt{\\frac{S}{N_{\\mbox{samples}}}}\\left(1- \\langle P\\rangle^2\\right)` where :math:`N_{\\mbox{samples}}` is the number of PEC samples."
msgstr ""

#: ../../how_to/error-mitigation.rst:106
msgid "The sampling overhead scales exponentially with a parameter that characterizes the collective noise of the input circuit. As the Qiskit Runtime primitive learns the noise of your circuit, it will return metadata about the sampling overhead associated with that particular layer.  Let's label the overhead of layer :math:`l` as :math:`\\gamma_l`. Then the total sampling overhead for mitigating your circuit is the product of all the layer overheads, that is:"
msgstr ""

#: ../../how_to/error-mitigation.rst:108
msgid ":math:`S = \\prod_l \\gamma_l`"
msgstr ":math:` S = \\prod_l \\gamma_l `"

#: ../../how_to/error-mitigation.rst:110
msgid "When the Estimator completes the model-learning phase of the primitive query, it will return metadata about the total sampling overhead for circuit."
msgstr ""

#: ../../how_to/error-mitigation.rst:112
msgid "Depending on the precision required by your application, you will need to scale the number of samples accordingly. The following plot illustrates the relationship between estimator error and number of circuit samples for different total sampling overheads."
msgstr ""

#: ../../how_to/error-mitigation.rst:-1
msgid "This image shows that sampling overhead goes down as the number of samples increases."
msgstr ""

#: ../../how_to/error-mitigation.rst:117
msgid "Note that the number of samples required to deliver a desired accuracy is not known before the primitive query because the mitigation scaling factor is discovered during the learning phase of PEC."
msgstr ""

#: ../../how_to/error-mitigation.rst:119
msgid "We suggest starting with short depth circuits to get a feel for the scaling of the sampling overhead of PEC before attempting larger problems."
msgstr ""

#: ../../how_to/error-mitigation.rst:126
msgid "Example"
msgstr "ఉదాహరణ"

#: ../../how_to/error-mitigation.rst:128
msgid "The Estimator interface lets users seamlessly work with the variety of error mitigation methods to reduce error in expectation values of observables. The following code uses Zero Noise Extrapolation by simply setting ``resilience_level 2``."
msgstr ""

#: ../../how_to/error-mitigation.rst:147
msgid "As you increase the resilience level, you will be able to use additional methods to improve the accuracy of your result. However, because the methods become more advanced with each level, they require additional sampling overhead (time) to generate more accurate expectation values. Note that higher resilience levels do not guarantee better quality. Higher levels only mean greater overhead. Each method has its strengths and weaknesses. For example, TREX (Twirled Readout Error eXtinction) is good for shallow circuits because of its readout error mitigation whereas ZNE (Zero Noise Extrapolation) is good for deeper circuits. PEC can mitigate arbitrary errors but may not work in practice because of its large overhead."
msgstr ""

#: ../../how_to/error-mitigation.rst:151
msgid "Configure Sampler with resilience levels"
msgstr ""

#: ../../how_to/error-mitigation.rst:154
msgid "The Sampler default resilience setting (level 1) enables readout error mitigation to allow users to generate mitigated quasi-probability distributions."
msgstr ""

#: ../../how_to/error-mitigation.rst:161
msgid "Level 1 uses matrix-free measurement mitigation (M3) routine to mitigate readout error. M3 works in a reduced subspace defined by the noisy input bit strings that are to be corrected. Because the number of unique bit strings can be much smaller than the dimensionality of the full multi-qubit Hilbert space, the resulting linear system of equations is nominally much easier to solve."
msgstr ""

#: ../../how_to/error-mitigation.rst:166
msgid "This image illustrates the M3 routine."
msgstr ""

#: ../../how_to/error-mitigation.rst:166
msgid "Illustration of the M3 method"
msgstr ""

#: ../../how_to/error-mitigation.rst:185
msgid "Advanced resilience options"
msgstr ""

#: ../../how_to/error-mitigation.rst:187
msgid "You can tune advanced options to configure your resilience strategy further. These methods can be used alongside resilience levels where you change the specific options of interest and let your previously set resilience level manage the rest."
msgstr ""

#: ../../how_to/error-mitigation.rst:189
msgid "As a part of the beta release of the resilience options, users will be able configure ZNE by using the following advanced options. We will soon add options to tune other resilience levels that include PEC."
msgstr ""

#: ../../how_to/error-mitigation.rst:192
msgid "Options"
msgstr ""

#: ../../how_to/error-mitigation.rst:192
msgid "Inputs"
msgstr ""

#: ../../how_to/error-mitigation.rst:192
msgid "Description"
msgstr ""

#: ../../how_to/error-mitigation.rst:194
msgid "options.resilience.noise_amplifier(Optional[str])"
msgstr ""

#: ../../how_to/error-mitigation.rst:196
msgid "select your amplification strategy"
msgstr ""

#: ../../how_to/error-mitigation.rst:194
msgid "``TwoQubitAmplifier`` [Default]"
msgstr ""

#: ../../how_to/error-mitigation.rst:194
msgid "Amplifies noise of all two qubit gates by performing local gate folding."
msgstr ""

#: ../../how_to/error-mitigation.rst:197
msgid "``CxAmplifier``"
msgstr ""

#: ../../how_to/error-mitigation.rst:197
msgid "Amplifies noise of all CNOT gates by performing local gate folding."
msgstr ""

#: ../../how_to/error-mitigation.rst:200
msgid "``LocalFoldingAmplifier``"
msgstr ""

#: ../../how_to/error-mitigation.rst:200
msgid "Amplifies noise of all gates by performing local gate folding."
msgstr ""

#: ../../how_to/error-mitigation.rst:203
msgid "``GlobalFoldingAmplifier``"
msgstr ""

#: ../../how_to/error-mitigation.rst:203
msgid "Amplifies noise of the input circuit by performing global folding of the entire input circuit."
msgstr ""

#: ../../how_to/error-mitigation.rst:206
msgid "options.resilience.noise_factors((Optional[Sequence[float]])"
msgstr ""

#: ../../how_to/error-mitigation.rst:206
msgid "(1, 3, 5) [Default]"
msgstr ""

#: ../../how_to/error-mitigation.rst:206
msgid "Noise amplification factors, where `1` represents the baseline noise. They all need to be greater than or equal to the baseline."
msgstr ""

#: ../../how_to/error-mitigation.rst:210
msgid "options.resilience.extrapolator(Optional[str])"
msgstr ""

#: ../../how_to/error-mitigation.rst:210
msgid "``LinearExtrapolator`` [Default]"
msgstr ""

#: ../../how_to/error-mitigation.rst:210
msgid "Polynomial extrapolation of degree one."
msgstr ""

#: ../../how_to/error-mitigation.rst:212
msgid "``QuadraticExtrapolator``"
msgstr ""

#: ../../how_to/error-mitigation.rst:212
msgid "Polynomial extrapolation of degree two and lower."
msgstr ""

#: ../../how_to/error-mitigation.rst:214
msgid "``CubicExtrapolator``"
msgstr ""

#: ../../how_to/error-mitigation.rst:214
msgid "Polynomial extrapolation of degree three and lower."
msgstr ""

#: ../../how_to/error-mitigation.rst:216
msgid "``QuarticExtrapolator``"
msgstr ""

#: ../../how_to/error-mitigation.rst:216
msgid "Polynomial extrapolation of degree four and lower."
msgstr ""

#: ../../how_to/error-mitigation.rst:220
msgid "Example of adding ``resilience_options`` into your estimator session"
msgstr ""


# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Qiskit Development Team
# This file is distributed under the same license as the Qiskit Runtime IBM
# Client package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit Runtime IBM Client \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-30 17:25+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.12.1\n"

#: ../../tutorials/user-transpiled-circuits.ipynb:9
msgid ""
"This page was generated from `docs/tutorials/user-transpiled-"
"circuits.ipynb`__."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:9
msgid "Submitting user-transpiled circuits using primitives"
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:11
msgid ""
"To get the best performance from your circuits, the Qiskit Runtime "
"service will pass all circuits through Qiskit's transpiler before running"
" them. While this is usually a good thing, we might sometimes want to "
"disable this by passing the argument ``skip_transpilation=True`` to the "
"primitive we're using."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:13
msgid ""
"For example, we may know better than the transpiler in some cases, or "
"want to target a specific subset of qubits on a specific device. In this "
"tutorial, we'll disable automatic transpilation to test the performance "
"of different transpiler settings. This example will take you through the "
"full process of creating, transpiling, and submitting circuits."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:16
msgid "Transpiling circuits for IBM Quantum devices"
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:18
msgid ""
"In the following code cell, we create a small circuit that our transpiler"
" will try to optimize. In this example, we create a circuit that carries "
"out Grover's algorithm, with an oracle that marks the state ``111``. We "
"then simulate the ideal distribution (what we'd expect to measure if we "
"ran this on a perfect quantum computer, an infinite number of times) for "
"comparison later."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:64
msgid ""
"Next, we need to choose a backend to transpile for. In the following "
"cell, we create a service instance, which we'll use to start a session, "
"and get the backend object, which contains information for the "
"transpiler. Since the transpilation process depends on the device, we'll "
"ask the runtime service for a specific device by name. In this example, "
"we'll use ``ibm_algiers``, which is only available through IBM Cloud."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:88
msgid ""
"Next, we transpile the circuits for our backend. We're going to compare "
"the performance of the transpiler with ``optimization_level`` set to "
"``0`` (lowest) against ``3`` (highest). The lowest optimization level "
"just does the bare minimum needed to get the circuit running on the "
"device; it maps the circuit qubits to the device qubits, and adds swaps "
"gates to allow all 2-qubit operations. The highest optimization level is "
"much smarter and uses lots of tricks to reduce the overall gate count. "
"Since multi-qubit gates have high error rates, and qubits decohere over "
"time, the shorter circuits should give better results."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:91
msgid ""
"In the following cell, we transpile ``qc`` for both values of "
"``optimization_level``, print the number of CNOT gates, and add the "
"transpiled circuits to a list. Some of the transpiler's algorithms are "
"randomized, so we set a seed for reproducibility."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:150
msgid ""
"Since CNOTs usually have a high error rate, the circuit transpiled with "
"``optimization_level=3`` should perform much better."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:152
msgid ""
"Another way we can improve performance is through `dynamic decoupling "
"<https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.DynamicalDecoupling.html>`__,"
" where we apply a sequence of gates to idling qubits. This cancels out "
"some unwanted interactions with the environment. In the following cell, "
"we add dynamic decoupling to the circuit transpiled with "
"``optimization_level=3``, and add it to our list."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:189
msgid "Run user-transpiled circuits using Qiskit Runtime"
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:191
msgid ""
"At this point, we have a list of circuits (named ``circuits``) transpiled"
" for ``ibm_algiers``. In the following cell, we create an instance of the"
" sampler primitive, and start a session using the context manager (``with"
" ...:``), which automatically opens and closes the session for us. This "
"is where we pass the ``skip_transpilation=True`` argument."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:193
msgid ""
"Within the context manager, we sample the circuits and store the results "
"to ``result``."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:223
msgid ""
"Finally, we can plot the results from the device runs against the ideal "
"distribution. You can see the results with ``optimization_level=3`` are "
"closer to the ideal distribution due to the lower gate count, and "
"``optimization_level=3 + dd`` is even closer due to the dynamic "
"decoupling we applied."
msgstr ""

#: ../../tutorials/user-transpiled-circuits.ipynb:265
msgid ""
"We can confirm this by computing the `Hellinger fidelity "
"<https://qiskit.org/documentation/stubs/qiskit.quantum_info.hellinger_fidelity.html>`__"
" between each set of results and the ideal distribution (higher is "
"better, and 1 is perfect fidelity)."
msgstr ""


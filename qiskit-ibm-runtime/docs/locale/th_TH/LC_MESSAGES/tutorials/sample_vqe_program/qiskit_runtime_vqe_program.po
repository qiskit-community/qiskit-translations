msgid ""
msgstr ""
"Project-Id-Version: qiskit-docs\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-10 16:30+0000\n"
"PO-Revision-Date: 2022-11-10 17:03\n"
"Last-Translator: \n"
"Language-Team: Thai\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: qiskit-docs\n"
"X-Crowdin-Project-ID: 369271\n"
"X-Crowdin-Language: th\n"
"X-Crowdin-File: /master/qiskit-ibm-runtime/docs/locale/en/LC_MESSAGES/tutorials/sample_vqe_program/qiskit_runtime_vqe_program.po\n"
"X-Crowdin-File-ID: 9826\n"
"Language: th_TH\n"

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:9
msgid "This page was generated from `docs/tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb`__."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:9
msgid "Creating Custom Programs for Qiskit Runtime"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:15
msgid "Paul Nation"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:25
msgid "IBM Quantum Partners Technical Enablement Team"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:31
msgid "Here we will demonstrate how to create, upload, and use a custom Program for Qiskit Runtime. As the utility of the Runtime execution engine lies in its ability to execute many quantum circuits with low latencies, this tutorial will show how to create your own Variational Quantum Eigensolver (VQE) program from scratch."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:43
msgid "Prerequisites"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:45
msgid "You must have the latest Qiskit installed."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:46
msgid "You must have either an IBM Cloud or an IBM Quantum account that can access Qiskit Runtime."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:58
msgid "Current limitations"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:60
msgid "The runtime execution engine currently has the following limitations that must be kept in mind:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:62
msgid "The Docker images used by the runtime include only Qiskit and its dependencies, with few exceptions. One exception is the inclusion of the ``mthree`` measurement mitigation package."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:64
msgid "For security reasons, the runtime cannot make internet calls outside of the environment."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:66
msgid "As Qiskit Runtime matures, these limitations will be removed."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:78
msgid "Simple VQE"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:80
msgid "VQE is an hybrid quantum-classical optimization procedure that finds the lowest eigenstate and eigenenergy of a linear system defined by a given Hamiltonian of Pauli operators. For example, consider the following two-qubit Hamiltonian:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:82
msgid "H = A X_{1}\\otimes X_{0} + A Y_{1}\\otimes Y_{0} + A Z_{1}\\otimes Z_{0},"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:87
msgid "where :math:`A` is numerical coefficient and the subscripts label the qubits on which the operators act. The zero index being farthest right is the ordering used in Qiskit. The Pauli operators tell us which measurement basis to to use when measuring each of the qubits."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:89
msgid "We want to find the ground state (lowest energy state) of this Hamiltonian, and the associated eigenvector. To do this we must start at a given initial state and iteratively vary the parameters that define this state using a classical optimizer, such that the computed energies of subsequent steps are nominally lower than those previously. The parameterized state of the system is defined by an ansatz quantum circuit that should have non-zero support in the direction of the ground state. Because in general we do not know the solution, the choice of ansatz circuit can be highly problem-specific with a form dictated by additional information. For further information about variational algorithms, we point the reader to `Nature Reviews Physics volume 3, 625 (2021) <https://doi.org/10.1038/s42254-021-00348-9>`__."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:92
msgid "Thus we need at least the following inputs to create our VQE quantum program:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:94
msgid "A representation of the Hamiltonian that specifies the problem."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:96
msgid "A choice of parameterized ansatz circuit, and the ability to pass configuration options, if any."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:98
msgid "However, the following are also beneficial inputs that users might want to have:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:100
msgid "Add the ability to pass an initial state."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:102
msgid "Vary the number of shots that are taken."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:104
msgid "Ability to select which classical optimizer is used, and set configuraton values, if any."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:106
msgid "Ability to turn on and off measurement mitigation."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:118
msgid "Specifying the form of the input values"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:120
msgid "All inputs to runtime programs must be serializable objects. That is to say, whatever you pass into a runtime program must be able to be converted to JSON format. It is thus beneficial to keep inputs limited to basic data types and structures unless you have experience with custom object serialization, or they are common Qiskit types such as ``QuantumCircuit`` etc that the built-in ``RuntimeEncoder`` can handle. Fortunately, the VQE program described above can be made out of simple Python components."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:123
msgid "First, it is possible to represent any Hamiltonian using a list of values with each containing the numerical coefficeint for each term and the string representation for the Pauli operators. For the above example, the ground state energy with :math:`A=1` is :math:`-3` and we can write it as:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:144
msgid "Next we have to provide the ability to specify the parameterized Ansatz circuit. Here we will take advange of the fact that many ansatz circuits are pre-defined in the Qiskit Circuit Library. Examples can be found in the `N-local circuits section <https://qiskit.org/documentation/apidoc/circuit_library.html#n-local-circuits>`__."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:146
msgid "We would like the user to be able to select between ansatz options such as: ``NLocal``, ``TwoLocal``, and ``EfficientSU2``. We could have the user pass the whole ansatz circuit to the program; however, in order to reduce the size of the upload we will pass the ansatz by name. In the runtime program, we can take this name and get the class that it corresponds to from the library using, for example,"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:169
msgid "For the ansatz configuration, we will pass a simple ``dict`` of values."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:181
msgid "Optionals"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:183
msgid "If we want to add the ability to pass an initial state, then we will need to add the ability to pass a 1D list/ NumPy array. Because the number of parameters depends on the ansatz and its configuration, the user would have to know what ansatz they are doing ahead of time."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:185
msgid "Selecting a number of shots requires simply passing an integer value."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:187
msgid "Here we will allow selecting a classical optimizer by name from those in SciPy, and a ``dict`` of configuration parameters. Note that for execution on an actual system, the noise inherent in todayâ€™s quantum systems makes having a stochastic optimizer crucial to success. SciPy does not have such a choice, and the one built into Qiskit is wrapped in such a manner as to make it difficult to use elsewhere. As such, here we will use an SPSA optimizer written to match the style of those in SciPy. This function is given in `Appendix A <#Appendix-A>`__."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:199
msgid "Finally, for measurement error mitigation we can simply pass a boolean (True/False) value."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:211
msgid "Main program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:213
msgid "We are now in a position to start building our main program. However, before doing so we point out that it makes the code cleaner to make a separate function that takes strings of Pauli operators that define our Hamiltonian and convert them to a list of circuits with single-qubit gates that change the measurement basis for each qubit, if needed. This function is given in `Appendix B <#Appendix-B>`__."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:225
msgid "Required signature"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:227
msgid "Every runtime program is defined via the ``main`` function, and must have the following input signature:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:233
msgid "where ``backend`` is the backend that the program is to be executed on, and ``user_message`` is the class by which interim (and possibly final) results are communicated back to the user. After these two items, we add our program-specific arguments and keyword arguments."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:245
msgid "The main VQE program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:247
msgid "Here is the main program for our sample VQE. What each element of the function does is written in the comments before the element appears."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:249
msgid "This program uses the ``mthree`` measurement mitigation package. You can install the package via ``pip install mthree``."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:441
msgid "Local testing"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:447
msgid "Important: You need to execute the code blocks in Appendices A and B before continuing."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:453
msgid "We can test whether our routine works by simply calling the ``main`` function with a backend instance, a ``UserMessenger``, and sample arguments."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:586
msgid "Having executed the above, we see that there are 5 parameter arrays returned, one for each callback, along with the final optimization result. The parameter arrays are the interim results, and the ``UserMessenger`` object prints these values to the cell output. The output itself is the answer we obtained, expressed as a SciPy ``OptimizerResult`` object."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:598
msgid "Program metadata"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:600
msgid "Program metadata is essentially the docstring for a runtime program. It describes overall program information such as the program ``name``, ``description``, and the ``max_execution_time`` the program is allowed to run, as well as details the inputs and the outputs the program expects. At a bare minimum the values described above are required"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:626
msgid "It is important to set the ``max_execution_time`` high enough so that your program does not get terminated unexpectedly. Additionally, one should make sure that interim results are sent back to the user so that, if something does happen, the user can start where they left off."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:628
msgid "It is, however, good form to detail the parameters and return types, as well as interim results. That being said, if making a runtime intended to be used by others, this information would also likely be mirrored in the signature of a function or class that the user would interact with directly; end users should not directly call runtime programs. We will see why below. Nevertheless, let us add to our metadata. First, the ``parameters`` section details the inputs the user is able to pass:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:689
msgid "Next, the ``return_values`` section tells about the return types:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:714
msgid "and finally let us specify what comes back when an interim result is returned:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:740
msgid "Uploading the program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:742
msgid "We now have all the ingredients needed to upload our program. To do so we need to collect all of our code in one file, here called ``sample_vqe.py`` for uploading. This limitation will be removed in later versions of Qiskit Runtime. Alternatively, if the entire code is contained within a single Jupyter notebook cell, this can be done using the magic function"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:748
msgid "To actually upload the program we need to initialize a Qiskit Runtime service:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:772
msgid "Program upload"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:774
msgid "The call to ``program_upload`` takes the target Python file as ``data`` and the metadata as inputs."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:821
msgid "Here the ``upload_program()`` method returns a ``program_id``, which is how you should reference your program."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:833
msgid "Program information"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:835
msgid "We can query the program for information and see that our metadata is correctly being attached:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1026
msgid "Deleting a program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1028
msgid "If you make a mistake and need to delete and/or re-upload the program, you can run the following, passing the ``program_id``:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1050
msgid "Running the program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1053
msgid "Specify parameters"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1055
msgid "To run the program we need to specify the ``options`` that are used in the runtime environment (not the program variables). The target backend is defined via the ``backend_name`` field."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1076
msgid "The ``inputs`` dictionary is used to pass arguments to the ``main`` function itself. For example:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1100
msgid "Execute the program"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1102
msgid "We now can execute the program and grab the result."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1182
msgid "A few things need to be pointed out. First, we did not get back any interim results, and second, the return object is a plain dictionary. This is because we did not listen for the return results, and we did not tell the job how to format the return result."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1194
msgid "Listening for interim results and final result"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1196
msgid "To listen for interim results and final result we need to pass a callback function to ``service.run`` that stores the results. The callback takes two arguments ``job_id`` and the returned data:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1221
msgid "Executing again we get:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1336
msgid "Formatting the returned results"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1338
msgid "In order to format the return results into the desired format, we need to specify a decoder. This decoder must have a ``decode`` method that gets called to do the actual conversion. In our case ``OptimizeResult`` is a simple sub-class of ``dict`` so the formatting is simple."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1367
msgid "We can then use this when returning the job result:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1439
msgid "Simplifying program execution with wrapping functions"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1441
msgid "While runtime programs are powerful and flexible, they are not the most friendly things to interact with. Therefore, if your program is intended to be used by others, it is best to make wrapper functions and/or classes that simplify the user experience. Moreover, such wrappers allow for validation of user inputs on the client side, which can quickly find errors that would otherwise be raised later during the execution process - something that might have taken hours waiting in queue to get to."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1443
msgid "Here we will make two helper routines. First, a job wrapper that allows us to attach and retrieve the interim results directly from the job object itself, as well as decodes for us so that the end user need not worry about formatting the results themselves."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1499
msgid "Next, we create the actual function we want users to call to execute our program. To this function we will add a series of simple validation checks (not all checks will be done for simplicity), as well as use the job wrapper defined above to simplify the output."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1599
msgid "We can now execute our runtime program via this runner function:"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1680
msgid "The interim results are now attached to the job ``interim_results`` attribute and, as expected, we see that the length matches the number of iterations performed."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1727
msgid "Conclusion"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1729
msgid "We have demonstrated how to create, upload, and use a custom Qiskit Runtime by creating our own VQE solver from scratch. This tutorial was meant to touch upon every aspect of the process for a real-world example. Within the current limitations of the runtime environment, this example should enable readers to develop their own single-file runtime program. This program is also a good starting point for exploring additional flavors of VQE runtime. For example, it is straightforward to vary the number of shots per iteration, increasing shots as the number of iterations increases. Those looking to go deeper can consider implimenting an `adaptive VQE <https://doi.org/10.1038/s41467-019-10988-2>`__, where the ansatz is not fixed at initialization."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1742
msgid "Appendix A"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1744
msgid "Here we code a simple simultaneous perturbation stochastic approximation (SPSA) optimizer for use on noisy quantum systems. Most optimizers do not handle fluctuating cost functions well, so this is a needed addition for executing on real quantum hardware."
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1842
msgid "Appendix B"
msgstr ""

#: ../../tutorials/sample_vqe_program/qiskit_runtime_vqe_program.ipynb:1844
msgid "This is a helper function that converts the Pauli operators in the strings that define the Hamiltonian operators into the appropriate measurements at the end of the circuits. For :math:`X` operators this involves adding an :math:`H` gate to the qubits to be measured, whereas a :math:`Y` operator needs :math:`S^{+}` followed by a :math:`H`. Other choices of Pauli operators require no additional gates prior to measurement."
msgstr ""

